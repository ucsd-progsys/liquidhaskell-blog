<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>LiquidHaskell Blog</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/atom.xml" rel="self" />
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/atom.xml</id>
    <author>
        <name>Ranjit Jhala</name>
        <email>rjhala@eng.ucsd.edu</email>
    </author>
    <updated>2020-08-20T00:00:00Z</updated>
    <entry>
    <title>LiquidHaskell is a GHC Plugin</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2020/08/20/lh-as-a-ghc-plugin.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2020/08/20/lh-as-a-ghc-plugin.lhs</id>
    <published>true</published>
    <updated>2020-08-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>LiquidHaskell is a GHC Plugin</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			Aug 20, 2020
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged &#39;basic&#39;." href="/tags/basic.html">basic</a>
              
            </div>

            <br>
			            <div class="hidden">

</div>
<p>I enjoy working with LH. However, I’d be the very first to confess
that it has been incredibly tedious to get to work on <em>existing</em> code
bases, for various reasons.</p>
<ol type="1">
<li><p>LH ran <em>one file at a time</em>; it was a hassle to <strong>systematically analyze</strong>
all the modules in a single package.</p></li>
<li><p>LH had <em>no notion of packages</em>; it was impossible to <strong>import specifications</strong>
across packages.</p></li>
<li><p>LH had <em>no integration</em> with the standard compilation cycle; it was difficult
to get robust, <strong>development-time feedback</strong> using <code>ghci</code> based tools.</p></li>
</ol>
<p>I’m delighted to announce the release of <a href="http://ucsd-progsys.github.io/liquidhaskell/">LH version 0.8.10.2</a>.</p>
<p>Thanks to the ingenuity and tireless efforts of our friends <a href="http://www.alfredodinapoli.com/">Alfredo Di Napoli</a>
and <a href="https://www.andres-loeh.de/">Andres Loh</a> at <a href="http://www.well-typed.com/">Well-Typed</a> this new version
solves all three of the above problems in a single stroke, making it vastly simpler
(dare I say, quite straightforward!) to run LH on your Haskell code.</p>
<!-- more -->
<p>Alfredo and Andres’ key insight was that all the above problems could be solved if
LH could be re-engineered as a <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html#compiler-plugins">GHC Compiler Plugin</a>
using hooks that GHC exposes to integrate external checkers during compilation.
I strongly encourage you to check out Alfredo’s talk at the <a href="https://icfp20.sigplan.org/details/hiw-2020-papers/1/Liquid-Haskell-as-a-GHC-Plugin">Haskell Implementor’s Workshop</a>
if you want to learn more about the rather non-trivial mechanics of how this plugin was engineered.
However, in this post, lets look at <em>how</em> and <em>why</em> to use the plugin,
in particular, how the plugin lets us</p>
<ol type="1">
<li><p>Use GHC’s dependency resolution to analyze entire packages with minimal recompilation;</p></li>
<li><p>Ship refined type specifications for old or new packages, and have them be verified at client code;</p></li>
<li><p>Use tools like <code>ghci</code> based IDE tooling (e.g. <code>ghcid</code> or <code>ghcide</code> to get interactive feedback),</p></li>
</ol>
<p>all of which ultimately, I hope, make Liquid Haskell easier to use.</p>
<h2 id="analyzing-packages">1. Analyzing Packages</h2>
<p>First, lets see a small “demo” of how to <em>use</em> the plugin to compile
a small <a href="https://github.com/ucsd-progsys/lh-plugin-demo"><code>lh-plugin-demo</code></a>
package with two modules</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Demo.Lib</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">{-@ type Pos = {v:Int | 0 &lt; v} @-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">{-@ incr :: Pos -&gt; Pos @-}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">incr ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>incr x <span class="ot">=</span> x <span class="op">-</span> <span class="dv">1</span></span></code></pre></div>
<p>which defines a function <code>incr</code> that consumes and returns positive integers, and</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Demo.Client</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Demo.Lib</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ot">bump ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>bump n <span class="ot">=</span> incr n</span></code></pre></div>
<p>which imports <code>Demo.Lib</code> and uses <code>incr</code>.</p>
<h3 id="updating-.cabal-to-compile-with-the-lh-plugin">Updating <code>.cabal</code> to compile with the LH plugin</h3>
<p>To “check” this code with LH we need only tell GHC to use it as a plugin, in two steps.</p>
<ol type="1">
<li>First, adding a dependency to LH in the <code>.cabal</code> file (or <code>package.yaml</code>)</li>
</ol>
<pre><code>  build-depends:
      liquid-base,
      liquidhaskell &gt;= 0.8.10</code></pre>
<ol start="2" type="1">
<li>Second, tell GHC to use the plugin</li>
</ol>
<pre><code>  ghc-options: -fplugin=LiquidHaskell</code></pre>
<p>That’s it. Now, everytime you (re-)build the code, GHC will <em>automatically</em>
run LH on the changed modules! If you use <code>stack</code> you may have to specify
a few more dependencies, as the various packages are not (yet) on stackage,
as shown in the <a href="https://github.com/ucsd-progsys/lh-plugin-demo/blob/main/stack.yaml">demo <code>stack.yaml</code></a>.
No extra dependencies are needede if you use <code>cabal-v2</code>. In both cases,
you can use the respective files <a href="https://github.com/ucsd-progsys/lh-plugin-demo/blob/main/stack.yaml.github"><code>stack.yaml</code></a>
and <a href="https://github.com/ucsd-progsys/lh-plugin-demo/blob/main/cabal.project.github"><code>cabal.project</code></a>
point to specific git snapshots if you want to use the most recent versions.
If you clone the repo and run, e.g. <code>cabal v2-build</code> or <code>stack build</code> you’ll get the following result, after the relevant dependencies
are downloaded and built of course…</p>
<pre><code>rjhala@khao-soi ~/r/lh-demo (main)&gt; stack build
lh-plugin-demo&gt; configure (lib)
Configuring lh-plugin-demo-0.1.0.0...
lh-plugin-demo&gt; build (lib)
Preprocessing library for lh-plugin-demo-0.1.0.0..
Building library for lh-plugin-demo-0.1.0.0..
[1 of 2] Compiling Demo.Lib

**** LIQUID: UNSAFE ************************************************************

/Users/rjhala/research/lh-demo/src/Demo/Lib.hs:7:1: error:
    Liquid Type Mismatch
    .
    The inferred type
      VV : {v : GHC.Types.Int | v == x - 1}
    .
    is not a subtype of the required type
      VV : {VV : GHC.Types.Int | 0 &lt; VV}
    .
    in the context
      x : {v : GHC.Types.Int | 0 &lt; v}
  |
7 | incr x = x - 1
  | ^^^^^^^^^^^^^^</code></pre>
<p>oops, of course that <code>(-)</code> should be a <code>(+)</code> if we want the output to also be <em>positive</em> so
lets edit the code to</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>incr x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">1</span></span></code></pre></div>
<p>and now we get</p>
<pre><code>rjhala@khao-soi ~/r/lh-plugin-demo (main)&gt; stack build
lh-plugin-demo&gt; configure (lib)
Configuring lh-plugin-demo-0.1.0.0...

lh-plugin-demo&gt; build (lib)
Preprocessing library for lh-plugin-demo-0.1.0.0..
Building library for lh-plugin-demo-0.1.0.0..
[1 of 2] Compiling Demo.Lib

**** LIQUID: SAFE (2 constraints checked) *****************************
[2 of 2] Compiling Demo.Client

**** LIQUID: UNSAFE ***************************************************

/Users/rjhala/lh-plugin-demo/src/Demo/Client.hs:6:15: error:
    Liquid Type Mismatch
    .
    The inferred type
      VV : {v : GHC.Types.Int | v == n}
    .
    is not a subtype of the required type
      VV : {VV : GHC.Types.Int | 0 &lt; VV}
    .
    in the context
      n : GHC.Types.Int
  |
6 | bump n = incr n
  |               ^</code></pre>
<p>That is, during the build, LH complains that <code>incr</code> is being called with a value <code>n</code>
that is not strictly positive as required by <code>incr</code>. To fix the code, we can edit it
in various ways, e.g. to only call <code>incr</code> if <code>n &gt; 0</code></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>bump n </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> n <span class="op">&gt;</span> <span class="dv">0</span>     <span class="ot">=</span> incr n</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dv">0</span></span></code></pre></div>
<p>and now the code builds successfully</p>
<pre><code>rjhala@khao-soi ~/r/lh-plugin-demo (main)&gt; stack build
lh-plugin-demo&gt; configure (lib)
Configuring lh-plugin-demo-0.1.0.0...
lh-plugin-demo&gt; build (lib)
Preprocessing library for lh-plugin-demo-0.1.0.0..
Building library for lh-plugin-demo-0.1.0.0..
[2 of 2] Compiling Demo.Client

**** LIQUID: SAFE (2 constraints checked) ****************************
lh-plugin-demo&gt; copy/register
Installing library in ... 
Registering library for lh-plugin-demo-0.1.0.0..</code></pre>
<h3 id="benefits">Benefits</h3>
<p>There are a couple of benefits to note immediately</p>
<ul>
<li><p>A plain <code>stack build</code> or <code>cabal v2-build</code> takes care of all the installing <em>and</em> checking!</p></li>
<li><p>No need to separately <em>install</em> LH; its part of the regular build.</p></li>
<li><p>GHC’s recompilation machinery ensures that only the relevant
modules are checked, e.g. the second time round, LH did not need
to analyze <code>Lib.hs</code> only <code>Client.hs</code></p></li>
</ul>
<h2 id="shipping-specifications-with-packages">2. Shipping Specifications with Packages</h2>
<p>While the above is nice, in principle it could have been done
with some clever <code>makefile</code> trickery (perhaps?). What I’m much
more excited about is that now, for the first time, you can
<em>ship refinement type specifications within plain Haskell packages</em>.</p>
<p>For example, consider a different <a href="https://github.com/ucsd-progsys/lh-plugin-demo-client">lh-plugin-demo-client</a>
package that uses <code>incr</code> from <code>lh-plugin-demo</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bump ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>bump n</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> n <span class="op">&gt;</span> <span class="dv">0</span>     <span class="ot">=</span> incr n</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> incr (<span class="dv">0</span> <span class="op">-</span> n)</span></code></pre></div>
<p>Again, the <code>lh-plugin-demo-client.cabal</code> file need only specify the various
dependencies:</p>
<pre><code>  build-depends:
      liquid-base,
      liquidhaskell,
      lh-plugin-demo</code></pre>
<p>and that GHC should use the plugin</p>
<pre><code>  ghc-options: -fplugin=LiquidHaskell</code></pre>
<p>and lo! a plain <code>stack build</code> or <code>cabal v2-build</code> takes care of all the rest.</p>
<pre><code>rjhala@khao-soi ~/r/lh-plugin-demo-client (main)&gt; stack build
lh-plugin-demo-client&gt; configure (lib)
Configuring lh-plugin-demo-client-0.1.0.0...

lh-plugin-demo-client&gt; build (lib)
Preprocessing library for lh-plugin-demo-client-0.1.0.0..
Building library for lh-plugin-demo-client-0.1.0.0..
[1 of 1] Compiling Demo.ExternalClient

**** LIQUID: UNSAFE ****************************************************

/Users/rjhala/lh-plugin-demo-client/src/Demo/ExternalClient.hs:8:22: error:
    Liquid Type Mismatch
    .
    The inferred type
      VV : {v : GHC.Types.Int | v == 0 - n}
    .
    is not a subtype of the required type
      VV : {VV : GHC.Types.Int | VV &gt; 0}
    .
    in the context
      n : GHC.Types.Int
  |
8 |   | otherwise = incr (0 - n)
  |                      ^^^^^^^</code></pre>
<p>(Whoops another off by one error, lets fix it!)</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bump ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>bump n</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> n <span class="op">&gt;</span> <span class="dv">0</span>     <span class="ot">=</span> incr n</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> incr (<span class="dv">1</span> <span class="op">-</span> n)</span></code></pre></div>
<p>and now all is well</p>
<pre><code>rjhala@khao-soi ~/r/lh-plugin-demo-client (main)&gt; stack build --fast
lh-plugin-demo-client&gt; configure (lib)
Configuring lh-plugin-demo-client-0.1.0.0...
lh-plugin-demo-client&gt; build (lib)
Preprocessing library for lh-plugin-demo-client-0.1.0.0..
Building library for lh-plugin-demo-client-0.1.0.0..
[1 of 1] Compiling Demo.ExternalClient

**** LIQUID: SAFE (3 constraints checked) *****************************

lh-plugin-demo-client&gt; copy/register
Installing library in ... 
Registering library for lh-plugin-demo-client-0.1.0.0..</code></pre>
<h3 id="prelude-specifications">Prelude Specifications</h3>
<p>Did you notice the strange <code>liquid-base</code> dependency in the cabal files?</p>
<p>Previously, LH came installed with a “built-in” set of specifications for
various <code>prelude</code> modules. This was <em>hacked</em> inside LH in a rather unfortunate
manner, which made these specifications very difficult to extend.</p>
<p>Moving forward, all the refinement specifications e.g. for <code>GHC.List</code> or <code>Data.Vector</code>
or <code>Data.Set</code> or <code>Data.Bytestring</code> simply live in packages that <em>mirror</em> the original
versions, e.g. <code>liquid-base</code>, <code>liquid-vector</code>, <code>liquid-containers</code>, <code>liquid-bytestring</code>.
Each <code>liquid-X</code> package directly <em>re-exports</em> all the contents of the corresponding <code>X</code>
package, but with any additional refinement type specifications.</p>
<p>Thus, all the refined types for various prelude operations like <code>(+)</code> or <code>(-)</code> or <code>head</code>
and so on, now ship with <code>liquid-base</code> and we add that dependency <strong>instead of</strong> base.
Similarly, if you want to verify that <em>your</em> code has no <code>vector</code>-index overflow errors,
you simply build with <code>liquid-vector</code> <strong>instead of</strong> <code>vector</code>! Of course, in an ideal,
and hopefully not too distant future, we’d directly include the refinement types inside
<code>vector</code>, <code>containers</code> or <code>bytestring</code> respectively.</p>
<h3 id="benefits-1">Benefits</h3>
<p>So to recap, the plugin offers several nice benefits with respect to <em>shipping specifications</em></p>
<ul>
<li><p>Refined signatures are bundled together with packages,</p></li>
<li><p>Importing packages with refined signatures automatically ensures those signatures are
checked on client code,</p></li>
<li><p>You can (optionally) use refined versions of <code>prelude</code> signatures, and hence, even
write refined versions of your favorite <em>custom preludes</em>.</p></li>
</ul>
<h2 id="editor-tooling">3. Editor Tooling</h2>
<p>I saved <em>my</em> favorite part for the end.</p>
<p>What I have enjoyed the most about the plugin is that now (almost) all the GHC-based
tools that I use in my regular Haskell development workflow, automatically incorporate
LH too! For example, reloading a module in <code>ghci</code> automatically re-runs LH on that file.</p>
<h3 id="ghcid"><code>ghcid</code></h3>
<p>This means, that the mega robust, editor-independent <code>ghcid</code> now automatically
produces LH type errors when you save a file. Here’s <code>ghcid</code> running in a terminal.</p>
<figure>
<img src="/static/img/plugin-ghcid.gif" alt="ghcid" /><figcaption aria-hidden="true">ghcid</figcaption>
</figure>
<h3 id="vscode"><code>vscode</code></h3>
<p>Editor plugins now produce little red squiggles for LH errors too.
Here’s <code>code</code> with the <code>Simple GHC (Haskell) Integration</code> plugin</p>
<p><img src="/static/img/plugin-vscode.gif" /></p>
<h3 id="emacs"><code>emacs</code></h3>
<p>Here’s <code>doom-emacs</code> with the <code>dante</code> plugin</p>
<p><img src="/static/img/plugin-emacs.gif" /></p>
<h3 id="vim"><code>vim</code></h3>
<p>And here is <code>neovim</code> with <code>ALE</code> and the <code>stack-build</code> linter</p>
<p><img src="/static/img/plugin-vim.png" /></p>
<h3 id="benefits-2">Benefits</h3>
<ul>
<li>Some of this <em>was</em> possible before: we had to write special LH modes for different
editors – special thanks to <a href="https://github.com/alanz">Alan Zimmerman’s</a> fantastic
haskell-ide-engine!. However, now we can simply work with the increasingly more robust
GHCi and Language-Server based tools already available for major editors and IDEs.</li>
</ul>
<h2 id="caveats">4. Caveats</h2>
<p>Of course, all the above is quite new, and so there are a few things to watch out for.</p>
<ul>
<li><p>First, for certain kinds of code, LH can take much longer than GHC to check a file.
This means, it may actually be too slow to run on every save, and you may want to
tweak your <code>.cabal</code> file to <em>only</em> run the plugin during particular builds, not on
every file update.</p></li>
<li><p>Second, the <code>liquid-X</code> machinery is designed to allow drop in replacements for various
base packages; it appears to work well in our testing, but if you try it, do let us know
if you hit some odd problems that we may not have anticipated.</p></li>
</ul>
<h2 id="summary">Summary</h2>
<p>Hopefully the above provides an overview of the new plugin mode: how it can be used,
and what things it enables. In particular, by virtue of being a GHC plugin, LH can now</p>
<ol type="1">
<li><p>Run on entire Haskell packages;</p></li>
<li><p>Export and import specifications across packages;</p></li>
<li><p>Provide errors via existing GHC/i based editor tooling.</p></li>
</ol>
<p>All of which, I hope, makes it a lot easier to run LH on your code.</p>
<p>Our most profound thanks to the <a href="https://nsf.gov/">National Science Foundation</a>:
this work was made possible by the support provided by grant 1917854:
“FMitF: Track II: Refinement Types in the Haskell Ecosystem”.</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2020/08/20/lh-as-a-ghc-plugin.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2020/08/20/lh-as-a-ghc-plugin.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Polymorphic Perplexion</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2020/04/12/polymorphic-perplexion.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2020/04/12/polymorphic-perplexion.lhs</id>
    <published>true</published>
    <updated>2020-04-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Polymorphic Perplexion</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			Apr 12, 2020
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged &#39;basic&#39;." href="/tags/basic.html">basic</a>
              
            </div>

            <br>
			            <p>Polymorphism plays a vital role in automating verification in LH.
However, thanks to its ubiquity, we often take it for granted, and
it can be quite baffling to figure out why verification fails with
monomorphic signatures. Let me explain why, using a simple example
that has puzzled me and other users several times.</p>
<!-- more -->
<div class="hidden">
<pre><span class=hs-linenum>22: </span>
<span class=hs-linenum>23: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>PolymorphicPerplexion</span> <span class='hs-keyword'>where</span>
</pre>
</div>
<h2 id="a-type-for-ordered-lists">A Type for Ordered Lists</h2>
<p><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/2013/07/29/putting-things-in-order.lhs/">Previously</a>
we have seen how you can use LH to define a type of lists whose values are in increasing
(ok, non-decreasing!) order.</p>
<p>First, we define an <code>IncList a</code> type, with <code>Emp</code> (“empty”)
and <code>:&lt;</code> (“cons”) constructors.</p>
<pre><span class=hs-linenum>38: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Emp</span>
<span class=hs-linenum>39: </span>               <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conop'>:&lt;</span><span class='hs-layout'>)</span> <span class='hs-layout'>{</span> <span class='hs-varid'>hd</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>tl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>40: </span>
<span class=hs-linenum>41: </span><span class='hs-keyword'>infixr</span> <span class='hs-num'>9</span> <span class='hs-conop'>:&lt;</span>
</pre>
<p>Next, we refine the type to specify that each “cons” <code>:&lt;</code>
constructor takes as input a <code>hd</code> and a <code>tl</code> which must
be an <code>IncList a</code> of values <code>v</code> each of which is greater
than <code>hd</code>.</p>
<pre><span class=hs-linenum>50: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Emp</span> 
<span class=hs-linenum>51: </span>                   <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conop'>:&lt;</span><span class='hs-layout'>)</span> <span class='hs-layout'>{</span> <span class='hs-varid'>hd</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>tl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IncList</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>hd</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span><span class='hs-layout'>}</span>  
<span class=hs-linenum>52: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>We can confirm that the above definition ensures that the only
<em>legal</em> values are increasingly ordered lists, as LH accepts
the first list below, but rejects the second where the elements
are out of order.</p>
<pre><span class=hs-linenum>61: </span><span class='hs-definition'>legalList</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IncList</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>62: </span><a class=annot href="#"><span class=annottext>(PolymorphicPerplexion.IncList GHC.Types.Int)</span><span class='hs-definition'>legalList</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>2</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>3</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>{VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}</span><span class='hs-conid'>Emp</span></a>
<span class=hs-linenum>63: </span>
<span class=hs-linenum>64: </span><span class='hs-definition'>illegalList</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IncList</span> <span class='hs-conid'>Int</span> 
<span class=hs-linenum>65: </span><a class=annot href="#"><span class=annottext>(PolymorphicPerplexion.IncList GHC.Types.Int)</span><span class='hs-definition'>illegalList</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>0</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>3</span></a> <span class='hs-conop'>:&lt;</span> <span class=hs-error><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>2</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-conop'>:&lt;</span></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}</span><span class='hs-conid'>Emp</span></a></span>
</pre>
<h2 id="a-polymorphic-insertion-sort">A Polymorphic Insertion Sort</h2>
<p>Next, lets write a simple <em>insertion-sort</em> function that
takes a plain unordered list of <code>[a]</code> and returns the elements
in increasing order:</p>
<pre><span class=hs-linenum>76: </span><span class='hs-definition'>insertSortP</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>77: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Classes.Ord&lt;[]&gt; a) =&gt;
[a] -&gt; (PolymorphicPerplexion.IncList a)</span><span class='hs-definition'>insertSortP</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <a class=annot href="#"><span class=annottext>a -&gt; (PolymorphicPerplexion.IncList a) -&gt; (PolymorphicPerplexion.IncList a)</span><span class='hs-varid'>insertP</span></a> <a class=annot href="#"><span class=annottext>{VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}</span><span class='hs-conid'>Emp</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | len v &gt;= 0
           &amp;&amp; v == xs}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>78: </span>
<span class=hs-linenum>79: </span><span class='hs-definition'>insertP</span>             <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>80: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Classes.Ord&lt;[]&gt; a) =&gt;
a -&gt; (PolymorphicPerplexion.IncList a) -&gt; (PolymorphicPerplexion.IncList a)</span><span class='hs-definition'>insertP</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>y</span></a> <span class='hs-conid'>Emp</span>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == y}</span><span class='hs-varid'>y</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>{VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}</span><span class='hs-conid'>Emp</span></a>
<span class=hs-linenum>81: </span><span class='hs-definition'>insertP</span> <span class='hs-varid'>y</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
<span class=hs-linenum>82: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == y}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a>         <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == y}</span><span class='hs-varid'>y</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>{v : (PolymorphicPerplexion.IncList {VV : a | x &lt;= VV}) | v == xs}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>83: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>(PolymorphicPerplexion.IncList a)</span><span class='hs-varid'>insertP</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == y}</span><span class='hs-varid'>y</span></a> <a class=annot href="#"><span class=annottext>{v : (PolymorphicPerplexion.IncList {VV : a | x &lt;= VV}) | v == xs}</span><span class='hs-varid'>xs</span></a>
</pre>
<p>Happily, LH is able to verify the above code without any trouble!
(If that seemed too easy, don’t worry: if you mess up the comparison,
e.g. change the guard to <code>x &lt;= y</code> LH will complain about it.)</p>
<h2 id="a-monomorphic-insertion-sort">A Monomorphic Insertion Sort</h2>
<p>However, lets take the <em>exact</em> same code as above <em>but</em> change
the type signatures to make the functions <em>monomorphic</em>, here,
specialized to <code>Int</code> lists.</p>
<pre><span class=hs-linenum>99: </span><span class='hs-definition'>insertSortM</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-conid'>Int</span> 
<span class=hs-linenum>100: </span><a class=annot href="#"><span class=annottext>[GHC.Types.Int] -&gt; (PolymorphicPerplexion.IncList GHC.Types.Int)</span><span class='hs-definition'>insertSortM</span></a> <a class=annot href="#"><span class=annottext>[GHC.Types.Int]</span><span class='hs-varid'>xs</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; (PolymorphicPerplexion.IncList GHC.Types.Int) -&gt; (PolymorphicPerplexion.IncList GHC.Types.Int)</span><span class='hs-varid'>insertM</span></a> <a class=annot href="#"><span class=annottext>{VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}</span><span class='hs-conid'>Emp</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | len v &gt;= 0
                       &amp;&amp; v == xs}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>101: </span>
<span class=hs-linenum>102: </span><span class='hs-definition'>insertM</span>            <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-conid'>Int</span> 
<span class=hs-linenum>103: </span><a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; (PolymorphicPerplexion.IncList GHC.Types.Int) -&gt; (PolymorphicPerplexion.IncList GHC.Types.Int)</span><span class='hs-definition'>insertM</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a> <span class='hs-conid'>Emp</span>      <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == y}</span><span class='hs-varid'>y</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>{VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}</span><span class='hs-conid'>Emp</span></a>
<span class=hs-linenum>104: </span><span class='hs-definition'>insertM</span> <span class='hs-varid'>y</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
<span class=hs-linenum>105: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == y}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>x</span></a>         <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == y}</span><span class='hs-varid'>y</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>x</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>{v : (PolymorphicPerplexion.IncList {v : GHC.Types.Int | x &lt;= v}) | v == xs}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>106: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == x}</span><span class='hs-varid'>x</span></a> <span class='hs-conop'>:&lt;</span> <span class=hs-error><a class=annot href="#"><span class=annottext>(PolymorphicPerplexion.IncList GHC.Types.Int)</span><span class='hs-varid'>insertM</span></a></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == y}</span><span class='hs-varid'>y</span></a></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : (PolymorphicPerplexion.IncList {v : GHC.Types.Int | x &lt;= v}) | v == xs}</span><span class='hs-varid'>xs</span></a></span>
</pre>
<p>Huh? Now LH appears to be unhappy with the code! How is this possible?</p>
<p>Lets look at the type error:</p>
<pre><span class=hs-linenum>114: </span> <span class='hs-varop'>/</span><span class='hs-conid'>Users</span><span class='hs-varop'>/</span><span class='hs-varid'>rjhala</span><span class='hs-varop'>/</span><span class='hs-conid'>PerplexingPolymorphicProperties.lhs</span><span class='hs-conop'>:</span><span class='hs-num'>80</span><span class='hs-conop'>:</span><span class='hs-num'>27</span><span class='hs-comment'>-</span><span class='hs-num'>38</span><span class='hs-conop'>:</span> <span class='hs-conid'>Error</span><span class='hs-conop'>:</span> <span class='hs-conid'>Liquid</span> <span class='hs-conid'>Type</span> <span class='hs-conid'>Mismatch</span>
<span class=hs-linenum>115: </span>  
<span class=hs-linenum>116: </span> <span class='hs-num'>80</span> <span class='hs-keyglyph'>|</span>   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>insertM</span> <span class='hs-varid'>y</span> <span class='hs-varid'>xs</span>
<span class=hs-linenum>117: </span>                                <span class='hs-varop'>^^^^^^^^^^^^</span>
<span class=hs-linenum>118: </span>   <span class='hs-conid'>Inferred</span> <span class='hs-keyword'>type</span>
<span class=hs-linenum>119: </span>     <span class='hs-conid'>VV</span> <span class='hs-conop'>:</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>120: </span>  
<span class=hs-linenum>121: </span>   <span class='hs-varid'>not</span> <span class='hs-varid'>a</span> <span class='hs-varid'>subtype</span> <span class='hs-keyword'>of</span> <span class='hs-conid'>Required</span> <span class='hs-keyword'>type</span>
<span class=hs-linenum>122: </span>     <span class='hs-conid'>VV</span> <span class='hs-conop'>:</span> <span class='hs-layout'>{</span><span class='hs-conid'>VV</span> <span class='hs-conop'>:</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;=</span> <span class='hs-conid'>VV</span><span class='hs-layout'>}</span>
<span class=hs-linenum>123: </span>  
<span class=hs-linenum>124: </span>   <span class='hs-conid'>In</span> <span class='hs-conid'>Context</span>
<span class=hs-linenum>125: </span>     <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-conid'>Int</span>
</pre>
<p>LH <em>expects</em> that since we’re using the “cons” operator <code>:&lt;</code> the “tail”
value <code>insertM y xs</code> must contain values <code>VV</code> that are greater than the
“head” <code>x</code>. The error says that, LH cannot prove this requirement of
<em>actual</em> list <code>insertM y xs</code>.</p>
<p>Hmm, well thats a puzzler. Two questions that should come to mind.</p>
<ol type="1">
<li><p><em>Why</em> does the above fact hold in the first place?</p></li>
<li><p><em>How</em> is LH able to deduce this fact with the <em>polymorphic</em> signature but not the monomorphic one?</p></li>
</ol>
<p>Lets ponder the first question: why <em>is</em> every element
of <code>insert y xs</code> in fact larger than <code>x</code>? For three reasons:</p>
<ol type="a">
<li><p>every element in <code>xs</code> is larger than <code>x</code>, as the
list <code>x :&lt; xs</code> was ordered,</p></li>
<li><p><code>y</code> is larger than <code>x</code> as established by the <code>otherwise</code> and crucially</p></li>
<li><p>the elements returned by <code>insert y xs</code> are either <code>y</code> or from <code>xs</code>!</p></li>
</ol>
<p>Now onto the second question: how <em>does</em> LH verify the polymorphic code,
but not the monomorphic one? The reason is the fact (c)! LH is a <em>modular</em>
verifier, meaning that the <em>only</em> information that it has about the behavior
of <code>insert</code> at a call-site is the information captured in the (refinement)
<em>type specification</em> for <code>insert</code>. The <em>polymorphic</em> signature:</p>
<pre><span class=hs-linenum>156: </span><span class='hs-definition'>insertP</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span>
</pre>
<p>via <em>parametricity</em>, implicitly states fact (c). That is, if at a call-site
<code>insertP y xs</code> we pass in a value that is greater an <code>x</code> and a list of values
greater than <code>x</code> then via <em>polymorphic instantiation</em> at the call-site, LH
infers that the returned value must also be a list of elements greater than <code>x</code>!</p>
<p>However, the <em>monomorphic</em> signature</p>
<pre><span class=hs-linenum>167: </span><span class='hs-definition'>insertM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-conid'>Int</span> 
</pre>
<p>offers no such insight. It simply says the function takes in an <code>Int</code> and another
ordered list of <code>Int</code> and returns another ordered list, whose actual elements could
be arbitrary <code>Int</code>. Specifically, at the call-site <code>insertP y xs</code> LH has no way to
conclude the the returned elements are indeed greater than <code>x</code> and hence rejects
the monomorphic code.</p>
<h2 id="perplexity">Perplexity</h2>
<p>While parametricity is all very nice, and LH’s polymorphic instanatiation is very
clever and useful, it can also be quite mysterious. For example, q curious user
Oisín <a href="https://github.com/ucsd-progsys/liquidhaskell-tutorial/issues/91">pointed out</a>
that while the code below is <em>rejected</em> that if you <em>uncomment</em> the type signature
for <code>go</code> then it is <em>accepted</em> by LH!</p>
<pre><span class=hs-linenum>187: </span><span class='hs-definition'>insertSortP'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IncList</span> <span class='hs-varid'>a</span> 
<span class=hs-linenum>188: </span><a class=annot href="#"><span class=annottext>forall a .
(GHC.Classes.Ord&lt;[]&gt; a) =&gt;
[a] -&gt; (PolymorphicPerplexion.IncList a)</span><span class='hs-definition'>insertSortP'</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(PolymorphicPerplexion.IncList a)</span><span class='hs-varid'>foldr</span></a> <a class=annot href="#"><span class=annottext>a -&gt; (PolymorphicPerplexion.IncList a) -&gt; (PolymorphicPerplexion.IncList a)</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>{VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}</span><span class='hs-conid'>Emp</span></a> 
<span class=hs-linenum>189: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>190: </span>    <span class='hs-comment'>-- go :: (Ord a) =&gt; a -&gt; IncList a -&gt; IncList a</span>
<span class=hs-linenum>191: </span>    <a class=annot href="#"><span class=annottext>a -&gt; (PolymorphicPerplexion.IncList a) -&gt; (PolymorphicPerplexion.IncList a)</span><span class='hs-varid'>go</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>y</span></a> <span class='hs-conid'>Emp</span>       <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == y}</span><span class='hs-varid'>y</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>{VV : forall a . (PolymorphicPerplexion.IncList a) | VV == Emp}</span><span class='hs-conid'>Emp</span></a>
<span class=hs-linenum>192: </span>    <span class='hs-varid'>go</span> <span class='hs-varid'>y</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-conop'>:&lt;</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
<span class=hs-linenum>193: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == y}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == y}</span><span class='hs-varid'>y</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <span class='hs-conop'>:&lt;</span> <a class=annot href="#"><span class=annottext>{v : (PolymorphicPerplexion.IncList {VV : a | x &lt;= VV}) | v == xs}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>194: </span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == x}</span><span class='hs-varid'>x</span></a> <span class='hs-conop'>:&lt;</span> <span class=hs-error><a class=annot href="#"><span class=annottext>(PolymorphicPerplexion.IncList a)</span><span class='hs-varid'>go</span></a></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{VV : a | VV == y}</span><span class='hs-varid'>y</span></a></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : (PolymorphicPerplexion.IncList {VV : a | x &lt;= VV}) | v == xs}</span><span class='hs-varid'>xs</span></a></span>
</pre>
<p>This is thoroughly perplexing, but again, is explained by the absence of
parametricity. When we <em>remove</em> the type signature, GHC defaults to giving
<code>go</code> a <em>monomorphic</em> signature where the <code>a</code> is not universally quantified,
and which roughly captures the same specification as the monomorphic <code>insertM</code>
above causing verification to fail!</p>
<p>Restoring the signature provides LH with the polymorphic specification,
which can be instantiated at the call-site to recover the fact <code>(c)</code>
that is crucial for verification.</p>
<h2 id="moral">Moral</h2>
<p>I hope that example illustrates two points.</p>
<p>First, <em>parametric polymorphism</em> lets type specifications
say a lot more than they immediately let on: so do write
polymorphic signatures whenever possible.</p>
<p>Second, on a less happy note, <em>explaining</em> why fancy type
checkers fail remains a vexing problem, whose difficulty
is compounded by increasing the cleverness of the type
system.</p>
<p>We’d love to hear any ideas you might have to solve the
explanation problem!</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2020/04/12/polymorphic-perplexion.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2020/04/12/polymorphic-perplexion.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Liquid Types vs. Floyd-Hoare Logic</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2019/10/20/why-types.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2019/10/20/why-types.lhs</id>
    <published>false</published>
    <updated>2019-10-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Liquid Types vs. Floyd-Hoare Logic</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			Oct 21, 2019
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged &#39;basic&#39;." href="/tags/basic.html">basic</a>
              
            </div>

            <br>
			            <p>Several folks who are experts in the program verification
literature have asked me some variant of the following question:</p>
<blockquote>
<p>How are <em>Liquid/Refinement</em> types different from <em>Floyd-Hoare logics</em>?</p>
</blockquote>
<p>This question always reminds me of <a href="https://yanniss.github.io/">Yannis Smaragdakis’</a> clever limerick:</p>
<blockquote>
<p>No idea is too obvious or dreary,</p>
<p>If appropriately expressed in type theory,</p>
<p>It’s a research advance,</p>
<p>That no one understands,</p>
<p>But they are all too impressed to be leery.</p>
</blockquote>
<p>That is, the above question can be rephrased as: why bother with
the hassle of encoding properties in <em>types</em> when good old-fashioned
<em>assertions</em>, <em>pre</em>- and <em>post</em>-conditions would do? Is it just a
marketing gimmick to make readers too impressed to be leery?</p>
<h2 id="the-problem-quantifiers">The Problem: Quantifiers</h2>
<p>The main <em>algorithmic</em> problem with classical Floyd-Hoare logic
is that to do useful things, you need to use <strong>universally quantified</strong>
logical formulas inside invariants, pre- and post-conditions.</p>
<p>Verification then proceeds by asking SMT solvers to check
<em>verification conditions</em> (VCs) over these quantified formulas.
While SMT solvers are marvelous technological artifacts, and I bow
to no one in my admiration of them, in reality, they work best on
formulas from a narrowly defined set of <em>decidable theories</em>.</p>
<p>In particular, they are notoriously (and justifiably!) fickle
when quizzed on VCs with quantifiers. Briefly, this is because
even if the solver “knows” the universally quantified fact:</p>
<pre><code>forall x. P(x)</code></pre>
<p>the solver doesn’t know which particular terms <code>e1</code>, <code>e2</code> or <code>e3</code>
to <strong>instantiate</strong> the fact at. That is, the solver doesn’t know
which <code>P(e1)</code> or <code>P(e2)</code> or <code>P(e3)</code> it should work with to prove
some given goal. At best, it can make some educated guesses, or
use hints from the user, but these heuristics can turn out to be
<a href="https://www.semanticscholar.org/paper/Trigger-Selection-Strategies-to-Stabilize-Program-Leino-Pit-Claudel/ca873df7c3172ab96dfc0d808e1654077c92064d">quite brittle</a> as the underlying logics
are undecidable in general. To make verification predictable,
we really want to ensure that the VCs remain decidable, and
to do so, we must steer clear of the precipice of quantification.</p>
<h2 id="the-solution-types">The Solution: Types</h2>
<p>The great thing about types, as any devotee will tell you,
is that the <em>compose</em>. Regrettably, that statement is only
comprehensible to believers. I prefer to think of it
differently: types <em>decompose</em>. To be precise:</p>
<blockquote>
<p><strong>Types <em>decompose</em> quantified assertions into quantifier-free refinements.</strong></p>
</blockquote>
<p>Let me make my point with some examples that show what verification
looks like when using Refinement Types (as implemented in <a href="https://github.com/ucsd-progsys/liquidhaskell">LiquidHaskell</a>) vs
Floyd-Hoare style contracts (as implemented in <a href="https://github.com/dafny-lang/dafny">Dafny</a>).</p>
<p>The goal of this exercise is to illustrate how types help
with verification, not to compare the tools LH and Dafny.
In particular, Dafny could profit from refinement types,
and LH could benefit from the many clever ideas embodied
within Dafny.</p>
<h2 id="example-1-properties-of-data">Example 1: Properties of Data</h2>
<p>Consider the following standard definition of a <code>List</code> datatype
in Dafny (left) and LH (right).</p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<figure>
<img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/why_types_1_1.png"
         height="200">
<figcaption>
A list data type in Dafny (L) and LiquidHaskell (R)
</figcaption>
</figure>
</div>
</div>
<p>(You can see the full definitions for <a href="https://rise4fun.com/Dafny/tkfQ">Dafny</a> and <a href="FIXME">LiquidHaskell</a>.)</p>
<h3 id="accessing-a-list">Accessing a list</h3>
<p>The two descriptions are more or less the same except for some
minor issues of concrete syntax. However, next consider the
respective implementations of a function to access the <code>ith</code>
element of a <code>List</code>. We also pass in a <code>def</code>ault value returned
when the index <code>i</code> is <em>invalid</em>.</p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<figure>
<img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/why_types_1_2.png"
       height="200">
<figcaption>
Accessing the i-th element of a list in Dafny(L) and LiquidHaskell(R)
</figcaption>
</figure>
</div>
</div>
<p>It is (usually) silly to access lists in this fashion.
I use this example merely to illustrate the common case
of defining a <em>container</em> structure (here, <code>List</code>) and
then <em>accessing</em> its contents (here, <code>ith</code>).
As such, we’d like to <em>specify</em> that the value returned
by the <code>ith</code> element is indeed in the container <em>or</em> is
the <code>def</code>ault.</p>
<p><strong>Floyd-Hoare Logic</strong></p>
<p>With classical Floyd-Hoare logic, as shown in the Dafny listing
on the left, we must spell out the specification quite explicitly.
The programmer must write an <code>elements</code> function that describes
the <em>set</em> of values in the container, and then the <em>post-condition</em>
of <code>ith</code> states that the <code>res</code> is either in that set or the default.</p>
<p>While this specification seems simple enough, we are already on
dicey terrain: how are we to encode the semantics of the
user-defined function <code>elements</code> to the SMT solver?
In the classical Floyd-Hoare approach, we must use a
<em>quantified invariant</em> of the form:</p>
<pre><code>   elements(Nil) = empty 
&amp;&amp; forall h t :: elements(Cons(h, t)) = {h} + elements(t)</code></pre>
<p>Thanks to the ingenuity of <a href="https://en.wikipedia.org/wiki/Greg_Nelson_(computer_scientist)">Greg Nelson</a> who invented the notion
of <em>triggers</em> and of <a href="http://leino.science/">Rustan Leino</a> and many others, who devised
ingenious heuristics for using them, Dafny handles the quantifier
calmly to verify the above specification for <code>ith</code>.
However, we are not always so fortunate: it frightfully easy
to run into quantifier-related problems with user-defined
functions, as we will see in due course.</p>
<p><strong>Liquid/Refinement Types</strong></p>
<p>In contrast, the liquid/refinement version is quite spare:
there <em>is</em> no extra specification beyond the code. Surely
there must be some mistake? Look again: the <em>type signature</em>
says everything we need:</p>
<blockquote>
<p>If you call <code>ith</code> with a list of <code>a</code> values and a default <code>a</code> value
then you get an <code>a</code> value”.</p>
</blockquote>
<p>That is <em>parametricity</em> removes the overhead of using an
explicit <code>elements</code> function.</p>
<h3 id="building-a-list">Building a list</h3>
<p>Next, lets extend our example to illustrate the common
situation where we want some <em>invariant</em> to be true for
<em>all</em> the values in a container. To this end, let us
write a function <code>mkList</code> that <em>builds</em> a container
with values <code>k+1</code>,…,<code>k+n</code> and then <em>test</em> that when
<code>k</code> is non-negative, any arbitrarily chosen value from
the container is indeed strictly positive.</p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<figure>
<img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/why_types_1_3.png"
       height="200">
<figcaption>
Building and accessing a list in Dafny (L) and LiquidHaskell(R)
</figcaption>
</figure>
</div>
</div>
<p>The code in Dafny and LH is more or less the same, except
for one crucial difference.</p>
<p><strong>Floyd-Hoare Logic</strong></p>
<p>Recall that the specification for <code>ith(pos, i, 1)</code> states
that the returned value is <em>some</em> element of the container
(or <code>1</code>). Thus, to verify the <code>assert</code> in <code>testPosN</code> using
classical Floyd-Hoare logic, we need a way to specify that
<em>every</em> element in <code>pos</code> is indeed strictly positive.
With classical program logics, the only way to do so is to
use a <em>universally quantified</em> post-condition, highlighted
in blue:</p>
<p>“<strong>for all</strong> <code>v</code> <em>if</em> <code>v</code> is in the elements of the <code>res</code>ult, <em>then</em> <code>v</code> is greater than <code>k</code>”</p>
<p><strong>Liquid/Refinement Types</strong></p>
<p>Regardless of my personal feelings about quantifiers,
we can agree that the version on the right is simpler
as types make it unnecessary to mention <code>elements</code> or
<code>forall</code>. Instead, LH <em>infers</em></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mkList ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> k<span class="op">:</span><span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">List</span> {v<span class="op">:</span><span class="dt">Int</span> <span class="op">|</span> k <span class="op">&lt;</span> v}</span></code></pre></div>
<p>That is, that the output type of <code>mkList</code> is a
list of values <code>v</code> that are all greater than <code>k</code>.
The scary <em>forall</em> has been replaced by the friendly
<em>type constructor</em> <code>List</code>. In other words, types
allow us to <em>decompose</em> the monolithic universally
quantified invariant into:</p>
<ol type="1">
<li>a <em>quantifier-free</em> refinement <code>k &lt; v</code>, and</li>
<li>a type <em>constructor</em> that implicitly “quantifies” over the container’s elements.</li>
</ol>
<h3 id="lesson-decomposition-enables-inference">Lesson: Decomposition Enables Inference</h3>
<p>Am I cheating? After all, what prevents Dafny from
<em>inferring</em> the same post-condition as LH?</p>
<p>Once again, quantifiers are the villain.</p>
<p>There have been many decades worth of papers on the
topic of inferring quantified invariants, but save
some nicely circumscribed use-cases these methods
turn out to be rather difficult to get working
efficiently and predictably enough to be practical.
In contrast, once the quantifiers are decomposed
away, even an extremely basic approach called
<a href="http://www-verimag.imag.fr/~graf/PAPERS/GrafSaidi97.pdf">Monomial Predicate Abstraction</a>,
or more snappily, <a href="https://dl.acm.org/citation.cfm?id=730008">Houdini</a>, suffices
to infer the above liquid type.</p>
<h2 id="example-2-properties-of-structures">Example 2: Properties of Structures</h2>
<p>Recall that when discussing the user-defined <code>elements</code> function above,
I had issued some dark warnings about quantifier-related problems that
arise from user-defined functions. Allow me to explain with another
simple example, that continues with the <code>List</code> datatype defined above.</p>
<p>(You can see the full definitions for <a href="https://rise4fun.com/Dafny/nphIv">Dafny</a> and <a href="FIXME">LiquidHaskell</a>.)</p>
<h3 id="specifying-a-size-function">Specifying a <code>size</code> Function</h3>
<p>Lets write the usual <em>recursive</em> function that computes the <code>size</code>
of a list. The definitions are mostly identical, except for the green
<code>measure</code> highlight that we will discuss below.</p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<figure>
<img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/why_types_2_1.png"
       height="200">
<figcaption>
A function defining the size of a list in Dafny (L) and LiquidHaskell (R)
</figcaption>
</figure>
</div>
</div>
<p><strong>Floyd-Hoare Logic</strong></p>
<p>SMT solvers are restricted to a set of <em>ground</em> theories and hence,
do not “natively” understand user-defined functions. Instead, the
verifer must <em>teach</em> the SMT solver how to reason about formulas (VCs)
containing uses of user-defined functions like <code>size</code>.
In the classical Floyd-Hoare approach, this is done by converting
the definition of <code>size</code> into a universally quantified <em>axiom</em> like:</p>
<pre><code>size Nil == 0  &amp;&amp; forall h, t :: size (Cons h t) = 1 + size t</code></pre>
<p>A quantifier! By the pricking of my thumbs, something wicked this way comes…</p>
<p><strong>Liquid/Refinement Types</strong></p>
<p>With a more <em>type-centric</em> view, we can think of the recursive
function <code>size</code> as a way to <em>decorate</em> or <em>refine</em> the types of
the <em>data constructors</em>. So, when you write the definition in
the green box above, specifically when you add the <code>measure</code>
annotation, the function is converted to <em>strengthened</em>
versions for the types of the constructors <code>Nil</code> and <code>Cons</code>,
so its as if we had defined the list type as two constructor
functions</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cons</span><span class="ot"> ::</span> h<span class="op">:</span>a <span class="ot">-&gt;</span> t<span class="op">:</span><span class="dt">List</span> a <span class="ot">-&gt;</span> {v<span class="op">:</span><span class="dt">List</span> a <span class="op">|</span> size v <span class="op">==</span> <span class="dv">1</span> <span class="op">+</span> size t}</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span><span class="ot">  ::</span> {v<span class="op">:</span><span class="dt">List</span> a <span class="op">|</span> size v <span class="op">==</span> <span class="dv">0</span>} </span></code></pre></div>
<p>That is, the bodies of the measures get translated to refinements
on the output types of the corresponding constructors. After this,
the SMT solver “knows nothing” about the semantics of <code>size</code>, except
that it is a function. In logic-speak, <code>size</code> is <strong>uninterpreted</strong>
in the refinement, and there are no quantified axioms. That is, we
choose to keep SMT solver blissfully ignorant about the semantics
of <code>size</code>. How could this possibly be a good thing?</p>
<h3 id="verifying-the-size-of-a-list">Verifying the <code>size</code> of a List</h3>
<p>Next, lets see what happens when we write a simple test that builds
a small list with two elements and <code>assert</code>s that the lists <code>size</code>
is indeed <code>2</code>:</p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<figure>
<img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/why_types_2_2.png"
       height="200">
<figcaption>
Verifying the size of a list in Dafny (L) and LiquidHaskell (R)
</figcaption>
</figure>
</div>
</div>
<p><strong>Floyd-Hoare Logic</strong></p>
<p>To get Dafny to verifier to sign off on the <code>assert (size(pos) == 2)</code>
we have to add a mysterious <em>extra assertion</em> that checks the size of
the intermediate value <code>Cons (1, Nil)</code>. (Without it, verification fails.)</p>
<p>Huh? Pesky quantifiers.</p>
<p>The SMT solver doesn’t know <em>where</em> to instantiate the <code>size</code> axom.
In this carefully chosen, but nevertheless simple situation, Dafny’s
instantiation heuristics come up short. I had to help them along by
guessing this intermediate assertion, which effectively “adds” the
fact that the size of the intermediate list is 1, thereby letting
the SMT solver prove the second assertion.</p>
<p><strong>Liquid/Refinement Types</strong></p>
<p>In contrast, with types, the solver is able to verify the code without
batting an eyelid. But how could it possibly do so even though we kept
it ignorant of the semantics of <code>size</code>?</p>
<p>Because types decompose reasoning. In particular, here, the measure
and constructor trick lets us <em>factor reasoning about <code>size</code> into the type system</em>.</p>
<p>In particular, LH internally views the code for <code>test</code> in A-Normal Form
which is a fancy way of saying, by introducing temporary variables
for all sub-expressions:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>test x1 <span class="ot">=</span> </span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> tmp0 <span class="ot">=</span> <span class="dt">Nil</span>                </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>       tmp1 <span class="ot">=</span> <span class="dt">Cons</span> x1 tmp0 </span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>       pos  <span class="ot">=</span> <span class="dt">Cons</span>  0 tmp1</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>      assert (size pos <span class="op">==</span> <span class="dv">2</span>)</span></code></pre></div>
<p>And now, just by the rules of type checking, and applying the types
of the constructors, it deduces that:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">   tmp0 ::</span> {size tmp0 <span class="op">==</span> <span class="dv">0</span>}</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">   tmp1 ::</span> {size tmp1 <span class="op">==</span> <span class="dv">1</span> <span class="op">+</span> size tmp0}</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">   pos  ::</span> {size pos  <span class="op">==</span> <span class="dv">1</span> <span class="op">+</span> size tmp1}</span></code></pre></div>
<p>which lets the SMT solver prove that <code>size pos == 2</code> without
requiring any axiomatic description of <code>size</code>. This simple
<code>measure</code> method goes a very long way in specifying and
verifying <a href="http://goto.ucsd.edu/~rjhala/papers/real_world_liquid.pdf">lots of properties</a>.</p>
<h3 id="lesson-decomposition-enables-type-directed-instantiation">Lesson: Decomposition Enables Type-Directed Instantiation</h3>
<p>I’d like to emphasize again that this trick was enabled
by the type-centric view: encode the function semantics
in <em>data constructors</em>, and let the type checking (or VC
generation) do the <em>instantiation</em>.</p>
<p>It could easily by incorporated inside and work together
with axioms in Floyd-Hoare based systems like Dafny.
Of course, this approach is limited to a restricted class
of functions – roughly, case-splits over a single data type’s
constructors – but we can generalize the method quite
a bit using the idea of <a href="https://arxiv.org/abs/1711.03842">logical evaluation</a>.</p>
<h2 id="summary">Summary</h2>
<p>To sum up, we saw two examples where taking a type-centric view
made verification more <em>ergonomic</em>, essentially by <em>factoring</em>
reasoning about quantifiers into the type system.</p>
<ul>
<li><p>In the first case, when reasoning about <em>data</em> in containers,
the polymorphic type constructor <code>List</code> provided an natural
way to reason about the fact that <em>all</em> elements in a container
satisfied some property.</p></li>
<li><p>In the second case, when reasoning about the <em>structure</em>
of the container via a recursive function, the types of
the data constructors allowed us to factor the instantiation
of properties of <code>size</code> at places where the list was constructed
(and dually, not shown, destructed) without burdening the SMT
solver with any axioms and the pressure of figuring out where
to instantiate them.</p></li>
</ul>
<p>To conclude I’d like to reiterate that the point is <em>not</em>
that types and program logics are at odds with each other.
Instead, the lesson is that while classical
Floyd-Hoare logic associates invariants with <em>program</em>
positions, Liquid/Refinement types are a <em>generalization</em>
that additionally let you associate invariants with
<em>type</em> positions, which lets us exploit</p>
<ul>
<li>types as a program logic, and</li>
<li>syntax-directed typing rules as a decision procedure,</li>
</ul>
<p>that, in many common situations, simplify verification by
decomposing proof obligations (VCs) into simple, quantifier-free,
SMT-friendly formulas. As you might imagine, the benefits
are magnified when working with higher-order functions,
e.g. <code>map</code>-ing or <code>fold</code>-ing over containers…</p>
<h3 id="acknowledgments">Acknowledgments</h3>
<p>Huge thanks to
<a href="http://leino.science/">Rustan Leino</a>,
<a href="https://cseweb.ucsd.edu/~npolikarpova/">Nadia Polikarpova</a>,
<a href="http://cseweb.ucsd.edu/~daricket/">Daniel Ricketts</a>,
<a href="https://twitter.com/hillelogram">Hillel Wayne</a>, and
<a href="https://twitter.com/zizzivon">Zizz Vonnegut</a>
for patiently answering my many questions about Dafny!</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2019/10/20/why-types.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2019/10/20/why-types.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>The Hillelogram Verifier Rodeo I (LeftPad)</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2018/05/17/hillel-verifier-rodeo-I-leftpad.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2018/05/17/hillel-verifier-rodeo-I-leftpad.lhs</id>
    <published>true</published>
    <updated>2018-05-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>The Hillelogram Verifier Rodeo I (LeftPad)</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			May 17, 2018
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged &#39;reflection&#39;." href="/tags/reflection.html">reflection</a>
              
            </div>

            <br>
			            <!--
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">You have to provide a 100%, machine-checked guarantee that there are no problems with your code whatsoever. If it&#39;s so much easier to analyze FP programs than imperative programs, this should be simple, right?</p>&mdash; Hillel (@Hillelogram) <a href="https://twitter.com/Hillelogram/status/987432180837167104?ref_src=twsrc%5Etfw">April 20, 2018</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
-->
<p>A month ago, <a href="https://twitter.com/Hillelogram">Hillel Wayne</a>
posted a <a href="https://twitter.com/Hillelogram/status/987432180837167104">verification challenge</a>
comprising three problems that might <em>sound</em> frivolous,
but which, in fact, hit the sweet spot of being easy to
describe and yet interesting to implement and verify.
I had a lot of fun hacking them up in LH, and learned
some things doing so.</p>
<p>Today, lets see how to implement the first
of these challenges – <code>leftPad</code> – in Haskell,
and to check Hillel’s specification with LH.</p>
<p>(Click here to <a href="http://goto.ucsd.edu:8090/index.html#?demo=LeftPad.hs">demo</a>)</p>
<!-- more -->
<div class="hidden">
<pre><span class=hs-linenum>35: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--reflection"</span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>36: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--ple"</span>         <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>37: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>infixr</span> <span class='hs-varop'>++</span>              <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>38: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>infixr</span> <span class='hs-varop'>!!</span>              <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>39: </span>
<span class=hs-linenum>40: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>PadLeft</span> <span class='hs-keyword'>where</span> 
<span class=hs-linenum>41: </span>
<span class=hs-linenum>42: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>max</span><span class='hs-layout'>,</span> <span class='hs-varid'>replicate</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>!!</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>43: </span><span class='hs-layout'>(</span><span class='hs-varop'>!!</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> 
<span class=hs-linenum>44: </span><span class='hs-definition'>size</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>45: </span><span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>46: </span><span class='hs-definition'>obviously</span>         <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>47: </span><span class='hs-definition'>replicate</span>         <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>48: </span><span class='hs-definition'>thmReplicate</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>49: </span><span class='hs-definition'>thmAppLeft</span>        <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>50: </span><span class='hs-definition'>thmAppRight</span>       <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>51: </span><span class='hs-definition'>thmLeftPad</span>        <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>52: </span>
<span class=hs-linenum>53: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>max</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>54: </span><span class='hs-definition'>max</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> 
<span class=hs-linenum>55: </span><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {VV : GHC.Types.Int | VV == max x1 x2
                                                              &amp;&amp; VV == (if x1 &gt; x2 then x1 else x2)}</span><span class='hs-definition'>max</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v &lt;=&gt; x &gt; y}</span><span class='hs-keyword'>if</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v &lt;=&gt; x &gt; y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 &gt; x2}</span><span class='hs-varop'>&gt;</span></a> <span class='hs-varid'>y</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>y</span> 
<span class=hs-linenum>56: </span>
<span class=hs-linenum>57: </span><span class='hs-comment'>-- A ghost function only used in the specification</span>
<span class=hs-linenum>58: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>leftPadVal</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Int | False}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>@-}</span>
</pre>
</div>
<h2 id="the-leftpad-challenge">The LeftPad Challenge</h2>
<p>The first of these problems was
<a href="https://twitter.com/Hillelogram/status/987432181889994759">leftPad</a></p>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="en" dir="ltr">
<ol type="1">
<li>Leftpad. Takes a padding character, a string, and a total length, returns the string padded with that length with that character. If length is less than string, does nothing.<a href="https://t.co/X8qR8gTZdO">https://t.co/X8qR8gTZdO</a>
</p>
— Hillel (<span class="citation" data-cites="Hillelogram">@Hillelogram</span>) <a href="https://twitter.com/Hillelogram/status/987432181889994759?ref_src=twsrc%5Etfw">April 20, 2018</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></li>
</ol>
<h2 id="implementation">Implementation</h2>
<p>First, lets write an idiomatic implementation
of <code>leftPad</code> where we will take the liberty of
generalizing</p>
<ul>
<li>the <strong>padding character</strong> to be the input <code>c</code> that is of some (polymorphic) type <code>a</code></li>
<li>the <strong>string</strong> to be the input <code>xs</code> that is a list of <code>a</code></li>
</ul>
<p>If the target length <code>n</code> is indeed greater than the input string <code>xs</code>,
i.e. if <code>k = n - size xs</code> is positive, we <code>replicate</code> the character <code>c</code>
<code>k</code> times and append the result to the left of the input <code>xs</code>.
Otherwise, if <code>k</code> is negative, we do nothing, i.e. return the input.</p>
<pre><span class=hs-linenum>87: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>leftPad</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>88: </span><span class='hs-definition'>leftPad</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>89: </span><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; a -&gt; x3:[a] -&gt; {res : [a] | size res == max x1 (size x3)}</span><span class='hs-definition'>leftPad</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>xs</span></a> 
<span class=hs-linenum>90: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-num'>0</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>k</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:a -&gt; {v : [a] | size v == k
                        &amp;&amp; v == replicate k x1
                        &amp;&amp; v == (if 0 == k then [] else : x1 (replicate (k - 1) x1))} | v == replicate k}</span><span class='hs-varid'>replicate</span></a> <span class='hs-varid'>k</span> <span class='hs-varid'>c</span> <span class='hs-varop'>++</span> <span class='hs-varid'>xs</span> 
<span class=hs-linenum>91: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xs</span> 
<span class=hs-linenum>92: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>93: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>k</span></a>         <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v == size xs}</span><span class='hs-varid'>size</span></a> <span class='hs-varid'>xs</span>
</pre>
<p>The code for <code>leftPad</code> is short because we’ve
delegated much of the work to <code>size</code>, <code>replicate</code>
and <code>++</code>. Here’s how we can compute the <code>size</code> of a list:</p>
<pre><span class=hs-linenum>101: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>size</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>102: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>size</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nat</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>103: </span><a class=annot href="#"><span class=annottext>x1:[a] -&gt; {v : GHC.Types.Int | v &gt;= 0
                               &amp;&amp; v == size x1}</span><span class='hs-definition'>size</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> 
<span class=hs-linenum>104: </span><span class='hs-definition'>size</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (1 : int)}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v == size xs}</span><span class='hs-varid'>size</span></a> <span class='hs-varid'>xs</span>
</pre>
<p>and here is the list append function <code>++</code> :</p>
<pre><span class=hs-linenum>110: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varop'>++</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>111: </span><span class='hs-keyword'>{-@</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ys</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class=hs-linenum>112: </span>            <span class='hs-keyword'>{v:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>| size v = size xs + size ys}</span> 
<span class=hs-linenum>113: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>114: </span><span class='hs-conid'>[]</span>     <a class=annot href="#"><span class=annottext>x1:[a] -&gt; x2:[a] -&gt; {v : [a] | size v == size x1 + size x2}</span><span class='hs-varop'>++</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>ys</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ys</span> 
<span class=hs-linenum>115: </span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : [a] | size v == size xs + size ys
           &amp;&amp; v == ++ xs ys}</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>++</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
</pre>
<p>and finally the implementation of <code>replicate</code> :</p>
<pre><span class=hs-linenum>121: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>replicate</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>122: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>replicate</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class=hs-linenum>123: </span>                 <span class='hs-keyword'>{v:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>| size v = n}</span> 
<span class=hs-linenum>124: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>125: </span><a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; a -&gt; {v : [a] | size v == x1}</span><span class='hs-definition'>replicate</span></a> <span class='hs-num'>0</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span> 
<span class=hs-linenum>126: </span><span class='hs-definition'>replicate</span> <span class='hs-varid'>n</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>c</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; a -&gt; {v : [a] | size v == x1}</span><span class='hs-varid'>replicate</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>c</span>
</pre>
<h2 id="what-shall-we-prove">What shall we Prove?</h2>
<p>My eyes roll whenever I read the phrase “proved X (a function, a program) <em>correct</em>”.</p>
<p>There is no such thing as “correct”.</p>
<p>There are only “specifications” or “properties”,
and proofs that ensures that your code matches
those specifications or properties.</p>
<p>What <em>specifications</em> shall we verify about our
implementation of <code>leftPad</code>? One might argue that
the above code is “obviously correct”, i.e. the
implementation more or less directly matches the
informal requirements.</p>
<p>One way to formalize this notion of “obviously correct”
is to verify a specification that directly captures
the informal requirements:</p>
<pre><span class=hs-linenum>151: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>obviously</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class=hs-linenum>152: </span>      <span class='hs-keyword'>{ leftPad n c xs = if (size xs &lt; n) 
                         then (replicate (n - size xs) c ++ xs) 
                         else xs }</span> 
<span class=hs-linenum>155: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>156: </span><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:a -&gt; x3:[a] -&gt; {VV : () | leftPad x1 x2 x3 == (if size x3 &lt; x1 then ++ (replicate (x1 - size x3) x2) x3 else x3)}</span><span class='hs-definition'>obviously</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
</pre>
<p>In the above, the type signature is a specification
that says that for all <code>n</code>, <code>c</code> and <code>xs</code>, the value
returned by <code>leftPad n c xs</code> is <code>xs</code> when <code>n</code> is
too small, and the suitably padded definition otherwise.</p>
<p>The code, namely <code>()</code>, is the proof.
LH is able to trivially check that <code>leftPad</code>
meets the “obviously correct” specification,
because, well, in this case, the implementation
<em>is</em> the specification. (Incidentally, this
is also why the <a href="https://github.com/hwayne/lets-prove-leftpad/blob/master/idris/Leftpad.idr">Idris solution</a>
is terse.)</p>
<p>So, if you are happy with the above specification,
you can stop reading right here: we’re done.</p>
<h2 id="hillels-specifications">Hillel’s Specifications</h2>
<p>However, the verification rodeo is made more
interesting by Hillel’s <a href="https://rise4fun.com/Dafny/nbNTl">Dafny specifications</a>:</p>
<ol type="1">
<li><p><strong>Size</strong> The <code>size</code> of the returned sequence is the
larger of <code>n</code> and the size of <code>xs</code>;</p></li>
<li><p><strong>Pad-Value</strong> Let <code>K = n - size xs</code>. We require
that the <code>i</code>-th element of the padded-sequence
is <code>c</code> if <code>0 &lt;= i &lt; K</code>, and is the <code>i - K</code>-th
element of <code>xs</code> otherwise.</p></li>
</ol>
<div class="row-fluid">
<div class="span12 pagination-centered">
<img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/leftpad-spec.png"
       alt="Ribbons" height="150">
</div>
</div>
<h2 id="digression-the-importance-of-being-decidable">Digression: The Importance of being Decidable</h2>
<p>LH, like many of the other rodeo entries, uses
SMT solvers to automate verification. For example,
the <code>leftPad</code> solutions in <a href="https://rise4fun.com/Dafny/nbNTl">Dafny</a>
and <a href="https://blog.adacore.com/taking-on-a-challenge-in-spark">SPARK</a> and <a href="https://gist.github.com/graydon/901f98049d05db65d9a50f741c7f7626">F*</a>
make heavy use <a href="https://github.com/Microsoft/dafny/blob/master/Binaries/DafnyPrelude.bpl#L898-L1110">quantified axioms to encode properties
of sequences.</a></p>
<p>However, unlike its many SMT-based brethren, LH
takes a somewhat fanatical stance: it <em>never</em> uses
quantifiers or axioms. We take this rigid position
because SMT solvers are only <em>predictable</em> on
queries from (certain) <strong>decidable logics</strong>.
Axioms, or more generally, quantified formulas
rapidly take SMT solvers out of this “comfort zone”,
causing them to reject valid formulas, run slowly,
or even, <a href="https://twitter.com/johnregehr/status/996901816842440704">to run forever</a>.</p>
<!--
<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">I mean, I&#39;m somewhat kind of serious here, I think unneeded generality makes things really difficult often. as a random example quantifiers seem to throw z3 into a really bad place, even when they&#39;re easy ones.</p>&mdash; John Regehr (@johnregehr) <a href="https://twitter.com/johnregehr/status/996901816842440704?ref_src=twsrc%5Etfw">May 16, 2018</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<div class="row-fluid">
  <div class="span12 pagination-centered">
  <img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/regehr-tweet-quantifiers.png"
       alt="Ribbons" height="100">
  </div>
</div>
-->
<p>Thus, we have chosen to deliberately avoid
the siren song of quantifiers by lashing LH
firmly to the steady mast of decidable logics.</p>
<h2 id="reasoning-about-sequences">Reasoning about Sequences</h2>
<p>Unfortunately, this design choice leaves us
with some work: we must develop i.e. <em>state</em>
and <em>prove</em> relevant properties about sequences
from scratch.</p>
<p><strong>Indexing into a Sequence</strong></p>
<p>To start, lets define the notion of the <code>i</code>-th element of
a sequence (this is pretty much Haskell’s list-index operator)</p>
<pre><span class=hs-linenum>247: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varop'>!!</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>248: </span><span class='hs-keyword'>{-@</span> <span class='hs-layout'>(</span><span class='hs-varop'>!!</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{n:</span><span class='hs-conid'>Nat</span> <span class='hs-keyword'>| n &lt; size xs}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>249: </span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <a class=annot href="#"><span class=annottext>x1:[a] -&gt; {v : GHC.Types.Int | v &gt;= 0
                               &amp;&amp; v &lt; size x1} -&gt; a</span><span class='hs-varop'>!!</span></a> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> 
<span class=hs-linenum>250: </span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>!!</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[a] -&gt; {v : GHC.Types.Int | v &gt;= 0
                               &amp;&amp; v &lt; size x1} -&gt; a</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>!!</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
</pre>
<p><strong>Replicated Sequences</strong></p>
<p>Next, we verify that <em>every</em> element in a <code>replicate</code>-d
sequence is the element being cloned:</p>
<pre><span class=hs-linenum>259: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>thmReplicate</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Nat | i &lt; n}</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class=hs-linenum>260: </span>                    <span class='hs-keyword'>{ replicate n c !! i  == c }</span> 
<span class=hs-linenum>261: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>262: </span><a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:a -&gt; x3:{v : GHC.Types.Int | v &gt;= 0
                                                                   &amp;&amp; v &lt; x1} -&gt; {VV : () | !! (replicate x1 x2) x3 == x2}</span><span class='hs-definition'>thmReplicate</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v &lt; n}</span><span class='hs-varid'>i</span></a> 
<span class=hs-linenum>263: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>0</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>264: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:a -&gt; x3:{v : GHC.Types.Int | v &gt;= 0
                                                                   &amp;&amp; v &lt; x1} -&gt; {VV : () | !! (replicate x1 x2) x3 == x2}</span><span class='hs-varid'>thmReplicate</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>c</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span> 
</pre>
<p>LH verifies the above “proof by induction”:</p>
<ul>
<li><p>In the base case <code>i == 0</code> and the value returned is <code>c</code>
by the definition of <code>replicate</code> and <code>!!</code>.</p></li>
<li><p>In the inductive case, <code>replicate n c !! i</code> is equal to
<code>replicate (n-1) c !! (i-1)</code> which, by the “induction hypothesis”
(i.e. by recursively calling the theorem) is <code>c</code>.</p></li>
</ul>
<p><strong>Concatenating Sequences</strong></p>
<p>Finally, we need two properties that relate
concatenation and appending, namely, the
<code>i</code>-th element of <code>xs ++ ys</code> is:</p>
<ul>
<li><strong>Left</strong> the <code>i</code>-th element of <code>xs</code> if <code>0 &lt;= i &lt; size xs</code>, and</li>
<li><strong>Right</strong> the <code>i - size xs</code> element of <code>ys</code> otherwise.</li>
</ul>
<pre><span class=hs-linenum>286: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>thmAppLeft</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ys</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{i:</span><span class='hs-conid'>Nat</span> <span class='hs-keyword'>| i &lt; size xs}</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class=hs-linenum>287: </span>                  <span class='hs-keyword'>{ (xs ++ ys) !! i == xs !! i }</span> 
<span class=hs-linenum>288: </span>  <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>289: </span><a class=annot href="#"><span class=annottext>x1:[a] -&gt; x2:[a] -&gt; x3:{v : GHC.Types.Int | v &gt;= 0
                                            &amp;&amp; v &lt; size x1} -&gt; {VV : () | !! (++ x1 x2) x3 == !! x1 x3}</span><span class='hs-definition'>thmAppLeft</span></a> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>ys</span></a> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>290: </span><span class='hs-definition'>thmAppLeft</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[a] -&gt; x2:[a] -&gt; x3:{v : GHC.Types.Int | v &gt;= 0
                                            &amp;&amp; v &lt; size x1} -&gt; {VV : () | !! (++ x1 x2) x3 == !! x1 x3}</span><span class='hs-varid'>thmAppLeft</span></a> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>      
<span class=hs-linenum>291: </span>
<span class=hs-linenum>292: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>thmAppRight</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ys</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{i:</span><span class='hs-conid'>Nat</span> <span class='hs-keyword'>| size xs &lt;= i}</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class=hs-linenum>293: </span>                   <span class='hs-keyword'>{ (xs ++ ys) !! i == ys !! (i - size xs) }</span> 
<span class=hs-linenum>294: </span>  <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>295: </span><a class=annot href="#"><span class=annottext>x1:[a] -&gt; x2:[a] -&gt; x3:{v : GHC.Types.Int | v &gt;= 0
                                            &amp;&amp; size x1 &lt;= v} -&gt; {VV : () | !! (++ x1 x2) x3 == !! x2 (x3 - size x1)}</span><span class='hs-definition'>thmAppRight</span></a> <span class='hs-conid'>[]</span>     <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>ys</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>i</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>296: </span><span class='hs-definition'>thmAppRight</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>ys</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[a] -&gt; x2:[a] -&gt; x3:{v : GHC.Types.Int | v &gt;= 0
                                            &amp;&amp; size x1 &lt;= v} -&gt; {VV : () | !! (++ x1 x2) x3 == !! x2 (x3 - size x1)}</span><span class='hs-varid'>thmAppRight</span></a> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>      
</pre>
<p>Both of the above properties are proved by induction on <code>i</code>.</p>
<h2 id="proving-hillels-specifications">Proving Hillel’s Specifications</h2>
<p>Finally, we’re ready to state and prove Hillel’s specifications.</p>
<p><strong>Size Specification</strong></p>
<p>The size specification is straightforward, in that LH proves
it automatically, when type-checking <code>leftPad</code> against the
signature:</p>
<pre><span class=hs-linenum>313: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>leftPad</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> 
<span class=hs-linenum>314: </span>                <span class='hs-keyword'>{res:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>| size res = max n (size xs)}</span> 
<span class=hs-linenum>315: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p><strong>Pad-Value Specification</strong></p>
<p>We <em>specify</em> the pad-value property – i.e. the <code>i</code>-th
element equals <code>c</code> or the corresponding element of <code>xs</code> –
by a type signature:</p>
<pre><span class=hs-linenum>325: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>thmLeftPad</span> 
<span class=hs-linenum>326: </span>      <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyword'>{size xs &lt; n}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Nat | i &lt; n}</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>327: </span>         <span class='hs-keyword'>{ leftPad n c xs !! i ==  leftPadVal n c xs i }</span>                               
<span class=hs-linenum>328: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>329: </span>
<span class=hs-linenum>330: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>leftPadVal</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>331: </span><a class=annot href="#"><span class=annottext>{n : GHC.Types.Int | False} -&gt; a -&gt; [a] -&gt; GHC.Types.Int -&gt; a</span><span class='hs-definition'>leftPadVal</span></a> <a class=annot href="#"><span class=annottext>{n : GHC.Types.Int | False}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>xs</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a> 
<span class=hs-linenum>332: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v &lt;=&gt; i &lt; k}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>k</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>c</span> 
<span class=hs-linenum>333: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [a] | size v &gt;= 0
           &amp;&amp; len v &gt;= 0
           &amp;&amp; v == xs}</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>!!</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == i - k}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>
<span class=hs-linenum>334: </span>  <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>k</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v == size xs}</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <span class='hs-varid'>size</span> <span class='hs-varid'>xs</span> 
</pre>
<p><strong>Pad-Value Verification</strong></p>
<p>We <em>verify</em> the above property by filling in the
implementation of <code>thmLeftPad</code> as:</p>
<pre><span class=hs-linenum>343: </span><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:a -&gt; x3:{v : [a] | size v &lt; x1} -&gt; x4:{v : GHC.Types.Int | v &gt;= 0
                                                                                  &amp;&amp; v &lt; x1} -&gt; {VV : () | !! (leftPad x1 x2 x3) x4 == leftPadVal x1 x2 x3 x4}</span><span class='hs-definition'>thmLeftPad</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>c</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | size v &lt; n}</span><span class='hs-varid'>xs</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v &lt; n}</span><span class='hs-varid'>i</span></a> 
<span class=hs-linenum>344: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | v &lt;=&gt; i &lt; k}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>k</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[a] -&gt; x2:{v : GHC.Types.Int | v &gt;= 0
                                  &amp;&amp; v &lt; size cs} -&gt; {v : () | !! (++ cs x1) x2 == !! cs x2}</span><span class='hs-varid'>thmAppLeft</span></a>  <span class='hs-varid'>cs</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>i</span> <span class='hs-varop'>`seq`</span> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:{v : GHC.Types.Int | v &gt;= 0
                                &amp;&amp; v &lt; k} -&gt; {v : () | !! (replicate k x1) x2 == x1}</span><span class='hs-varid'>thmReplicate</span></a> <span class='hs-varid'>k</span> <span class='hs-varid'>c</span> <span class='hs-varid'>i</span>   
<span class=hs-linenum>345: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[a] -&gt; x2:{v : GHC.Types.Int | v &gt;= 0
                                  &amp;&amp; size cs &lt;= v} -&gt; {v : () | !! (++ cs x1) x2 == !! x1 (x2 - size cs)}</span><span class='hs-varid'>thmAppRight</span></a> <span class='hs-varid'>cs</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>i</span>
<span class=hs-linenum>346: </span>  <span class='hs-keyword'>where</span> 
<span class=hs-linenum>347: </span>    <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>k</span></a>         <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>n</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v == size xs}</span><span class='hs-varid'>size</span></a> <span class='hs-varid'>xs</span> 
<span class=hs-linenum>348: </span>    <a class=annot href="#"><span class=annottext>{v : [a] | size v == k
           &amp;&amp; v == replicate k c
           &amp;&amp; v == (if 0 == k then [] else : c (replicate (k - 1) c))}</span><span class='hs-varid'>cs</span></a>        <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:a -&gt; {v : [a] | size v == k
                        &amp;&amp; v == replicate k x1
                        &amp;&amp; v == (if 0 == k then [] else : x1 (replicate (k - 1) x1))} | v == replicate k}</span><span class='hs-varid'>replicate</span></a> <span class='hs-varid'>k</span> <span class='hs-varid'>c</span>
</pre>
<p>The “proof” – in quotes because its
just a Haskell function – simply combines
the replicate- and concatenate-left theorems
if <code>i</code> is in the “pad”, and the concatenate-right
theorem, otherwise.</p>
<h2 id="conclusions">Conclusions</h2>
<p>That concludes part I of the rodeo. What did I learn from this exercise?</p>
<ol type="1">
<li><p>Even apparently simple functions like <code>leftPad</code> can
have <em>many</em> different specifications; there is no
necessarily “best” specification as different specs
make different assumptions about what is “trusted”,
and more importantly, though we didn’t see it here,
ultimately a spec is a particular <em>view</em> into how a
piece of code behaves and
we may want different views depending on the context where we want
to use the given piece of code.</p></li>
<li><p>The <code>leftPad</code> exercise illustrates a fundamental
problem with Floyd-Hoare style “modular” verification,
where pre- and post-conditions (or contracts or refinement
types or …) are used to modularly “abstract” functions
i.e. are used to describe the behavior of a function
at a call-site. As the above exercise shows, we often
need properties connecting the behavior of different
functions, e.g. append (<code>++</code>), indexing (<code>!!</code>).
In these cases, the only meaningful <em>specification</em>
for the underlying function <em>is its implementation</em>.</p></li>
<li><p>Finally, the above proofs are all over user-defined
recursive functions which this was not even possible
before <a href="/tags/reflection.html">refinement reflection</a>, i.e
till about a year ago. I’m also quite pleased by how
<a href="/tags/ple.html">logical evaluation</a> makes these proofs
quite short, letting LH verify expressive specifications
while steering clear of the siren song of quantifiers.</p></li>
</ol>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2018/05/17/hillel-verifier-rodeo-I-leftpad.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2018/05/17/hillel-verifier-rodeo-I-leftpad.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Measures and Case Splitting</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2018/02/23/measures-and-case-splitting.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2018/02/23/measures-and-case-splitting.lhs</id>
    <published>true</published>
    <updated>2018-02-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Measures and Case Splitting</h1>
                    
                    <span class="meta">
		    
			Posted by Niki Vazou
		    
			Feb 23, 2018
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged &#39;measures&#39;." href="/tags/measures.html">measures</a>, <a title="All pages tagged &#39;advanced&#39;." href="/tags/advanced.html">advanced</a>
              
            </div>

            <br>
			            <p>Liquid Haskell has a flag called <code>--no-case-expand</code>
which can make verification of your code much faster,
especially when your code is using ADTs with many alternatives.
This flag says relax precision to get fast verification,
thus may lead to rejecting safe code.</p>
<p>In this post, I explain how <code>--no-case-expand</code>
works using a trivial example!</p>
<p>(Click here to <a href="http://goto.ucsd.edu:8090/index.html#?demo=RangeSet.hs">demo</a>)</p>
<!-- more -->
<div class="hidden">
<pre><span class=hs-linenum>28: </span>
<span class=hs-linenum>29: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>MeasuresAndCaseSplitting</span> <span class='hs-keyword'>where</span>
</pre>
</div>
<h2 id="measures">Measures</h2>
<p>Let’s define a simple data type with three alternatives</p>
<pre><span class=hs-linenum>40: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>A</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>B</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>C</span> 
</pre>
<p>and a measure that turns <code>ABD</code> into an integer</p>
<pre><span class=hs-linenum>46: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>toInt</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>47: </span><span class='hs-definition'>toInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> 
<span class=hs-linenum>48: </span><a class=annot href="#"><span class=annottext>x1:MeasuresAndCaseSplitting.ABC -&gt; {VV : GHC.Types.Int | VV == MeasuresAndCaseSplitting.toInt x1}</span><span class='hs-definition'>toInt</span></a> <span class='hs-conid'>A</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> 
<span class=hs-linenum>49: </span><span class='hs-definition'>toInt</span> <span class='hs-conid'>B</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span>
<span class=hs-linenum>50: </span><span class='hs-definition'>toInt</span> <span class='hs-conid'>C</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>3</span> 
</pre>
<p>Though obvious to us, Liquid Haskell will fail to check
that <code>toInt</code> of any <code>ABC</code> argument
gives back a natural number.
Or, the following call leads to a refinement type error.</p>
<pre><span class=hs-linenum>59: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>unsafe</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{o:</span><span class='hs-conid'>()</span> <span class='hs-keyword'>| 0 &lt;= toInt x }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>60: </span><span class='hs-keyword'>unsafe</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>61: </span><span class=hs-error><a class=annot href="#"><span class=annottext>x1:MeasuresAndCaseSplitting.ABC -&gt; {o : () | 0 &lt;= MeasuresAndCaseSplitting.toInt x1}</span><span class='hs-keyword'>unsafe</span></a></span> <a class=annot href="#"><span class=annottext>MeasuresAndCaseSplitting.ABC</span><span class='hs-varid'>x</span></a>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
</pre>
<p>Why?
By turning <code>toInt</code> into a measure, Liquid Haskell
gives precise information to each data constructor of <code>ABC</code>.
Thus it knows that <code>toInt</code> or <code>A</code>, <code>B</code>, and <code>C</code>
is respectively <code>1</code>, <code>2</code>, and <code>3</code>, by <em>automatically</em>
generating the following types:</p>
<pre><span class=hs-linenum>72: </span><span class='hs-conid'>A</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>toInt</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-num'>1</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>73: </span><span class='hs-conid'>B</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>toInt</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-num'>2</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>74: </span><span class='hs-conid'>C</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>toInt</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-num'>3</span> <span class='hs-layout'>}</span>
</pre>
<p>Thus, to get the <code>toInt</code> information one need to
explicitly perform case analysis on an <code>ABC</code> argument.
The following code is safe</p>
<pre><span class=hs-linenum>82: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>safe</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{o:</span><span class='hs-conid'>()</span> <span class='hs-keyword'>| 0 &lt;= toInt x}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>83: </span><span class='hs-keyword'>safe</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>84: </span><a class=annot href="#"><span class=annottext>x1:MeasuresAndCaseSplitting.ABC -&gt; {o : () | 0 &lt;= MeasuresAndCaseSplitting.toInt x1}</span><span class='hs-keyword'>safe</span></a> <span class='hs-conid'>A</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>85: </span><span class='hs-keyword'>safe</span> <span class='hs-conid'>B</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>86: </span><span class='hs-keyword'>safe</span> <span class='hs-conid'>C</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
</pre>
<p>Liquid Haskell type check the above code because
in the first case the body is checked under the assumption
that the argument, call it <code>x</code>, is an <code>A</code>.
Under this assumption, <code>toInt x</code> is indeed non negative.
Yet, this is the case for the rest two alternatives,
where <code>x</code> is either <code>B</code> or <code>C</code>.
So, <code>0 &lt;= toInt x</code> holds for all the alternatives,
because case analysis on <code>x</code> automatically reasons about the
value of the measure <code>toInt</code>.</p>
<p>Now, what if I match the argument <code>x</code> only with <code>A</code>
and provide a default body for the rest?</p>
<pre><span class=hs-linenum>104: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>safeBut</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{o:</span><span class='hs-conid'>()</span> <span class='hs-keyword'>| 0 &lt;= toInt x}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>105: </span><span class='hs-definition'>safeBut</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>106: </span><a class=annot href="#"><span class=annottext>x1:MeasuresAndCaseSplitting.ABC -&gt; {o : () | 0 &lt;= MeasuresAndCaseSplitting.toInt x1}</span><span class='hs-definition'>safeBut</span></a> <span class='hs-conid'>A</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>107: </span><span class='hs-definition'>safeBut</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
</pre>
<p>Liquid Haskell knows that if the argument <code>x</code> is actually an <code>A</code>,
then <code>toInt x</code> is not negative, but does not know the value of <code>toInt</code>
for the default case.</p>
<p>But, <em>by default</em> Liquid Haskell will do the the case expansion
of the default case for you and rewrite your code to match <code>_</code>
with all the possible cases.
Thus, Liquid Haskell will internally rewrite <code>safeBut</code> as</p>
<pre><span class=hs-linenum>119: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>safeButLH</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{o:</span><span class='hs-conid'>()</span> <span class='hs-keyword'>| 0 &lt;= toInt x}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>120: </span><span class='hs-definition'>safeButLH</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ABC</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>121: </span><a class=annot href="#"><span class=annottext>x1:MeasuresAndCaseSplitting.ABC -&gt; {o : () | 0 &lt;= MeasuresAndCaseSplitting.toInt x1}</span><span class='hs-definition'>safeButLH</span></a> <span class='hs-conid'>A</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>122: </span><span class='hs-definition'>safeButLH</span> <span class='hs-conid'>B</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
<span class=hs-linenum>123: </span><span class='hs-definition'>safeButLH</span> <span class='hs-conid'>C</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span> 
</pre>
<p>With this rewrite Liquid Haskell gets precision!
Thus, it has all the information it needs to prove <code>safeBut</code> as safe.
Yet, it repeats the code of the default case,
thus verification slows down.</p>
<p>In this example, we only have three case alternatives,
so we only repeat the code two times with a minor slow down.
In cases with many more alternatives repeating the code
of the default case can kill the verification time.</p>
<p>For that reason, Liquid Haskell comes with the <code>no-case-expand</code>
flag that deactivates this expansion of the default cases.
With the <code>no-case-expand</code> flag on, the <code>safeBut</code> code will not type check
and to fix it the user needs to perform the case expansion manually.</p>
<p>In short, the <code>no-case-expand</code> increases verification speed
but reduces precision. Then it is up to the user
to manually expand the default cases, as required,
to restore all the precision required for the code to type check.</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2018/02/23/measures-and-case-splitting.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2018/02/23/measures-and-case-splitting.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Splitting and Splicing Intervals (Part 2)</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2017/12/24/splitting-and-splicing-intervals-II.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2017/12/24/splitting-and-splicing-intervals-II.lhs</id>
    <published>true</published>
    <updated>2017-12-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Splitting and Splicing Intervals (Part 2)</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			Dec 24, 2017
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged &#39;reflection&#39;." href="/tags/reflection.html">reflection</a>, <a title="All pages tagged &#39;abstract-refinements&#39;." href="/tags/abstract-refinements.html">abstract-refinements</a>
              
            </div>

            <br>
			            <p><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/2017/12/15/splitting-and-splicing-intervals-I.lhs/">Previously</a>, we saw how the principle of
<em>“making illegal states unrepresentable”</em> allowed LH
to easily enforce a <em>key invariant</em> in
<a href="https://twitter.com/nomeata?lang=en">Joachim</a>
Breitner’s library for representing sets of integers
as <a href="https://www.joachim-breitner.de/blog/734-Finding_bugs_in_Haskell_code_by_proving_it">sorted lists of intervals</a>.</p>
<p>However, <a href="https://github.com/antalsz/hs-to-coq">Hs-to-coq</a> let Breitner
specify and verify that his code properly
implemented a <em>set</em> library. Today, lets
see how LH’s new <em>“type-level computation”</em>
abilities let us reason about the sets
of values corresponding to intervals,
while using the SMT solver to greatly
simplify the overhead of proof.</p>
<p>(Click here to <a href="http://goto.ucsd.edu:8090/index.html#?demo=RangeSet.hs">demo</a>)</p>
<!-- more -->
<div class="row">
<div class="col-lg-2">

</div>
<div class="col-lg-8">
<p><img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ribbon.png" alt="Ribbons"></p>
</div>
<div class="col-lg-2">

</div>
</div>
<div class="hidden">
<pre><span class=hs-linenum>42: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--short-names"</span>    <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>43: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--exact-data-con"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>44: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-adt"</span>         <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>45: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--higherorder"</span>    <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>46: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--diff"</span>           <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>47: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--ple"</span>            <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>48: </span>
<span class=hs-linenum>49: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>RangeSet</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>50: </span>
<span class=hs-linenum>51: </span><span class='hs-keyword'>import</span>           <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>min</span><span class='hs-layout'>,</span> <span class='hs-varid'>max</span><span class='hs-layout'>)</span>
<span class=hs-linenum>52: </span><span class='hs-keyword'>import</span>           <span class='hs-conid'>Language</span><span class='hs-varop'>.</span><span class='hs-conid'>Haskell</span><span class='hs-varop'>.</span><span class='hs-conid'>Liquid</span><span class='hs-varop'>.</span><span class='hs-conid'>NewProofCombinators</span>
</pre>
</div>
<h2 id="intervals">Intervals</h2>
<p>Recall that the key idea is to represent sets of integers like</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>{ <span class="dv">7</span>, <span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">3</span>, <span class="dv">11</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">12</span>, <span class="dv">4</span>}</span></code></pre></div>
<p>as ordered lists of <em>intervals</em></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>[ (<span class="dv">1</span>, <span class="dv">5</span>), (<span class="dv">7</span>, <span class="dv">8</span>), (<span class="dv">9</span>, <span class="dv">13</span>) ]</span></code></pre></div>
<p>where each pair <code>(i, j)</code> represents the set <code>{i, i+1,..., j-1}</code>.</p>
<p>To verify that the implementation correctly implements a set
data type, we need a way to</p>
<ol type="1">
<li><em>Specify</em> the set of values being described,</li>
<li><em>Establish</em> some key properties of these sets.</li>
</ol>
<h2 id="range-sets-semantics-of-intervals">Range-Sets: Semantics of Intervals</h2>
<p>We can describe the set of values corresponding
to (i.e. “the semantics of”) an interval <code>i, j</code>
by importing the <code>Data.Set</code> library</p>
<pre><span class=hs-linenum>88: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>S</span>
</pre>
<p>to write a function <code>rng i j</code> that defines the <strong>range-set</strong> <code>i..j</code></p>
<pre><span class=hs-linenum>94: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>rng</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>95: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>rng</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Int</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>j</span> <span class='hs-comment'>-</span> <span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>96: </span><a class=annot href="#"><span class=annottext>Int -&gt; Int -&gt; (Set Int)</span><span class='hs-definition'>rng</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>j</span></a>
<span class=hs-linenum>97: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i &lt; j}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>j</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>union</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (Set Int) | v == Set_sng i}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>singleton</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int -&gt; Int -&gt; (Set Int)</span><span class='hs-varid'>rng</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span>
<span class=hs-linenum>98: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-varid'>empty</span>
</pre>
<p>The <code>reflect rng</code> <a href="/tags/reflection.html">tells LH</a> that
we are going to want to work with the Haskell
function <code>rng</code> at the refinement-type level.</p>
<h2 id="equational-reasoning">Equational Reasoning</h2>
<p>To build up a little intuition about the above
definition and how LH reasons about Sets, lets
write some simple <em>unit proofs</em>. For example,
lets check that <code>2</code> is indeed in the range-set
<code>rng 1 3</code>, by writing a type signature</p>
<pre><span class=hs-linenum>116: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>test1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ S.member 2 (rng 1 3) }</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>Any <em>implementation</em> of the above type is a <em>proof</em>
that <code>2</code> is indeed in <code>rng 1 3</code>. Notice that we can
reuse the operators from <code>Data.Set</code> (here, <code>S.member</code>)
to talk about set operations in the refinement logic.
Lets write this proof in an <a href="http://themattchan.com/docs/algprog.pdf">equational style</a>:</p>
<pre><span class=hs-linenum>126: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | Set_mem 2 (RangeSet.rng 1 3)}</span><span class='hs-definition'>test1</span></a> <span class='hs-conid'>()</span>
<span class=hs-linenum>127: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-num'>1</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span>
<span class=hs-linenum>128: </span>      <span class='hs-comment'>-- by unfolding `rng 1 3`</span>
<span class=hs-linenum>129: </span>  <span class='hs-varop'>===</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>union</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>singleton</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-num'>2</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>130: </span>      <span class='hs-comment'>-- by unfolding `rng 2 3`</span>
<span class=hs-linenum>131: </span>  <span class='hs-varop'>===</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>union</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>singleton</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>132: </span>                          <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>union</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>singleton</span> <span class='hs-num'>2</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-num'>3</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>133: </span>      <span class='hs-comment'>-- by set-theory</span>
<span class=hs-linenum>134: </span>  <span class='hs-varop'>===</span> <span class='hs-conid'>True</span>
<span class=hs-linenum>135: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>the “proof” uses two library operators:</p>
<ul>
<li><p><code>e1 === e2</code> is an <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/Language/Haskell/Liquid/NewProofCombinators.hs#L87-L96">implicit equality</a>
that checks <code>e1</code> is indeed equal to <code>e2</code> after
<strong>unfolding functions at most once</strong>, and returns
a term that equals <code>e1</code> and <code>e2</code>, and</p></li>
<li><p><code>e *** QED</code> <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/Language/Haskell/Liquid/NewProofCombinators.hs#L65-L69">converts any term</a> <code>e</code>
into a proof.</p></li>
</ul>
<p>The first two steps of <code>test1</code>, simply unfold <code>rng</code>
and the final step uses the SMT solver’s
decision procedure for sets to check equalities
over set operations like <code>S.union</code>, <code>S.singleton</code>
and <code>S.member</code>.</p>
<h2 id="reusing-proofs">Reusing Proofs</h2>
<p>Next, lets check that:</p>
<pre><span class=hs-linenum>160: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>test2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ S.member 2 (rng 0 3) }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>161: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | Set_mem 2 (RangeSet.rng 0 3)}</span><span class='hs-definition'>test2</span></a> <span class='hs-conid'>()</span>
<span class=hs-linenum>162: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-num'>0</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span>
<span class=hs-linenum>163: </span>      <span class='hs-comment'>-- by unfolding and set-theory</span>
<span class=hs-linenum>164: </span>  <span class='hs-varop'>===</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Bool</span><span class='hs-num'>2</span></a> <a class=annot href="#"><span class=annottext>x1:Integer -&gt; x2:Integer -&gt; {v : Bool | v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>0</span> <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; x2:Bool -&gt; {v : Bool | v &lt;=&gt; x1
                                             || x2} | v == GHC.Classes.||}</span><span class='hs-varop'>||</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-num'>1</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>165: </span>      <span class='hs-comment'>-- by re-using test1 as a lemma</span>
<span class=hs-linenum>166: </span>  <span class='hs-varop'>==?</span> <span class='hs-conid'>True</span> <span class='hs-varop'>?</span> <a class=annot href="#"><span class=annottext>{v : () -&gt; {v : () | Set_mem 2 (RangeSet.rng 1 3)} | v == RangeSet.test1}</span><span class='hs-varid'>test1</span></a> <span class='hs-conid'>()</span>
<span class=hs-linenum>167: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>We could do the proof by unfolding in
the equational style. However, <code>test1</code>
already establishes that <code>S.member 2 (rng 1 3)</code>
and we can reuse this fact using:</p>
<ul>
<li><code>e1 ==? e2 ? pf</code> an <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/Language/Haskell/Liquid/NewProofCombinators.hs#L98-L116">explicit equality</a>
which checks that <code>e1</code> equals <code>e2</code> <em>because of</em> the
extra facts asserted by the <code>Proof</code> named <code>pf</code>
(in addition to unfolding functions at most once)
and returns a term that equals both <code>e1</code> and <code>e2</code>.</li>
</ul>
<h2 id="proof-by-logical-evaluation">Proof by Logical Evaluation</h2>
<p>Equational proofs like <code>test1</code> and <code>test2</code>
often have long chains of calculations that
can be tedious to spell out. Fortunately, we
taught LH a new trick called
<strong>Proof by Logical Evaluation</strong> (PLE) that
optionally shifts the burden of performing
those calculations onto the machine. For example,
PLE completely automates the above proofs:</p>
<pre><span class=hs-linenum>194: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>test1_ple</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ S.member 2 (rng 1 3) }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>195: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | Set_mem 2 (RangeSet.rng 1 3)}</span><span class='hs-definition'>test1_ple</span></a> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>196: </span>
<span class=hs-linenum>197: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>test2_ple</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ S.member 2 (rng 0 3) }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>198: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | Set_mem 2 (RangeSet.rng 0 3)}</span><span class='hs-definition'>test2_ple</span></a> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
</pre>
<p><strong>Be Warned!</strong> While automation is cool,
it can be <em>very</em> helpful to first write
out all the steps of an equational proof,
at least while building up intuition.</p>
<h2 id="proof-by-induction">Proof by Induction</h2>
<p>At this point, we have enough tools to start proving some
interesting facts about range-sets. For example, if <code>x</code>
is <em>outside</em> the range <code>i..j</code> then it does not belong in
<code>rng i j</code>:</p>
<pre><span class=hs-linenum>216: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_mem</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-keyword'>{x &lt; i || j &lt;= x}</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>217: </span>                 <span class='hs-keyword'>{ not (S.member x (rng i j)) }</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>j</span> <span class='hs-comment'>-</span> <span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>218: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>We will prove the above <a href="/tags/induction.html">“by induction”</a>.
A confession: I always had trouble understanding what
exactly <em>proof by induction</em> really meant. Why was it
it ok to “do” induction on one thing but not another?</p>
<p><strong>Induction is Recursion</strong></p>
<p>Fortunately, with LH, induction is just recursion. That is,</p>
<ol type="1">
<li><p>We can <strong>recursively</strong> use the same theorem we
are trying to prove, but</p></li>
<li><p>We must make sure that the recursive function/proof
<strong>terminates</strong>.</p></li>
</ol>
<p>The proof makes this clear:</p>
<pre><span class=hs-linenum>239: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1
                                  || x2 &lt;= v} -&gt; {VV : () | not (Set_mem x3 (RangeSet.rng x1 x2))}</span><span class='hs-definition'>lem_mem</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>j</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &lt; i
           || j &lt;= v}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>240: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i &gt;= j}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}</span><span class='hs-varop'>&gt;=</span></a> <span class='hs-varid'>j</span>
<span class=hs-linenum>241: </span>      <span class='hs-comment'>-- BASE CASE</span>
<span class=hs-linenum>242: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}</span><span class='hs-varid'>not</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>243: </span>      <span class='hs-comment'>-- by unfolding</span>
<span class=hs-linenum>244: </span>  <span class='hs-varop'>===</span> <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}</span><span class='hs-varid'>not</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-varid'>x</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-varid'>empty</span><span class='hs-layout'>)</span>
<span class=hs-linenum>245: </span>      <span class='hs-comment'>-- by set-theory</span>
<span class=hs-linenum>246: </span>  <span class='hs-varop'>===</span> <span class='hs-conid'>True</span> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>247: </span>
<span class=hs-linenum>248: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i &lt; j}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>j</span>
<span class=hs-linenum>249: </span>      <span class='hs-comment'>-- INDUCTIVE CASE</span>
<span class=hs-linenum>250: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}</span><span class='hs-varid'>not</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>251: </span>      <span class='hs-comment'>-- by unfolding</span>
<span class=hs-linenum>252: </span>  <span class='hs-varop'>===</span> <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}</span><span class='hs-varid'>not</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>union</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (Set Int) | v == Set_sng i}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>singleton</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>253: </span>      <span class='hs-comment'>-- by set-theory</span>
<span class=hs-linenum>254: </span>  <span class='hs-varop'>===</span> <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; {v : Bool | v &lt;=&gt; not x1} | v == GHC.Classes.not}</span><span class='hs-varid'>not</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_mem x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>member</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>255: </span>      <span class='hs-comment'>-- by "induction hypothesis"</span>
<span class=hs-linenum>256: </span>  <span class='hs-varop'>==?</span> <span class='hs-conid'>True</span> <span class='hs-varop'>?</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1
                                  || x2 &lt;= v} -&gt; {VV : () | not (Set_mem x3 (RangeSet.rng x1 x2))}</span><span class='hs-varid'>lem_mem</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j</span> <span class='hs-varid'>x</span> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>There are two cases.</p>
<ul>
<li><p><strong>Base Case:</strong> As <code>i &gt;= j</code>, we know <code>rng i j</code> is empty, so <code>x</code>
cannot be in it.</p></li>
<li><p><strong>Inductive Case</strong> As <code>i &lt; j</code> we can unfold <code>rng i j</code> and
then <em>recursively call</em> <code>lem_mem (i+1) j</code> to obtain the fact
that <code>x</code> cannot be in <code>i+1..j</code> to complete the proof.</p></li>
</ul>
<p>LH automatically checks that the proof:</p>
<ol type="1">
<li><p><strong>Accounts for all cases</strong>, as otherwise the
function is <em>not total</em> i.e. like the <code>head</code> function
which is only defined on non-empty lists.
(Try deleting a case at the <a href="http://goto.ucsd.edu:8090/index.html#?demo=RangeSet.hs">demo</a> to see what happens.)</p></li>
<li><p><strong>Terminates</strong>, as otherwise the induction
is bogus, or in math-speak, not <em>well-founded</em>.
We use the <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/README.md#explicit-termination-metrics">explicit termination metric</a>
<code>/ [j-i]</code> as a hint to tell LH that in each recursive call,
the size of the interval <code>j-i</code> shrinks and is
always non-negative. LH checks that is indeed the case,
ensuring that we have a legit proof by induction.</p></li>
</ol>
<p><strong>Proof by Evaluation</strong></p>
<p>Once you get the hang of the above style, you get tired
of spelling out all the details. Logical evaluation lets
us eliminate all the boring calculational steps, leaving
the essential bits: the recursive (inductive) skeleton</p>
<pre><span class=hs-linenum>291: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_mem_ple</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-keyword'>{x &lt; i || j &lt;= x}</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>292: </span>                     <span class='hs-keyword'>{not (S.member x (rng i j))}</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>j</span><span class='hs-comment'>-</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>293: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>294: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1
                                  || x2 &lt;= v} -&gt; {VV : () | not (Set_mem x3 (RangeSet.rng x1 x2))}</span><span class='hs-definition'>lem_mem_ple</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>j</span></a> <a class=annot href="#"><span class=annottext>{v : Int | v &lt; i
           || j &lt;= v}</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>295: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i &gt;= j}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}</span><span class='hs-varop'>&gt;=</span></a> <span class='hs-varid'>j</span> <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>()</span>
<span class=hs-linenum>296: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i &lt; j}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>j</span>  <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1
                                  || x2 &lt;= v} -&gt; {VV : () | not (Set_mem x3 (RangeSet.rng x1 x2))}</span><span class='hs-varid'>lem_mem_ple</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j</span> <span class='hs-varid'>x</span>
</pre>
<p>The above is just <code>lem_mem</code> sans the
(PLE-synthesized) intermediate equalities.</p>
<h2 id="disjointness">Disjointness</h2>
<p>We say that two sets are <em>disjoint</em> if their <code>intersection</code> is <code>empty</code>:</p>
<pre><span class=hs-linenum>309: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>inline</span> <span class='hs-varid'>disjoint</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>310: </span><span class='hs-definition'>disjoint</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>311: </span><a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {VV : Bool | VV &lt;=&gt; Set_cap x1 x2 == Set_empty 0}</span><span class='hs-definition'>disjoint</span></a> <a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-varid'>a</span></a> <a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-varid'>b</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cap x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>intersection</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-varid'>empty</span>
</pre>
<p>Lets prove that two intervals are disjoint if
the first <em>ends</em> before the second <em>begins</em>:</p>
<pre><span class=hs-linenum>318: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_disj</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-keyword'>{j1 &lt;= i2}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j2</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>319: </span>                  <span class='hs-keyword'>{disjoint (rng i1 j1) (rng i2 j2)}</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>j2</span><span class='hs-comment'>-</span><span class='hs-varid'>i2</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>320: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>This proof goes “by induction” on the size of
the second interval, i.e. <code>j2-i2</code>:</p>
<pre><span class=hs-linenum>327: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{i2 : Int | x2 &lt;= i2} -&gt; x4:Int -&gt; {VV : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0}</span><span class='hs-definition'>lem_disj</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i1</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>j1</span></a> <a class=annot href="#"><span class=annottext>{i2 : Int | j1 &lt;= i2}</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>j2</span></a>
<span class=hs-linenum>328: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i2 &gt;= j2}</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}</span><span class='hs-varop'>&gt;=</span></a> <span class='hs-varid'>j2</span>
<span class=hs-linenum>329: </span>      <span class='hs-comment'>-- Base CASE</span>
<span class=hs-linenum>330: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}</span><span class='hs-varid'>disjoint</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>j2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>331: </span>      <span class='hs-comment'>-- by unfolding</span>
<span class=hs-linenum>332: </span>  <span class='hs-varop'>===</span> <a class=annot href="#"><span class=annottext>{v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}</span><span class='hs-varid'>disjoint</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span><span class='hs-layout'>)</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-varid'>empty</span>
<span class=hs-linenum>333: </span>      <span class='hs-comment'>-- by set-theory</span>
<span class=hs-linenum>334: </span>  <span class='hs-varop'>===</span> <span class='hs-conid'>True</span>
<span class=hs-linenum>335: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>336: </span>
<span class=hs-linenum>337: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i2 &lt; j2}</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>j2</span>
<span class=hs-linenum>338: </span>      <span class='hs-comment'>-- Inductive CASE</span>
<span class=hs-linenum>339: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}</span><span class='hs-varid'>disjoint</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>j2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>340: </span>      <span class='hs-comment'>-- by unfolding</span>
<span class=hs-linenum>341: </span>  <span class='hs-varop'>===</span> <a class=annot href="#"><span class=annottext>{v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}</span><span class='hs-varid'>disjoint</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>union</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (Set Int) | v == Set_sng i2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>singleton</span> <span class='hs-varid'>i2</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : (Set Int) | v == RangeSet.rng x1 x2
                                          &amp;&amp; v == (if x1 &lt; x2 then Set_cup (Set_sng x1) (RangeSet.rng (x1 + 1) x2) else Set_empty 0)} | v == RangeSet.rng}</span><span class='hs-varid'>rng</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i2</span></a><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>342: </span>      <span class='hs-comment'>-- by induction and lem_mem</span>
<span class=hs-linenum>343: </span>  <span class='hs-varop'>==?</span> <span class='hs-conid'>True</span> <span class='hs-varop'>?</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1
                                       || x2 &lt;= v} -&gt; {v : () | not (Set_mem x3 (RangeSet.rng x1 x2))} | v == RangeSet.lem_mem}</span><span class='hs-varid'>lem_mem</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span> <span class='hs-varid'>i2</span> <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{i2 : Int | x2 &lt;= i2} -&gt; x4:Int -&gt; {VV : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0}</span><span class='hs-varid'>lem_disj</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i2</span></a><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>344: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>Here, the operator <code>pf1 &amp;&amp;&amp; pf2</code> conjoins the
two facts asserted by <code>pf1</code> and <code>pf2</code>.</p>
<p>Again, we can get PLE to do the boring calculations:</p>
<pre><span class=hs-linenum>353: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_disj_ple</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-keyword'>{j1 &lt;= i2}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j2</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>354: </span>                      <span class='hs-keyword'>{disjoint (rng i1 j1) (rng i2 j2)}</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>j2</span><span class='hs-comment'>-</span><span class='hs-varid'>i2</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>355: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>356: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{i2 : Int | x2 &lt;= i2} -&gt; x4:Int -&gt; {VV : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0}</span><span class='hs-definition'>lem_disj_ple</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i1</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>j1</span></a> <a class=annot href="#"><span class=annottext>{i2 : Int | j1 &lt;= i2}</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>j2</span></a>
<span class=hs-linenum>357: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i2 &gt;= j2}</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}</span><span class='hs-varop'>&gt;=</span></a> <span class='hs-varid'>j2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>358: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i2 &lt; j2}</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a>  <span class='hs-varid'>j2</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1
                                       || x2 &lt;= v} -&gt; {v : () | not (Set_mem x3 (RangeSet.rng x1 x2))} | v == RangeSet.lem_mem}</span><span class='hs-varid'>lem_mem</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span> <span class='hs-varid'>i2</span> <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; x3:{i2 : Int | x2 &lt;= i2} -&gt; x4:Int -&gt; {VV : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0}</span><span class='hs-varid'>lem_disj_ple</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i2</span></a><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>j2</span>
</pre>
<h2 id="splitting-intervals">Splitting Intervals</h2>
<p>Finally, we can establish the <strong>splitting property</strong>
of an interval <code>i..j</code>, that is, given some <code>x</code> that lies
between <code>i</code> and <code>j</code> we can <strong>split</strong> <code>i..j</code> into <code>i..x</code>
and <code>x..j</code>. We define a predicate that a set <code>s</code> can
be split into <code>a</code> and <code>b</code> as:</p>
<pre><span class=hs-linenum>372: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>inline</span> <span class='hs-varid'>split</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>373: </span><span class='hs-definition'>split</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>374: </span><a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; x3:(Set Int) -&gt; {VV : Bool | VV &lt;=&gt; x1 == Set_cup x2 x3
                                                                    &amp;&amp; Set_cap x2 x3 == Set_empty 0}</span><span class='hs-definition'>split</span></a> <a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-varid'>s</span></a> <a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-varid'>a</span></a> <a class=annot href="#"><span class=annottext>(Set Int)</span><span class='hs-varid'>b</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Bool</span><span class='hs-varid'>s</span></a> <a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <a class=annot href="#"><span class=annottext>x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : (Set Int) | v == Set_cup x1 x2}</span><span class='hs-conid'>S</span></a><span class='hs-varop'>.</span><span class='hs-varid'>union</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; x2:Bool -&gt; {v : Bool | v &lt;=&gt; x1
                                             &amp;&amp; x2} | v == GHC.Classes.&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:(Set Int) -&gt; x2:(Set Int) -&gt; {v : Bool | v &lt;=&gt; Set_cap x1 x2 == Set_empty 0} | v == RangeSet.disjoint}</span><span class='hs-varid'>disjoint</span></a> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span>
</pre>
<p>We can now state and prove the <strong>splitting property</strong> as:</p>
<pre><span class=hs-linenum>380: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_split</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-keyword'>{i &lt;= x}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j</span><span class='hs-conop'>:</span><span class='hs-keyword'>{x &lt;= j}</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>381: </span>                   <span class='hs-keyword'>{split (rng i j) (rng i x) (rng x j)}</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-comment'>-</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>382: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>383: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{j : Int | x2 &lt;= j} -&gt; {VV : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                         &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0}</span><span class='hs-definition'>lem_split</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>{v : Int | i &lt;= v}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{j : Int | x &lt;= j}</span><span class='hs-varid'>t</span></a>
<span class=hs-linenum>384: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i == x}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>385: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i &lt; x}</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a>  <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{j : Int | x2 &lt;= j} -&gt; {VV : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                         &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>x</span> <span class='hs-varid'>t</span> <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | v &lt; x1
                                       || x2 &lt;= v} -&gt; {v : () | not (Set_mem x3 (RangeSet.rng x1 x2))} | v == RangeSet.lem_mem}</span><span class='hs-varid'>lem_mem</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>t</span> <span class='hs-varid'>i</span>
</pre>
<p>(We’re using PLE here quite aggressively, can <em>you</em> work out the equational proof?)</p>
<h2 id="set-operations">Set Operations</h2>
<p>The splitting abstraction is a wonderful hammer that lets us
break higher-level proofs into the bite sized pieces suitable
for the SMT solver’s decision procedures.</p>
<p><strong>Subset</strong></p>
<p>An interval <code>i1..j1</code> is <em>enclosed by</em> <code>i2..j2</code>
if <code>i2 &lt;= i1 &lt; j1 &lt;= j2</code>. Lets verify that the
range-set of an interval is <strong>contained</strong> in
that of an enclosing one.</p>
<pre><span class=hs-linenum>406: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_sub</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j1</span><span class='hs-conop'>:</span><span class='hs-keyword'>{i1 &lt; j1}</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>407: </span>               <span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j2</span><span class='hs-conop'>:</span><span class='hs-keyword'>{i2 &lt; j2 &amp;&amp; i2 &lt;= i1 &amp;&amp; j1 &lt;= j2 }</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>408: </span>                 <span class='hs-keyword'>{ S.isSubsetOf (rng i1 j1) (rng i2 j2) }</span>
<span class=hs-linenum>409: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>Here’s a “proof-by-picture”. We can split the
larger interval <code>i2..j2</code> into smaller pieces,
<code>i2..i1</code>, <code>i1..j1</code> and <code>j1..j2</code> one of which
is the <code>i1..j1</code>, thereby completing the proof:</p>
<br>
<div class="row">
<div class="col-lg-2">

</div>
<div class="col-lg-8">
<img src="/static/img/lem_sub.png" title="fig:lem_sub proof by picture" alt="lem_sub a proof by picture" />
</div>
<div class="col-lg-2">

</div>
</div>
<p><br></p>
<p>The intuition represented by the picture can distilled
into the following proof, that invokes <code>lem_split</code> to
carve <code>i2..j2</code> into the relevant sub-intervals:</p>
<pre><span class=hs-linenum>432: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{j1 : Int | x1 &lt; j1} -&gt; x3:Int -&gt; x4:{j2 : Int | x3 &lt; j2
                                                              &amp;&amp; x3 &lt;= x1
                                                              &amp;&amp; x2 &lt;= j2} -&gt; {VV : () | Set_sub (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)}</span><span class='hs-definition'>lem_sub</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i1</span></a> <a class=annot href="#"><span class=annottext>{j1 : Int | i1 &lt; j1}</span><span class='hs-varid'>j1</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>{j2 : Int | i2 &lt; j2
            &amp;&amp; i2 &lt;= i1
            &amp;&amp; j1 &lt;= j2}</span><span class='hs-varid'>j2</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>j2</span> <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span> <span class='hs-varid'>j2</span>
</pre>
<p><strong>Union</strong></p>
<p>An interval <code>i1..j1</code> <em>overlaps</em> <code>i2..j2</code>
if <code>i1 &lt;= j2 &lt;= i2</code>, that is, if the latter
ends somewhere inside the former.
The same splitting hammer lets us compute
the union of two overlapping intervals
simply by picking the interval defined
by the <em>endpoints</em>.</p>
<pre><span class=hs-linenum>446: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_union</span> <span class='hs-keyglyph'>::</span>
<span class=hs-linenum>447: </span>      <span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j1</span><span class='hs-conop'>:</span><span class='hs-keyword'>{i1 &lt; j1}</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>448: </span>      <span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j2</span><span class='hs-conop'>:</span><span class='hs-keyword'>{i2 &lt; j2 &amp;&amp; i1 &lt;= j2 &amp;&amp; j2 &lt;= j1 }</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>449: </span>        <span class='hs-keyword'>{ rng (min i1 i2) j1 = S.union (rng i1 j1) (rng i2 j2) }</span>
<span class=hs-linenum>450: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<br>
<div class="row">
<div class="col-lg-2">

</div>
<div class="col-lg-8">
<img src="/static/img/lem_union.png" title="fig:lem_union proof by picture" alt="lem_union a proof by picture" />
</div>
<div class="col-lg-2">

</div>
</div>
<p><br></p>
<p>The pictorial proof illustrates the two cases:</p>
<ol type="1">
<li><p><code>i1..j1</code> encloses <code>i2..j2</code>; here the union is just <code>i1..j1</code>,</p></li>
<li><p><code>i1..j1</code> only overlaps <code>i1..j1</code>; here the union is <code>i2..j1</code> which
can be split into <code>i2..i1</code>, <code>i1..j2</code> and <code>j2..j1</code> which are exactly
the union of the intervals <code>i1..j1</code> and <code>i2..j2</code>.</p></li>
</ol>
<p>Again, we render the picture into a formal proof as:</p>
<pre><span class=hs-linenum>474: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{j1 : Int | x1 &lt; j1} -&gt; x3:Int -&gt; x4:{j2 : Int | x3 &lt; j2
                                                              &amp;&amp; x1 &lt;= j2
                                                              &amp;&amp; j2 &lt;= x2} -&gt; {VV : () | RangeSet.rng (RangeSet.min x1 x3) x2 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)}</span><span class='hs-definition'>lem_union</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i1</span></a> <a class=annot href="#"><span class=annottext>{j1 : Int | i1 &lt; j1}</span><span class='hs-varid'>j1</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>{j2 : Int | i2 &lt; j2
            &amp;&amp; i1 &lt;= j2
            &amp;&amp; j2 &lt;= j1}</span><span class='hs-varid'>j2</span></a>
<span class=hs-linenum>475: </span>  <span class='hs-comment'>-- i1..j1 encloses i2..j2</span>
<span class=hs-linenum>476: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i1 &lt; i2}</span><span class='hs-varid'>i1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>i2</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; x3:Int -&gt; x4:{v : Int | x3 &lt; v
                                                                &amp;&amp; x3 &lt;= x1
                                                                &amp;&amp; x2 &lt;= v} -&gt; {v : () | Set_sub (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)} | v == RangeSet.lem_sub}</span><span class='hs-varid'>lem_sub</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>j2</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span>
<span class=hs-linenum>477: </span>  <span class='hs-comment'>-- i1..j1 overlaps i2..j2</span>
<span class=hs-linenum>478: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span>
<span class=hs-linenum>479: </span>            <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j2</span> <span class='hs-varid'>j1</span>
<span class=hs-linenum>480: </span>            <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>j2</span>
</pre>
<p><strong>Intersection</strong></p>
<p>Finally, we check that the intersection of two overlapping intervals
is given by their <em>inner-points</em>.</p>
<pre><span class=hs-linenum>489: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>lem_intersect</span> <span class='hs-keyglyph'>::</span>
<span class=hs-linenum>490: </span>      <span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j1</span><span class='hs-conop'>:</span><span class='hs-keyword'>{i1 &lt; j1}</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>491: </span>      <span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j2</span><span class='hs-conop'>:</span><span class='hs-keyword'>{i2 &lt; j2 &amp;&amp; i1 &lt;= j2 &amp;&amp; j2 &lt;= j1 }</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>492: </span>        <span class='hs-keyword'>{rng (max i1 i2) j2 = S.intersection (rng i1 j1) (rng i2 j2)}</span>
<span class=hs-linenum>493: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<br>
<div class="row">
<div class="col-lg-2">

</div>
<div class="col-lg-8">
<img src="/static/img/lem_intersect.png" title="fig:lem_intersect proof by picture" alt="lem_intersect a proof by picture" />
</div>
<div class="col-lg-2">

</div>
</div>
<p><br></p>
<p>We have the same two cases as for <code>lem_union</code></p>
<ol type="1">
<li><p><code>i1..j1</code> encloses <code>i2..j2</code>; here the intersection is just <code>i2..j2</code>,</p></li>
<li><p><code>i1..j1</code> only overlaps <code>i1..j1</code>; here the intersection is the
<em>middle segment</em> <code>i1..j2</code>, which we obtain by</p>
<ol type="a">
<li><em>splitting</em> <code>i1..j1</code> at <code>j2</code>,</li>
<li><em>splitting</em> <code>i2..j2</code> at <code>i1</code>,</li>
<li><em>discarding</em> the end segments which do not belong in the intersection.</li>
</ol></li>
</ol>
<pre><span class=hs-linenum>517: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{j1 : Int | x1 &lt; j1} -&gt; x3:Int -&gt; x4:{j2 : Int | x3 &lt; j2
                                                              &amp;&amp; x1 &lt;= j2
                                                              &amp;&amp; j2 &lt;= x2} -&gt; {VV : () | RangeSet.rng (RangeSet.max x1 x3) x4 == Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)}</span><span class='hs-definition'>lem_intersect</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i1</span></a> <a class=annot href="#"><span class=annottext>{j1 : Int | i1 &lt; j1}</span><span class='hs-varid'>j1</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>i2</span></a> <a class=annot href="#"><span class=annottext>{j2 : Int | i2 &lt; j2
            &amp;&amp; i1 &lt;= j2
            &amp;&amp; j2 &lt;= j1}</span><span class='hs-varid'>j2</span></a>
<span class=hs-linenum>518: </span>  <span class='hs-comment'>-- i1..j1 encloses i2..j2</span>
<span class=hs-linenum>519: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; i1 &lt; i2}</span><span class='hs-varid'>i1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>i2</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; x3:Int -&gt; x4:{v : Int | x3 &lt; v
                                                                &amp;&amp; x3 &lt;= x1
                                                                &amp;&amp; x2 &lt;= v} -&gt; {v : () | Set_sub (RangeSet.rng x1 x2) (RangeSet.rng x3 x4)} | v == RangeSet.lem_sub}</span><span class='hs-varid'>lem_sub</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>j2</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span>
<span class=hs-linenum>520: </span>  <span class='hs-comment'>-- i1..j1 overlaps i2..j2</span>
<span class=hs-linenum>521: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-varid'>i1</span> <span class='hs-varid'>j2</span> <span class='hs-varid'>j1</span>
<span class=hs-linenum>522: </span>            <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt;= v} -&gt; x3:{v : Int | x2 &lt;= v} -&gt; {v : () | RangeSet.rng x1 x3 == Set_cup (RangeSet.rng x1 x2) (RangeSet.rng x2 x3)
                                                                             &amp;&amp; Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x2 x3) == Set_empty 0} | v == RangeSet.lem_split}</span><span class='hs-varid'>lem_split</span></a> <span class='hs-varid'>i2</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>j2</span>
<span class=hs-linenum>523: </span>            <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | x2 &lt;= v} -&gt; x4:Int -&gt; {v : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0} | v == RangeSet.lem_disj}</span><span class='hs-varid'>lem_disj</span></a>  <span class='hs-varid'>i2</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>i1</span> <span class='hs-varid'>j1</span>     <span class='hs-comment'>-- discard i2..i1</span>
<span class=hs-linenum>524: </span>            <a class=annot href="#"><span class=annottext>{v : () -&gt; () -&gt; () | v == Language.Haskell.Liquid.NewProofCombinators.&amp;&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; x3:{v : Int | x2 &lt;= v} -&gt; x4:Int -&gt; {v : () | Set_cap (RangeSet.rng x1 x2) (RangeSet.rng x3 x4) == Set_empty 0} | v == RangeSet.lem_disj}</span><span class='hs-varid'>lem_disj</span></a>  <span class='hs-varid'>i2</span> <span class='hs-varid'>j2</span> <span class='hs-varid'>j2</span> <span class='hs-varid'>j1</span>     <span class='hs-comment'>-- discard j2..j1</span>
</pre>
<h2 id="conclusions">Conclusions</h2>
<p>Whew. That turned out a lot longer than I’d expected!</p>
<p>On the bright side, we saw how to:</p>
<ol type="1">
<li><em>Specify</em> the semantics of range-sets,</li>
<li><em>Write</em> equational proofs using plain Haskell code,</li>
<li><em>Avoid</em> boring proof steps using PLE,</li>
<li><em>Verify</em> key properties of operations on range-sets.</li>
</ol>
<p>Next time we’ll finish the series by showing how to use
the above lemmas to specify and verify the correctness
of <a href="https://www.joachim-breitner.de/blog/734-Finding_bugs_in_Haskell_code_by_proving_it">Breitner’s implementation</a>.</p>
<div class="hidden">
<pre><span class=hs-linenum>547: </span><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<span class=hs-linenum>548: </span><span class='hs-comment'>-- | Some helper definitions</span>
<span class=hs-linenum>549: </span><span class='hs-comment'>--------------------------------------------------------------------------------</span>
<span class=hs-linenum>550: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>min</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>551: </span><span class='hs-definition'>min</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>552: </span><a class=annot href="#"><span class=annottext>(Ord a) =&gt;
x2:a -&gt; x3:a -&gt; {VV : a | VV == RangeSet.min x2 x3
                          &amp;&amp; VV == (if x2 &lt; x3 then x2 else x3)}</span><span class='hs-definition'>min</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; x &lt; y}</span><span class='hs-keyword'>if</span></a> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; x &lt; y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>y</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>x</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>y</span>
<span class=hs-linenum>553: </span>
<span class=hs-linenum>554: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>max</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>555: </span><span class='hs-definition'>max</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>556: </span><a class=annot href="#"><span class=annottext>(Ord a) =&gt;
x2:a -&gt; x3:a -&gt; {VV : a | VV == RangeSet.max x2 x3
                          &amp;&amp; VV == (if x2 &lt; x3 then x3 else x2)}</span><span class='hs-definition'>max</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; x &lt; y}</span><span class='hs-keyword'>if</span></a> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; x &lt; y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>y</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>y</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>x</span>
<span class=hs-linenum>557: </span>
<span class=hs-linenum>558: </span><span class='hs-definition'>rng</span>         <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>S</span><span class='hs-varop'>.</span><span class='hs-conid'>Set</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>559: </span><span class='hs-definition'>test1</span>       <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>560: </span><span class='hs-definition'>test2</span>       <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>561: </span><span class='hs-definition'>test1_ple</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>562: </span><span class='hs-definition'>test2_ple</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>563: </span><span class='hs-definition'>lem_mem</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>564: </span><span class='hs-definition'>lem_mem_ple</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>565: </span><span class='hs-definition'>lem_sub</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>566: </span><span class='hs-definition'>lem_disj</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>567: </span><span class='hs-definition'>lem_disj_ple</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>568: </span><span class='hs-definition'>lem_split</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>569: </span>
<span class=hs-linenum>570: </span><span class='hs-definition'>lem_intersect</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>571: </span><span class='hs-definition'>lem_union</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>()</span>
<span class=hs-linenum>572: </span><span class='hs-comment'>-- https://ucsd-progsys.github.io/liquidhaskell-blog/tags/induction.html</span>
<span class=hs-linenum>573: </span>
</pre>
</div>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2017/12/24/splitting-and-splicing-intervals-II.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2017/12/24/splitting-and-splicing-intervals-II.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Splitting and Splicing Intervals (Part 1)</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2017/12/15/splitting-and-splicing-intervals-I.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2017/12/15/splitting-and-splicing-intervals-I.lhs</id>
    <published>true</published>
    <updated>2017-12-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Splitting and Splicing Intervals (Part 1)</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			Dec 15, 2017
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged &#39;reflection&#39;." href="/tags/reflection.html">reflection</a>, <a title="All pages tagged &#39;abstract-refinements&#39;." href="/tags/abstract-refinements.html">abstract-refinements</a>
              
            </div>

            <br>
			            <p><a href="https://twitter.com/nomeata?lang=en">Joachim Breitner</a>
wrote a <a href="https://www.joachim-breitner.de/blog/734-Finding_bugs_in_Haskell_code_by_proving_it">cool post</a> describing a
library for representing sets of integers
as <em>sorted lists of intervals</em>, and how
they were able to formally verify the
code by translating it to Coq using
their <a href="https://github.com/antalsz/hs-to-coq">nifty new tool</a>.</p>
<ul>
<li><p>First, lets just see how plain refinement types
let us specify the key “goodness” invariant,
and check it automatically.</p></li>
<li><p>Next, we’ll see how LH’s new “type-level computation”
abilities let us specify and check “correctness”,
and even better, understand <em>why</em> the code works.</p></li>
</ul>
<p>(Click here to <a href="http://goto.ucsd.edu:8090/index.html#?demo=IntervalSets.hs">demo</a>)</p>
<!-- more -->
<div class="row-fluid">
<div class="span12 pagination-centered">
<img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ribbon.png"
       alt="Ribbons" height="150">
</div>
</div>
<div class="hidden">
<pre><span class=hs-linenum>41: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--short-names"</span>    <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>42: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--exact-data-con"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>43: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-adt"</span>         <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>44: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--prune-unsorted"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>45: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--higherorder"</span>    <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>46: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--no-termination"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>47: </span>
<span class=hs-linenum>48: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>49: </span>
<span class=hs-linenum>50: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Interval</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span>
<span class=hs-linenum>51: </span>  <span class='hs-layout'>{</span> <span class='hs-varid'>from</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>52: </span>  <span class='hs-layout'>,</span> <span class='hs-varid'>to</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>53: </span>  <span class='hs-layout'>}</span> <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(Show Interval)</span><span class='hs-conid'>Show</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>54: </span>
</pre>
</div>
<h2 id="encoding-sets-as-intervals">Encoding Sets as Intervals</h2>
<p>The key idea underlying the intervals data structure, is that
we can represent sets of integers like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>{ <span class="dv">7</span>, <span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">3</span>, <span class="dv">11</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">12</span>, <span class="dv">4</span>}</span></code></pre></div>
<p>by first <em>ordering</em> them into a list</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>[ <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">12</span> ]</span></code></pre></div>
<p>and then <em>partitioning</em> the list into compact intervals</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>[ (<span class="dv">1</span>, <span class="dv">5</span>), (<span class="dv">7</span>, <span class="dv">8</span>), (<span class="dv">9</span>, <span class="dv">13</span>) ]</span></code></pre></div>
<p>That is,</p>
<ol type="1">
<li><p>Each interval <code>(from, to)</code> corresponds to the set
<code>{from,from+1,...,to-1}</code>.</p></li>
<li><p>Ordering ensures there is a canonical representation
that simplifies interval operations.</p></li>
</ol>
<h2 id="making-illegal-intervals-unrepresentable">Making Illegal Intervals Unrepresentable</h2>
<p>We require that the list of intervals be
“sorted, non-empty, disjoint and non-adjacent”.
Lets follow the slogan of <em>make-illegal-values-unrepresentable</em>
to see how we can encode the legality constraints with refinements.</p>
<p><strong>A Single Interval</strong></p>
<p>We can ensure that each interval is <strong>non-empty</strong> by
refining the data type for a single interval to specify
that the <code>to</code> field must be strictly bigger than the <code>from</code>
field:</p>
<pre><span class=hs-linenum>104: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Interval</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>I</span>
<span class=hs-linenum>105: </span>      <span class='hs-layout'>{</span> <span class='hs-varid'>from</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>106: </span>      <span class='hs-layout'>,</span> <span class='hs-varid'>to</span>   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>from</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>v</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>107: </span>      <span class='hs-layout'>}</span>
<span class=hs-linenum>108: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>Now, LH will ensure that we can only construct <em>legal</em>,
non-empty <code>Interval</code>s</p>
<pre><span class=hs-linenum>115: </span><a class=annot href="#"><span class=annottext>Interval</span><span class='hs-definition'>goodItv</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-num'>10</span> <span class='hs-num'>20</span>
<span class=hs-linenum>116: </span><a class=annot href="#"><span class=annottext>Interval</span><span class='hs-definition'>badItv</span></a>  <span class='hs-keyglyph'>=</span> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>20</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>10</span></span>     <span class='hs-comment'>-- ILLEGAL: empty interval!</span>
</pre>
<p><strong>Many Intervals</strong></p>
<p>We can represent arbitrary sets as a <em>list of</em> <code>Interval</code>s:</p>
<pre><span class=hs-linenum>124: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Intervals</span> <span class='hs-layout'>{</span> <span class='hs-varid'>itvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Interval</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span>
</pre>
<p>The plain Haskell type doesn’t have enough teeth to
enforce legality, specifically, to ensure <em>ordering</em>
and the absence of <em>overlaps</em>. Refinements to the rescue!</p>
<p>First, we specify a <em>lower-bounded</em> <code>Interval</code> as:</p>
<pre><span class=hs-linenum>134: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>LbItv</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Interval</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>N</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>from</span> <span class='hs-varid'>v</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>Intuitively, an <code>LbItv n</code> is one that starts (at or) after <code>n</code>.</p>
<p>Next, we use the above to define an <em>ordered list</em>
of lower-bounded intervals:</p>
<pre><span class=hs-linenum>143: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LbItv</span> <span class='hs-conid'>N</span><span class='hs-keyglyph'>]</span><span class='hs-varop'>&lt;</span><span class='hs-layout'>{</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>vHd</span> <span class='hs-varid'>vTl</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>to</span> <span class='hs-varid'>vHd</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>from</span> <span class='hs-varid'>vTl</span><span class='hs-layout'>}</span><span class='hs-varop'>&gt;</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>The signature above uses an <a href="/tags/abstract-refinements.html">abstract-refinement</a>
to capture the legality requirements.</p>
<ol type="1">
<li><p>An <code>OrdInterval N</code> is a list of <code>Interval</code> that are
lower-bounded by <code>N</code>, and</p></li>
<li><p>In each sub-list, the head <code>Interval</code> <code>vHd</code> <em>precedes</em>
each in the tail <code>vTl</code>.</p></li>
</ol>
<h2 id="legal-intervals">Legal Intervals</h2>
<p>We can now describe legal <code>Intervals</code> simply as:</p>
<pre><span class=hs-linenum>161: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Intervals</span> <span class='hs-layout'>{</span> <span class='hs-varid'>itvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-num'>0</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>LH will now ensure that illegal <code>Intervals</code> are not representable.</p>
<pre><span class=hs-linenum>167: </span><a class=annot href="#"><span class=annottext>Intervals</span><span class='hs-definition'>goodItvs</span></a>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1
                                                                     &amp;&amp; lqdc##$select v == x1
                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}</span><span class='hs-conid'>Intervals</span></a> <span class='hs-keyglyph'>[</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-num'>1</span> <span class='hs-num'>5</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-num'>7</span> <span class='hs-num'>8</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-num'>9</span> <span class='hs-num'>13</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- LEGAL</span>
<span class=hs-linenum>168: </span>
<span class=hs-linenum>169: </span><a class=annot href="#"><span class=annottext>Intervals</span><span class='hs-definition'>badItvs1</span></a>  <span class='hs-keyglyph'>=</span> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1
                                                                     &amp;&amp; lqdc##$select v == x1
                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}</span><span class='hs-conid'>Intervals</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-keyglyph'>[</span></span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>1</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>7</span></span><span class=hs-error><span class='hs-layout'>,</span></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>5</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>8</span></span><span class=hs-error><span class='hs-keyglyph'>]</span></span>          <span class='hs-comment'>-- ILLEGAL: overlap!</span>
<span class=hs-linenum>170: </span><a class=annot href="#"><span class=annottext>Intervals</span><span class='hs-definition'>badItvs2</span></a>  <span class='hs-keyglyph'>=</span> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1
                                                                     &amp;&amp; lqdc##$select v == x1
                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}</span><span class='hs-conid'>Intervals</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-keyglyph'>[</span></span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>1</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>5</span></span><span class=hs-error><span class='hs-layout'>,</span></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>9</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>13</span></span><span class=hs-error><span class='hs-layout'>,</span></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>7</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>8</span></span><span class=hs-error><span class='hs-keyglyph'>]</span></span>  <span class='hs-comment'>-- ILLEGAL: disorder!</span>
</pre>
<p>Do the types <em>really</em> capture the legality requirements?
In the original code, Breitner described goodness as a
recursively defined predicate that takes an additional
<em>lower bound</em> <code>lb</code> and returns <code>True</code> iff the representation
was legal:</p>
<pre><span class=hs-linenum>180: </span><span class='hs-definition'>goodLIs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Interval</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>181: </span><a class=annot href="#"><span class=annottext>x1:{v : Int | v &gt;= 0} -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; {v : Bool | v}</span><span class='hs-definition'>goodLIs</span></a> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<span class=hs-linenum>182: </span><span class='hs-definition'>goodLIs</span> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span> <span class='hs-varid'>f</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>Bool</span><span class='hs-varid'>lb</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}</span><span class='hs-varop'>&lt;=</span></a> <span class='hs-varid'>f</span> <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; x2:Bool -&gt; {v : Bool | v &lt;=&gt; x1
                                             &amp;&amp; x2} | v == GHC.Classes.&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; f &lt; t}</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>t</span> <a class=annot href="#"><span class=annottext>{v : x1:Bool -&gt; x2:Bool -&gt; {v : Bool | v &lt;=&gt; x1
                                             &amp;&amp; x2} | v == GHC.Classes.&amp;&amp;}</span><span class='hs-varop'>&amp;&amp;</span></a> <a class=annot href="#"><span class=annottext>x1:{v : Int | v &gt;= 0} -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; {v : Bool | v}</span><span class='hs-varid'>goodLIs</span></a> <span class='hs-varid'>t</span> <span class='hs-varid'>is</span>
</pre>
<p>We can check that our type-based representation is indeed
legit by checking that <code>goodLIs</code> returns <code>True</code> whenever it
is called with a valid of <code>OrdItvs</code>:</p>
<pre><span class=hs-linenum>190: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>goodLIs</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>lb</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>is</span><span class='hs-conop'>:</span><span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v :</span> <span class='hs-conid'>Bool</span> <span class='hs-keyword'>| v }</span> <span class='hs-keyword'>@-}</span>
</pre>
<h2 id="algorithms-on-intervals">Algorithms on Intervals</h2>
<p>We represent legality as a type, but is that <em>good for</em>?
After all, we could, as seen above, just as well have written a
predicate <code>goodLIs</code>? The payoff comes when it comes to <em>using</em>
the <code>Intervals</code> e.g. to implement various set operations.</p>
<p>For example, here’s the code for <em>intersecting</em> two sets,
each represented as intervals. We’ve made exactly one
change to the function implemented by Breitner: we added
the extra lower-bound parameter <code>lb</code> to the recursive <code>go</code>
to make clear that the function takes two <code>OrdItvs lb</code>
and returns an <code>OrdItvs lb</code>.</p>
<pre><span class=hs-linenum>210: </span><span class='hs-definition'>intersect</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Intervals</span>
<span class=hs-linenum>211: </span><a class=annot href="#"><span class=annottext>Intervals -&gt; Intervals -&gt; Intervals</span><span class='hs-definition'>intersect</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Intervals</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Intervals</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1
                                                                     &amp;&amp; lqdc##$select v == x1
                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}</span><span class='hs-conid'>Intervals</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] | v == go}</span><span class='hs-varid'>go</span></a> <span class='hs-num'>0</span> <span class='hs-varid'>is1</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>212: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>213: </span>    <span class='hs-keyword'>{-@</span> <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>lb</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>214: </span>    <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<span class=hs-linenum>215: </span>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<span class=hs-linenum>216: </span>    <span class='hs-varid'>go</span> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span> <span class='hs-varid'>f1</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span> <span class='hs-varid'>f2</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>217: </span>      <span class='hs-comment'>-- reorder for symmetry</span>
<span class=hs-linenum>218: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; t1 &lt; t2}</span><span class='hs-varid'>t1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>t2</span>   <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-varid'>is2</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-varid'>is1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>219: </span>      <span class='hs-comment'>-- disjoint</span>
<span class=hs-linenum>220: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; f1 &gt;= t2}</span><span class='hs-varid'>f1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt;= x2}</span><span class='hs-varop'>&gt;=</span></a> <span class='hs-varid'>t2</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-varid'>is2</span>
<span class=hs-linenum>221: </span>      <span class='hs-comment'>-- subset</span>
<span class=hs-linenum>222: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; t1 == t2}</span><span class='hs-varid'>t1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-varid'>t2</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>f'</span> <span class='hs-varid'>t2</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>t2</span> <span class='hs-varid'>is1</span> <span class='hs-varid'>is2</span>
<span class=hs-linenum>223: </span>      <span class='hs-comment'>-- overlapping</span>
<span class=hs-linenum>224: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; f2 &lt; f1}</span><span class='hs-varid'>f2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>f1</span>   <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>f'</span> <span class='hs-varid'>t2</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>t2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>t2</span> <span class='hs-varid'>t1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>225: </span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>f2</span> <span class='hs-varid'>t1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>226: </span>      <span class='hs-keyword'>where</span> <a class=annot href="#"><span class=annottext>{v : Int | v == (if f1 &gt; f2 then f1 else f2)}</span><span class='hs-varid'>f'</span></a>    <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == (if x1 &gt; x2 then x1 else x2)}</span><span class='hs-varid'>max</span></a> <span class='hs-varid'>f1</span> <span class='hs-varid'>f2</span>
</pre>
<h2 id="internal-vs-external-verification">Internal vs External Verification</h2>
<p>By representing legality <strong>internally</strong> as a refinement type,
as opposed to <strong>externally</strong> as predicate (<code>goodLIs</code>) we have
exposed enough information about the structure of the values
that LH can <em>automatically</em> chomp through the above code to
guarantee that we haven’t messed up the invariants.</p>
<p>To appreciate the payoff, compare to the effort needed
to verify legality using the external representation
used in the <a href="https://github.com/antalsz/hs-to-coq/blob/8f84d61093b7be36190142c795d6cd4496ef5aed/examples/intervals/Proofs.v#L370-L439">hs-to-coq proof</a>.</p>
<p>The same principle and simplification benefits apply to both the <code>union</code></p>
<pre><span class=hs-linenum>245: </span><span class='hs-definition'>union</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Intervals</span>
<span class=hs-linenum>246: </span><a class=annot href="#"><span class=annottext>Intervals -&gt; Intervals -&gt; Intervals</span><span class='hs-definition'>union</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Intervals</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Intervals</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1
                                                                     &amp;&amp; lqdc##$select v == x1
                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}</span><span class='hs-conid'>Intervals</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] | v == go}</span><span class='hs-varid'>go</span></a> <span class='hs-num'>0</span> <span class='hs-varid'>is1</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>247: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>248: </span>    <span class='hs-keyword'>{-@</span> <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>lb</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>249: </span>    <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>[Interval]</span><span class='hs-varid'>is</span></a> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is</span>
<span class=hs-linenum>250: </span>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>is</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is</span>
<span class=hs-linenum>251: </span>    <span class='hs-varid'>go</span> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span> <span class='hs-varid'>f1</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span> <span class='hs-varid'>f2</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>252: </span>      <span class='hs-comment'>-- reorder for symmetry</span>
<span class=hs-linenum>253: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; t1 &lt; t2}</span><span class='hs-varid'>t1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>t2</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-varid'>is2</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-varid'>is1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>254: </span>      <span class='hs-comment'>-- disjoint</span>
<span class=hs-linenum>255: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; f1 &gt; t2}</span><span class='hs-varid'>f1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &gt; x2}</span><span class='hs-varop'>&gt;</span></a> <span class='hs-varid'>t2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>i2</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>t2</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-varid'>is2</span>
<span class=hs-linenum>256: </span>      <span class='hs-comment'>-- overlapping</span>
<span class=hs-linenum>257: </span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>f'</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-varid'>is2</span>
<span class=hs-linenum>258: </span>      <span class='hs-keyword'>where</span>
<span class=hs-linenum>259: </span>        <a class=annot href="#"><span class=annottext>{v : Int | v == (if f1 &lt; f2 then f1 else f2)}</span><span class='hs-varid'>f'</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == (if x1 &lt; x2 then x1 else x2)}</span><span class='hs-varid'>min</span></a> <span class='hs-varid'>f1</span> <span class='hs-varid'>f2</span>
</pre>
<p>and the <code>subtract</code> functions too:</p>
<pre><span class=hs-linenum>265: </span><span class='hs-definition'>subtract</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Intervals</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Intervals</span>
<span class=hs-linenum>266: </span><a class=annot href="#"><span class=annottext>Intervals -&gt; Intervals -&gt; Intervals</span><span class='hs-definition'>subtract</span></a> <span class='hs-layout'>(</span><span class='hs-conid'>Intervals</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Intervals</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:[{v : Interval | 0 &lt;= Intervals.from v}] -&gt; {v : Intervals | Intervals.itvs v == x1
                                                                     &amp;&amp; lqdc##$select v == x1
                                                                     &amp;&amp; v == Intervals.Intervals x1} | v == Intervals.Intervals}</span><span class='hs-conid'>Intervals</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] | v == go}</span><span class='hs-varid'>go</span></a> <span class='hs-num'>0</span> <span class='hs-varid'>is1</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>267: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>268: </span>    <span class='hs-keyword'>{-@</span> <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>lb</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OrdItvs</span> <span class='hs-varid'>lb</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>269: </span>    <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>[Interval]</span><span class='hs-varid'>is</span></a> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is</span>
<span class=hs-linenum>270: </span>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<span class=hs-linenum>271: </span>    <span class='hs-varid'>go</span> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span> <span class='hs-varid'>f1</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>I</span> <span class='hs-varid'>f2</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>272: </span>      <span class='hs-comment'>-- i2 past i1</span>
<span class=hs-linenum>273: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; t1 &lt;= f2}</span><span class='hs-varid'>t1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}</span><span class='hs-varop'>&lt;=</span></a> <span class='hs-varid'>f2</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>t1</span> <span class='hs-varid'>is1</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-varid'>is2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>274: </span>      <span class='hs-comment'>-- i1 past i2</span>
<span class=hs-linenum>275: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; t2 &lt;= f1}</span><span class='hs-varid'>t2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}</span><span class='hs-varop'>&lt;=</span></a> <span class='hs-varid'>f1</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>lb</span> <span class='hs-layout'>(</span><span class='hs-varid'>i1</span><span class='hs-conop'>:</span><span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>276: </span>      <span class='hs-comment'>-- i1 contained in i2</span>
<span class=hs-linenum>277: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; f2 &lt;= f1}</span><span class='hs-varid'>f2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}</span><span class='hs-varop'>&lt;=</span></a> <span class='hs-varid'>f1</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; t1 &lt;= t2}</span><span class='hs-varid'>t1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}</span><span class='hs-varop'>&lt;=</span></a> <span class='hs-varid'>t2</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>lb</span> <span class='hs-varid'>is1</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>278: </span>      <span class='hs-comment'>-- i2 covers beginning of i1</span>
<span class=hs-linenum>279: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; f2 &lt;= f1}</span><span class='hs-varid'>f2</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}</span><span class='hs-varop'>&lt;=</span></a> <span class='hs-varid'>f1</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>t2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>t2</span> <span class='hs-varid'>t1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-varid'>is2</span>
<span class=hs-linenum>280: </span>      <span class='hs-comment'>-- -- i2 covers end of i1</span>
<span class=hs-linenum>281: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>{v : Bool | v &lt;=&gt; t1 &lt;= t2}</span><span class='hs-varid'>t1</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt;= x2}</span><span class='hs-varop'>&lt;=</span></a> <span class='hs-varid'>t2</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>f1</span> <span class='hs-varid'>f2</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>f2</span> <span class='hs-varid'>is1</span> <span class='hs-layout'>(</span><span class='hs-varid'>i2</span><span class='hs-conop'>:</span><span class='hs-varid'>is2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>282: </span>      <span class='hs-comment'>-- i2 in the middle of i1</span>
<span class=hs-linenum>283: </span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>f1</span> <span class='hs-varid'>f2</span> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>x1:Int -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}] -&gt; [{v : Interval | x1 &lt;= Intervals.from v}]</span><span class='hs-varid'>go</span></a> <span class='hs-varid'>f2</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | x1 &lt; v} -&gt; {v : Interval | Intervals.to v == x2
                                                        &amp;&amp; Intervals.from v == x1
                                                        &amp;&amp; lqdc##$select v == x2
                                                        &amp;&amp; lqdc##$select v == x1
                                                        &amp;&amp; v == Intervals.I x1 x2} | v == Intervals.I}</span><span class='hs-conid'>I</span></a> <span class='hs-varid'>t2</span> <span class='hs-varid'>t1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>is1</span><span class='hs-layout'>)</span> <span class='hs-varid'>is2</span><span class='hs-layout'>)</span>
</pre>
<p>both of which require <a href="https://github.com/antalsz/hs-to-coq/blob/b7efc7a8dbacca384596fc0caf65e62e87ef2768/examples/intervals/Proofs_Function.v#L319-L382">non-trivial</a> <a href="https://github.com/antalsz/hs-to-coq/blob/8f84d61093b7be36190142c795d6cd4496ef5aed/examples/intervals/Proofs.v#L565-L648">proofs</a>
in the <em>external style</em>. (Of course, its possible those proofs can be
simplified.)</p>
<h2 id="summing-up-and-looking-ahead">Summing Up (and Looking Ahead)</h2>
<p>I hope the above example illustrates why <em>“making illegal states”</em>
unrepresentable is a great principle for engineering code <em>and</em> proofs.</p>
<p>That said, notice that with <a href="https://www.joachim-breitner.de/blog/734-Finding_bugs_in_Haskell_code_by_proving_it">hs-to-coq</a>, Breitner
was able to go <em>far beyond</em> the above legality requirement: he was able
to specify and verify the far more important (and difficult) property
that the above is a <em>correct</em> implementation of a Set library.</p>
<p>Is it even <em>possible</em>, let alone <em>easier</em> to do that with LH?</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2017/12/15/splitting-and-splicing-intervals-I.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2017/12/15/splitting-and-splicing-intervals-I.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Arithmetic Overflows</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2017/03/20/arithmetic-overflows.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2017/03/20/arithmetic-overflows.lhs</id>
    <published>true</published>
    <updated>2017-03-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Arithmetic Overflows</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			Mar 20, 2017
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged &#39;basic&#39;." href="/tags/basic.html">basic</a>
              
            </div>

            <br>
			            <p>Computers are great at crunching numbers.
However, if programmers aren’t careful, their
machines can end up biting off more than
they can chew: simple arithmetic operations
over very large (or very tiny) inputs can
<em>overflow</em> leading to bizarre crashes
or vulnerabilities. For example,
<a href="https://research.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html">Joshua Bloch’s classic post</a>
argues that nearly all binary searches
are broken due to integer overflows.
Lets see how we can teach LiquidHaskell
to spot such overflows.</p>
<!-- more -->
<div class="hidden">
<pre><span class=hs-linenum>30: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Bounded</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>31: </span>
<span class=hs-linenum>32: </span><span class='hs-keyword'>import</span>           <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Exception</span> <span class='hs-layout'>(</span><span class='hs-varid'>assert</span><span class='hs-layout'>)</span>
<span class=hs-linenum>33: </span><span class='hs-keyword'>import</span>           <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-conid'>Num</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>34: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Prelude</span>
<span class=hs-linenum>35: </span>
<span class=hs-linenum>36: </span><span class='hs-definition'>plusStrict</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>37: </span><span class='hs-definition'>plusLazy</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>38: </span><span class='hs-definition'>mono</span>       <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
</pre>
</div>
<h2 id="the-problem">1. The Problem</h2>
<p>LiquidHaskell, like some programmers, likes to make believe
that <code>Int</code> represents the set of integers. For example, you
might define a function <code>plus</code> as:</p>
<pre><span class=hs-linenum>51: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>plus</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span> <span class='hs-keyword'>| v == x + y}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>52: </span><span class='hs-definition'>plus</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>53: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-definition'>plus</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | v == y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-conid'>Prelude</span></a><span class='hs-varop'>.+</span> <span class='hs-varid'>y</span>
</pre>
<p>The output type of the function states that the returned value
is equal to the  result of adding the two inputs.</p>
<p>The above signature lets us “prove” facts like addition by one
yields a bigger number:</p>
<pre><span class=hs-linenum>63: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>monoPlus</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| v &lt;=&gt; true }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>64: </span><span class='hs-definition'>monoPlus</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<span class=hs-linenum>65: </span><a class=annot href="#"><span class=annottext>Int -&gt; {v : Bool | v &lt;=&gt; true}</span><span class='hs-definition'>monoPlus</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | v == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2} | v == Bounded.plus}</span><span class='hs-varid'>plus</span></a> <span class='hs-varid'>x</span> <span class='hs-num'>1</span>
</pre>
<p>Unfortunately, the signature for plus and hence, the above
“fact” are both lies.</p>
<p>LH <em>checks</em> <code>plus</code> as the same signature is <em>assumed</em>
for the primitive <code>Int</code> addition operator <code>Prelude.+</code>.
LH has to assume <em>some</em> signature for this “foreign”
machine operation, and by default, LH assumes that
machine addition behaves like logical addition.</p>
<p>However, this assumption, and its consequences are
only true upto a point:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span>  monoPlus <span class="dv">0</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span>  monoPlus <span class="dv">100</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span>  monoPlus <span class="dv">10000</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span>  monoPlus <span class="dv">1000000</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span></span></code></pre></div>
<p>Once we get to <code>maxBound</code> at the very edge of <code>Int</code>,
a tiny bump is enough to send us tumbling backwards
into a twilight zone.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> monoPlus <span class="fu">maxBound</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">False</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> plus <span class="fu">maxBound</span> <span class="dv">1</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="dv">9223372036854775808</span></span></code></pre></div>
<h2 id="keeping-int-in-their-place">2. Keeping Int In Their Place</h2>
<p>The news isn’t all bad: the glass half full
view is that for “reasonable” values
like 10, 100, 10000 and 1000000, the
machine’s arithmetic <em>is</em> the same as
logical arithmetic. Lets see how to impart
this wisdom to LH. We do this in two steps:
define the <em>biggest</em> <code>Int</code> value, and then,
use this value to type the arithmetic operations.</p>
<p><strong>A. The Biggest Int</strong></p>
<p>First, we need a way to talk about
“the edge” – i.e. the largest <code>Int</code>
value at which overflows occur.</p>
<p>We could use the concrete number</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span><span class="ot"> maxBound ::</span> <span class="dt">Int</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dv">9223372036854775807</span></span></code></pre></div>
<p>However, instead of hardwiring a particular number,
a more general strategy is to define a symbolic
constant <code>maxInt</code> to represent <em>any</em> arbitrary
overflow value and thus, make the type checking
robust to different machine integer widths.</p>
<pre><span class=hs-linenum>135: </span><span class='hs-comment'>-- defines an Int constant called `maxInt`</span>
<span class=hs-linenum>136: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>maxInt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>To tell LH that <code>maxInt</code> is the “biggest” <code>Int</code>,
we write a predicate that describes values bounded
by <code>maxInt</code>:</p>
<pre><span class=hs-linenum>144: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>predicate</span> <span class='hs-conid'>Bounded</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> <span class='hs-varop'>&lt;</span> <span class='hs-conid'>N</span> <span class='hs-varop'>+</span> <span class='hs-varid'>maxInt</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-conid'>N</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>maxInt</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>Thus, <code>Bounded n</code> means that the number <code>n</code> is in
the range <code>[-maxInt, maxInt]</code>.</p>
<p><strong>B. Bounded Machine Arithmetic</strong></p>
<p>Next, we can assign the machine arithmetic operations
types that properly capture the possibility of arithmetic
overflows. Here are <em>two</em> possible specifications.</p>
<p><strong>Strict: Thou Shalt Not Overflow</strong> A <em>strict</em> specification
simply prohibits any overflow:</p>
<pre><span class=hs-linenum>160: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>plusStrict</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Int|Bounded(x+y)}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span><span class='hs-keyword'>|v = x+y}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>161: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{y : Int | 0 &lt; (x1 + y) + maxInt
                        &amp;&amp; x1 + y &lt; maxInt} -&gt; {v : Int | v == x1 + x2}</span><span class='hs-definition'>plusStrict</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{y : Int | 0 &lt; (x + y) + maxInt
           &amp;&amp; x + y &lt; maxInt}</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | 0 &lt; (x + v) + maxInt
           &amp;&amp; x + v &lt; maxInt
           &amp;&amp; v == y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-conid'>Prelude</span></a><span class='hs-varop'>.+</span> <span class='hs-varid'>y</span>
</pre>
<p>The inputs <code>x</code> and <code>y</code> <em>must</em> be such that the result is <code>Bounded</code>,
and in that case, the output value is indeed their logical sum.</p>
<p><strong>Lazy: Overflow at Thine Own Risk</strong> Instead, a <em>lazy</em>
specification could permit overflows but gives no
guarantees about the output when they occur.</p>
<pre><span class=hs-linenum>172: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>plusLazy</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span><span class='hs-keyword'>|Bounded(x+y) =&gt; v = x+y}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>173: </span><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | 0 &lt; (x1 + x2) + maxInt
                               &amp;&amp; x1 + x2 &lt; maxInt =&gt; v == x1 + x2}</span><span class='hs-definition'>plusLazy</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | v == y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-conid'>Prelude</span></a><span class='hs-varop'>.+</span> <span class='hs-varid'>y</span>
</pre>
<p>The lazy specification says that while <code>plusLazy</code>
can be called with any values you like, the
result is the logical sum
<em>only if there is no overflow</em>.</p>
<p>To understand the difference between the two
specifications, lets revisit the <code>monoPlus</code>
property using the new machine-arithmetic
sensitive signatures:</p>
<pre><span class=hs-linenum>188: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>monoPlusStrict</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| v &lt;=&gt; true }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>189: </span><a class=annot href="#"><span class=annottext>Int -&gt; {v : Bool | v &lt;=&gt; true}</span><span class='hs-definition'>monoPlusStrict</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | v == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:{v : Int | 0 &lt; (x1 + v) + maxInt
                             &amp;&amp; x1 + v &lt; maxInt} -&gt; {v : Int | v == x1 + x2} | v == Bounded.plusStrict}</span><span class='hs-varid'>plusStrict</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>x</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>1</span></span>
<span class=hs-linenum>190: </span>
<span class=hs-linenum>191: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>monoPlusLazy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| v &lt;=&gt; true }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>192: </span><a class=annot href="#"><span class=annottext>Int -&gt; {v : Bool | v &lt;=&gt; true}</span><span class='hs-definition'>monoPlusLazy</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <span class=hs-error><a class=annot href="#"><span class=annottext>{v : Int | v == x}</span><span class='hs-varid'>x</span></a></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a></span><span class=hs-error> </span><span class=hs-error><a class=annot href="#"><span class=annottext>{v : x1:Int -&gt; x2:Int -&gt; {v : Int | 0 &lt; (x1 + x2) + maxInt
                                    &amp;&amp; x1 + x2 &lt; maxInt =&gt; v == x1 + x2} | v == Bounded.plusLazy}</span><span class='hs-varid'>plusLazy</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-varid'>x</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>1</span></span>
</pre>
<p>Both are rejected by LH, since, as we saw earlier,
the functions <em>do not</em> always evaluate to <code>True</code>.
However, in the strict version the error is at the
possibly overflowing call to <code>plusStrict</code>.
In the lazy version, the call to <code>plusLazy</code> is
accepted, but as the returned value is some
arbitrary <code>Int</code> (not the logical <code>x+1</code>), the
comparison may return <code>False</code> hence the output
is not always <code>True</code>.</p>
<p><strong>Exercise:</strong> Can you fix the specification
for <code>monoPlusStrict</code> and <code>monoPlusLazy</code> to
get LH to verify the implementation?</p>
<h2 id="a-typeclass-for-machine-arithmetic">3. A Typeclass for Machine Arithmetic</h2>
<p>Its a bit inconvenient to write <code>plusStrict</code> and <code>plusLazy</code>,
and really, we’d just like to write <code>+</code> and <code>-</code> and so on.
We can do so, by tucking the above specifications into
a <em>bounded numeric</em> typeclass whose signatures capture machine
arithmetic. First, we define a <code>BoundedNum</code> variant of <code>Num</code></p>
<pre><span class=hs-linenum>220: </span><span class='hs-keyword'>class</span> <span class='hs-conid'>BoundedNum</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>221: </span>  <span class='hs-layout'>(</span><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>222: </span>  <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>223: </span>  <span class='hs-comment'>-- other operations ...</span>
</pre>
<p>and now, we can define its <code>Int</code> instance just as wrappers
around the <code>Prelude</code> operations:</p>
<pre><span class=hs-linenum>230: </span><span class='hs-keyword'>instance</span> <span class='hs-conid'>BoundedNum</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>231: </span>  <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{y : Int | 0 &lt; (x1 + y) + maxInt
                        &amp;&amp; x1 + y &lt; maxInt} -&gt; {v : Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{y : Int | 0 &lt; (x + y) + maxInt
           &amp;&amp; x + y &lt; maxInt}</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | 0 &lt; (x + v) + maxInt
           &amp;&amp; x + v &lt; maxInt
           &amp;&amp; v == y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 + x2}</span><span class='hs-conid'>Prelude</span></a><span class='hs-varop'>.+</span> <span class='hs-varid'>y</span>
<span class=hs-linenum>232: </span>  <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:{y : Int | 0 &lt; (x1 - y) + maxInt
                        &amp;&amp; x1 - y &lt; maxInt} -&gt; {v : Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a> <a class=annot href="#"><span class=annottext>{y : Int | 0 &lt; (x - y) + maxInt
           &amp;&amp; x - y &lt; maxInt}</span><span class='hs-varid'>y</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | 0 &lt; (x - v) + maxInt
           &amp;&amp; x - v &lt; maxInt
           &amp;&amp; v == y}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Int | v == x1 - x2}</span><span class='hs-conid'>Prelude</span></a><span class='hs-varop'>.-</span> <span class='hs-varid'>y</span>
</pre>
<p>Finally, we can tell LH that the above above instance obeys the
(strict) specifications for machine arithmetic:</p>
<pre><span class=hs-linenum>239: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>BoundedNum</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>240: </span>      <span class='hs-varop'>+</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Int | Bounded (x+y)}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span> <span class='hs-keyword'>| v == x+y }</span><span class='hs-layout'>;</span>
<span class=hs-linenum>241: </span>      <span class='hs-comment'>-</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Int | Bounded (x-y)}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Int</span> <span class='hs-keyword'>| v == x-y }</span>
<span class=hs-linenum>242: </span>  <span class='hs-keyword'>@-}</span>
</pre>
<p>With the above instance in scope, we can just use the plain <code>+</code>
operator and have LH flag potential overflows:</p>
<pre><span class=hs-linenum>249: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>mono</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span><span class='hs-conid'>Bool</span> <span class='hs-keyword'>| v &lt;=&gt; true}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>250: </span><a class=annot href="#"><span class=annottext>Int -&gt; {v : Bool | v &lt;=&gt; true}</span><span class='hs-definition'>mono</span></a> <a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Int | v == x}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:Int -&gt; x2:Int -&gt; {v : Bool | v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class=hs-error><a class=annot href="#"><span class=annottext>Int</span><span class='hs-varid'>x</span></a></span><span class=hs-error> </span><span class=hs-error><span class='hs-varop'>+</span></span><span class=hs-error> </span><span class=hs-error><span class='hs-num'>1</span></span>
</pre>
<h2 id="an-application-binary-search">4. An Application: Binary Search</h2>
<p>The above seems a bit paranoid. Do overflows <em>really</em> matter?
And if they do, is it really practical to check for them using
the above?</p>
<p><a href="https://research.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html">Joshua Bloch’s</a> famous article describes a
tricky overflow bug in an implementation of binary-search
that lay hidden in plain sight in classic textbooks and his
own implementation in the JDK for nearly a decade.
Gabriel Gonzalez wrote a lovely <a href="http://www.haskellforall.com/2015/12/compile-time-memory-safety-using-liquid.html">introduction to LH</a>
using binary-search as an example, and a careful reader
<a href="https://www.reddit.com/r/haskell/comments/3ysh9k/haskell_for_all_compiletime_memory_safety_using/cyg8g60/">pointed out</a> that it had the same
overflow bug!</p>
<p>Lets see how we might spot and fix such bugs using <code>BoundedNum</code>.
(<em>Hover over the images to animate</em>.)</p>
<div class="row">
<div class="col-md-4">
<p><strong>A. Off by One</strong> Lets begin by just using
the default <code>Num Int</code> which ignores overflow.
As Gabriel explains, LH flags a bunch of errors
if we start the search with <code>loop x v 0 n</code> as
the resulting search can access <code>v</code> at any
index between <code>0</code> and <code>n</code> inclusive, which
may lead to an out of bounds at <code>n</code>.
We can fix the off-by-one by correcting the
upper bound to <code>n-1</code>, at which point LH
reports the code free of errors.</p>
</div>
<div class="col-md-8">
<p><img id="splash-binarySearch-A"
     class="center-block anim"
     png="/liquidhaskell-blog/static/img/splash-binarySearch-A.png"
     src="/liquidhaskell-blog/static/img/splash-binarySearch-A.png"></p>
</div>
</div>
<p><br></p>
<div class="row">
<div class="col-md-8">
<p><img id="splash-binarySearch-B"
     class="center-block anim"
     png="/liquidhaskell-blog/static/img/splash-binarySearch-B.png"
     src="/liquidhaskell-blog/static/img/splash-binarySearch-B.png"></p>
</div>
<div class="col-md-4">
<p><strong>B. Lots of Overflows</strong> To spot arithmetic overflows, we need
only hide the default <code>Prelude</code> and instead import the <code>BoundedNum</code>
instance described above. Upon doing so, LH flags a whole bunch of
potential errors – essentially <em>all</em> the arithmetic operations which
seems rather dire!</p>
</div>
</div>
<div class="row">
<div class="col-md-4">
<p><strong>C. Vector Sizes are Bounded</strong> Of course, things
aren’t <em>so</em> bad. LH is missing the information that
the size of any <code>Vector</code> must be <code>Bounded</code>. Once we
inform LH about this invariant with the
<a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/README.md#invariants"><code>using</code> directive</a>, it infers that
as the <code>lo</code> and <code>hi</code> indices are upper-bounded by
the <code>Vector</code>’s size, all the arithmetic on them is
also <code>Bounded</code> and hence, free of overflows.</p>
</div>
<div class="col-md-8">
<p><img id="splash-binarySearch-C"
     class="center-block anim"
     png="/liquidhaskell-blog/static/img/splash-binarySearch-C.png"
     src="/liquidhaskell-blog/static/img/splash-binarySearch-C.png"></p>
</div>
</div>
<p><br></p>
<div class="row">
<div class="col-md-8">
<p><img id="splash-binarySearch-D"
     class="center-block anim"
     png="/liquidhaskell-blog/static/img/splash-binarySearch-D.png"
     src="/liquidhaskell-blog/static/img/splash-binarySearch-D.png"></p>
</div>
<div class="col-md-4">
<p><strong>D. Staying In The Middle</strong>
Well, <em>almost</em> all. The one pesky pink highlight that
remains is exactly the bug that Bloch made famous. Namely:
the addition used to compute the new midpoint between <code>lo</code>
and <code>hi</code> could overflow e.g. if the array was large and both
those indices were near the end. To ensure the machine doesn’t
choke, we follow Bloch’s suggestion and re-jigger the computation
to instead compute the midpoint by splitting the difference
between <code>hi</code> and <code>lo</code>! the code is now free of arithmetic
overflows and truly memory safe.</p>
</div>
</div>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2017/03/20/arithmetic-overflows.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2017/03/20/arithmetic-overflows.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Refinement Reflection on ADTs</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2016/10/06/structural-induction.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2016/10/06/structural-induction.lhs</id>
    <published>true</published>
    <updated>2016-10-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Refinement Reflection on ADTs</h1>
                    
                    <span class="meta">
		    
			Posted by Niki Vazou
		    
			Oct  6, 2016
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged &#39;reflection&#39;." href="/tags/reflection.html">reflection</a>, <a title="All pages tagged &#39;induction&#39;." href="/tags/induction.html">induction</a>, <a title="All pages tagged &#39;measures&#39;." href="/tags/measures.html">measures</a>
              
            </div>

            <br>
			            <h2 id="lists-are-monoids">Lists are Monoids</h2>
<p><a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2016/09/18/refinement-reflection.lhs/">Previously</a> we saw how Refinement Reflection
can be used to write Haskell functions that prove theorems about
other Haskell functions. Today, we will see how Refinement Reflection
works on <strong>recursive data types</strong>.
As an example, we will prove that <strong>lists are monoids</strong> (under nil and append).</p>
<p>Lets see how to express <strong>the monoid laws</strong> as liquid types, and then prove
the laws by writing plain Haskell functions that are checked by LiquidHaskell.</p>
<!-- more -->
<p><br></p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<p style="text-align:center">
<img class="center-block" src="http://www.aaronartprints.org/images/Paintings/4597.jpg" alt="Recursion" width="300">
<br>
Recursive Paper and Pencil Proofs.
“Drawing Hands” by Escher.
<br>
</p>
</div>
</div>
<div class="hidden">
<pre><span class=hs-linenum>46: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--higherorder"</span>     <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>47: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--totality"</span>        <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>48: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>StructuralInduction</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>49: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Language</span><span class='hs-varop'>.</span><span class='hs-conid'>Haskell</span><span class='hs-varop'>.</span><span class='hs-conid'>Liquid</span><span class='hs-varop'>.</span><span class='hs-conid'>ProofCombinators</span>
<span class=hs-linenum>50: </span>
<span class=hs-linenum>51: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span><span class='hs-layout'>)</span>
<span class=hs-linenum>52: </span>
<span class=hs-linenum>53: </span><span class='hs-definition'>length</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>54: </span><span class='hs-definition'>leftId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
<span class=hs-linenum>55: </span><span class='hs-definition'>rightId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
<span class=hs-linenum>56: </span><span class='hs-definition'>associativity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
</pre>
</div>
<h2 id="lists">Lists</h2>
<p>First, lets define the <code>List a</code> data type</p>
<pre><span class=hs-linenum>66: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>C</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
</pre>
<h2 id="induction-on-lists">Induction on Lists</h2>
<p>As we will see, <em>proofs</em> by structural induction will correspond to
<em>programs</em> that perform recursion on lists. To keep things legit,
we must verify that those programs are total and terminating.</p>
<p>To that end, lets define a <code>length</code> function that
computes the natural number that is the size of a
list.</p>
<pre><span class=hs-linenum>81: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>length</span>               <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>82: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>length</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nat</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>83: </span><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                        &amp;&amp; v == length x1}</span><span class='hs-definition'>length</span></a> <span class='hs-conid'>N</span>        <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<span class=hs-linenum>84: </span><span class='hs-definition'>length</span> <span class='hs-layout'>(</span><span class='hs-conid'>C</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == (1 : int)}</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v == length xs
                     &amp;&amp; v == length xs}</span><span class='hs-varid'>length</span></a> <span class='hs-varid'>xs</span>
</pre>
<p>We lift <code>length</code> in the logic, as a <a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2014/02/11/the-advantage-of-measures.lhs/">measure</a>.</p>
<p>We can now tell Liquid Haskell that when proving termination
on recursive functions with a list argument <code>xs</code>, it should
check whether the <code>length xs</code> is decreasing.</p>
<pre><span class=hs-linenum>94: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>data</span> <span class='hs-conid'>List</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>length</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>N</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>C</span> <span class='hs-layout'>{</span><span class='hs-varid'>hd</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-varid'>tl</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<h2 id="reflecting-lists-into-the-logic">Reflecting Lists into the Logic</h2>
<p>To talk about lists in the logic, we use the annotation</p>
<pre><span class=hs-linenum>104: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--exact-data-cons"</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>which <strong>automatically</strong> derives measures for</p>
<ul>
<li><em>testing</em> if a value has a given data constructor, and</li>
<li><em>extracting</em> the corresponding field’s value.</li>
</ul>
<p>For our example, LH will automatically derive the following
functions in the refinement logic.</p>
<pre><span class=hs-linenum>116: </span><span class='hs-definition'>isN</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>         <span class='hs-comment'>-- Haskell's null</span>
<span class=hs-linenum>117: </span><span class='hs-definition'>isC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>         <span class='hs-comment'>-- Haskell's not . null</span>
<span class=hs-linenum>118: </span>
<span class=hs-linenum>119: </span><span class='hs-definition'>select_C_1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>     <span class='hs-comment'>-- Haskell's head</span>
<span class=hs-linenum>120: </span><span class='hs-definition'>select_C_2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>L</span> <span class='hs-varid'>a</span>   <span class='hs-comment'>-- Haskell's tail</span>
</pre>
<p>A programmer <em>never</em> sees the above operators; they are internally
used by LH to <strong>reflect</strong> Haskell functions into the refinement logic,
as we shall see shortly.</p>
<h2 id="defining-the-monoid-operators">Defining the Monoid Operators</h2>
<p>A structure is a monoid, when it has two operators:</p>
<ul>
<li>the identity element <code>empty</code> and</li>
<li>an associative operator <code>&lt;&gt;</code>.</li>
</ul>
<p>Lets define these two operators for our <code>List</code>.</p>
<ul>
<li>the identity element is the empty list, and</li>
<li>the associative operator <code>&lt;&gt;</code> is list append.</li>
</ul>
<pre><span class=hs-linenum>141: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>empty</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>142: </span><span class='hs-definition'>empty</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>143: </span><a class=annot href="#"><span class=annottext>{VV : (StructuralInduction.List a) | VV == empty
                                     &amp;&amp; VV == StructuralInduction.N}</span><span class='hs-definition'>empty</span></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>N</span>
<span class=hs-linenum>144: </span>
<span class=hs-linenum>145: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>infix</span>   <span class='hs-varop'>&lt;&gt;</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>146: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>147: </span><span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>::</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>148: </span><span class='hs-conid'>N</span>        <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; {VV : (StructuralInduction.List a) | VV == &lt;&gt; x1 x2
                                                                                                           &amp;&amp; VV == (if is_N x1 then x2 else StructuralInduction.C (select_C_1 x1) (&lt;&gt; (select_C_2 x1) x2))}</span><span class='hs-varop'>&lt;&gt;</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>ys</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ys</span>
<span class=hs-linenum>149: </span><span class='hs-layout'>(</span><span class='hs-conid'>C</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{VV : (StructuralInduction.List a) | VV == &lt;&gt; xs ys
                                     &amp;&amp; VV == (if is_N xs then ys else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) ys))
                                     &amp;&amp; VV == &lt;&gt; xs ys}</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
</pre>
<p>LiquidHaskell automatically checked that the recursive <code>(&lt;&gt;)</code>
is terminating, by checking that the <code>length</code> of its first
argument is decreasing. Since both the above operators are
provably terminating, LH lets us reflect them into logic.</p>
<p>As with our <a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2016/09/18/refinement-reflection.lhs/">previous</a>
<code>fibonacci</code> example, reflection of a function
into logic, means strengthening the result type
of the function with its implementation.</p>
<p>Thus, the <strong>automatically</strong> derived, strengthened
types for <code>empty</code> and <code>(&lt;&gt;)</code> will be</p>
<pre><span class=hs-linenum>166: </span><span class='hs-definition'>empty</span>   <span class='hs-keyglyph'>::</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-varid'>empty</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-conid'>N</span> <span class='hs-layout'>}</span>
<span class=hs-linenum>167: </span>
<span class=hs-linenum>168: </span><span class='hs-layout'>(</span><span class='hs-varop'>&lt;&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ys</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>169: </span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-varid'>xs</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ys</span> <span class='hs-varop'>&amp;&amp;</span>
<span class=hs-linenum>170: </span>                    <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isN</span> <span class='hs-varid'>xs</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>ys</span> <span class='hs-keyword'>else</span>
<span class=hs-linenum>171: </span>                         <span class='hs-conid'>C</span> <span class='hs-layout'>(</span><span class='hs-varid'>select_C_1</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>select_C_2</span> <span class='hs-varid'>xs</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
<span class=hs-linenum>172: </span>        <span class='hs-layout'>}</span>
</pre>
<p>In effect, the derived checker and selector functions are used
to translate Haskell to logic. The above is just to <em>explain</em>
how LH reasons about the operators; the programmer never (directly)
reads or writes the operators <code>isN</code> or <code>select_C_1</code> etc.</p>
<h2 id="proving-the-monoid-laws">Proving the Monoid Laws</h2>
<p>Finally, we have set everything up, (actually LiquidHaskell
did most of the work for us) and we are ready to prove the
monoid laws for the <code>List</code>.</p>
<p>First we prove left identity of <code>empty</code>.</p>
<pre><span class=hs-linenum>190: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>leftId</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ empty &lt;&gt; x == x }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>191: </span><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; empty x1 == x1}</span><span class='hs-definition'>leftId</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>x</span></a>
<span class=hs-linenum>192: </span>   <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>empty</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>x</span>
<span class=hs-linenum>193: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-conid'>N</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>x</span>
<span class=hs-linenum>194: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <span class='hs-varid'>x</span>
<span class=hs-linenum>195: </span>   <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>This proof was trivial, because left identity is satisfied
by the way we defined <code>(&lt;&gt;)</code>.</p>
<p>Next, we prove right identity of <code>empty</code>.</p>
<pre><span class=hs-linenum>204: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>rightId</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ x &lt;&gt; empty  == x }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>205: </span><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 empty == x1}</span><span class='hs-definition'>rightId</span></a> <span class='hs-conid'>N</span>
<span class=hs-linenum>206: </span>   <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List (GHC.Prim.Any *))</span><span class='hs-conid'>N</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>empty</span>
<span class=hs-linenum>207: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List (GHC.Prim.Any *)) -&gt; (StructuralInduction.List (GHC.Prim.Any *)) -&gt; (StructuralInduction.List (GHC.Prim.Any *))</span><span class='hs-varop'>==.</span></a> <span class='hs-conid'>N</span>
<span class=hs-linenum>208: </span>   <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>209: </span>
<span class=hs-linenum>210: </span><span class='hs-definition'>rightId</span> <span class='hs-layout'>(</span><span class='hs-conid'>C</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span>
<span class=hs-linenum>211: </span>   <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>empty</span>
<span class=hs-linenum>212: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>empty</span><span class='hs-layout'>)</span>
<span class=hs-linenum>213: </span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; () -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span>        <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>{VV : () | &lt;&gt; xs empty == xs}</span><span class='hs-varid'>rightId</span></a> <span class='hs-varid'>xs</span>
<span class=hs-linenum>214: </span>   <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>This proof is more tricky, as it requires <strong>structural induction</strong> which is
encoded in LH proofs simply as <strong>recursion</strong>. LH ensures that the inductive
hypothesis is appropriately applied by checking that the recursive proof is
total and terminating. In the <code>rightId</code> case, for termination, Liquid Haskell
checked that <code>length xs &lt; length (C x xs)</code>.</p>
<p>It turns out that we can prove lots of properties about lists using structural
induction, encoded in Haskell as</p>
<ul>
<li>case splitting,</li>
<li>recursive calls, and</li>
<li>rewriting,</li>
</ul>
<p>To see a last example, lets prove the associativity of <code>(&lt;&gt;)</code>.</p>
<pre><span class=hs-linenum>233: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>associativity</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>z</span><span class='hs-conop'>:</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>234: </span>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ x &lt;&gt; (y &lt;&gt; z) == (x &lt;&gt; y) &lt;&gt; z }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>235: </span><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; x3:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 (&lt;&gt; x2 x3) == &lt;&gt; (&lt;&gt; x1 x2) x3}</span><span class='hs-definition'>associativity</span></a> <span class='hs-conid'>N</span> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>y</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>z</span></a>
<span class=hs-linenum>236: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-conid'>N</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span><span class='hs-layout'>)</span>
<span class=hs-linenum>237: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>238: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-conid'>N</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>239: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>240: </span>
<span class=hs-linenum>241: </span><span class='hs-definition'>associativity</span> <span class='hs-layout'>(</span><span class='hs-conid'>C</span> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varid'>y</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>242: </span>  <span class='hs-keyglyph'>=</span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span><span class='hs-layout'>)</span>
<span class=hs-linenum>243: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class='hs-varid'>y</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<span class=hs-linenum>244: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; () -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; xs y
                                    &amp;&amp; v == (if is_N xs then y else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) y))
                                    &amp;&amp; v == &lt;&gt; xs y}</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span><span class='hs-layout'>)</span> <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; x3:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 (&lt;&gt; x2 x3) == &lt;&gt; (&lt;&gt; x1 x2) x3}</span><span class='hs-varid'>associativity</span></a> <span class='hs-varid'>xs</span> <span class='hs-varid'>y</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>245: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>{v : (StructuralInduction.List a) | v == &lt;&gt; xs y
                                    &amp;&amp; v == (if is_N xs then y else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) y))
                                    &amp;&amp; v == &lt;&gt; xs y}</span><span class='hs-varid'>xs</span></a> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>246: </span>  <a class=annot href="#"><span class=annottext>(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>(StructuralInduction.List a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class='hs-conid'>C</span></a> <span class='hs-varid'>x</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>z</span>
<span class=hs-linenum>247: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>The above proof of associativity reifies the paper and pencil
proof by structural induction.</p>
<p>With that, we can safely conclude that our user defined list
is a monoid!</p>
<h2 id="conclusion">Conclusion</h2>
<p>We saw how Refinement Reflection can be used to</p>
<ul>
<li>specify properties of <code>ADTs</code>,</li>
<li>naturally encode structural inductive proofs of these properties, and</li>
<li>have these proofs machine checked by Liquid Haskell.</li>
</ul>
<p>Why is this useful? Because the theorems we prove refer to your Haskell
functions! Thus you (or in the future, the compiler) can use properties like
monoid or monad laws to optimize your Haskell code. In the future, we will
present examples of code optimizations using monoid laws. Stay tuned!</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2016/10/06/structural-induction.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2016/10/06/structural-induction.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>
<entry>
    <title>Haskell as a Theorem Prover</title>
    <link href="https://ucsd-progsys.github.io/liquidhaskell-blog/2016/09/18/refinement-reflection.lhs" />
    <id>https://ucsd-progsys.github.io/liquidhaskell-blog/2016/09/18/refinement-reflection.lhs</id>
    <published>true</published>
    <updated>2016-09-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt="" title="">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Haskell as a Theorem Prover</h1>
                    
                    <span class="meta">
		    
			Posted by Niki Vazou
		    
			Sep 18, 2016
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged &#39;reflection&#39;." href="/tags/reflection.html">reflection</a>
              
            </div>

            <br>
			            <p>We’ve taught LiquidHaskell a new trick that we call ``Refinement Reflection’’
which lets us turn Haskell into a theorem prover capable of proving arbitrary
properties of code. The key idea is to <strong>reflect</strong> the code of the function into
its <strong>output type</strong>, which lets us then reason about the function at the
(refinement) type level. Lets see how to use refinement types to express a
theorem, for example that fibonacci is a monotonically increasing function,
then write plain Haskell code to reify a paper-and-pencil-style proof
for that theorem, that can be machine checked by LiquidHaskell.</p>
<!-- more -->
<p><br>
<br>
<br></p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<img src="https://eyesofodysseus.files.wordpress.com/2013/06/full-moon-over-ocean-reflection.jpg"
       alt="Reflection" width="300">
</div>
</div>
<div class="hidden">
<pre><span class=hs-linenum>38: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--higherorder"</span>     <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>39: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--totality"</span>        <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>40: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>RefinementReflection</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum>41: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Language</span><span class='hs-varop'>.</span><span class='hs-conid'>Haskell</span><span class='hs-varop'>.</span><span class='hs-conid'>Liquid</span><span class='hs-varop'>.</span><span class='hs-conid'>ProofCombinators</span>
<span class=hs-linenum>42: </span>
<span class=hs-linenum>43: </span><span class='hs-definition'>fib</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>44: </span><span class='hs-definition'>propPlusComm</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>45: </span><span class='hs-definition'>propOnePlueOne</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>46: </span><span class='hs-definition'>fibTwo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>47: </span><span class='hs-definition'>fibCongruence</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
<span class=hs-linenum>48: </span><span class='hs-definition'>fibUp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>49: </span><span class='hs-definition'>fibTwoPretty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>50: </span><span class='hs-definition'>fibThree</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>()</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>51: </span><span class='hs-definition'>fMono</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<span class=hs-linenum>52: </span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span><span class='hs-layout'>)</span>
<span class=hs-linenum>53: </span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>54: </span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> 
<span class=hs-linenum>55: </span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>56: </span><span class='hs-definition'>fibMono</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>57: </span>
</pre>
</div>
<h2 id="shallow-vs.-deep-specifications">Shallow vs. Deep Specifications</h2>
<p>Up to now, we have been using Liquid Haskell to specify and verify “shallow”
specifications that abstractly describe the behavior of functions. For example,
below, we specify and verify that <code>fib</code>restricted to natural numbers, always
terminates returning a natural number.</p>
<pre><span class=hs-linenum>70: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fib</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nat</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>71: </span><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-definition'>fib</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>i</span></a> <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>0</span>    <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> 
<span class=hs-linenum>72: </span>      <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>1</span>    <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> 
<span class=hs-linenum>73: </span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>2</span><span class='hs-layout'>)</span>
</pre>
<p>In this post we present how refinement reflection is used to verify
“deep” specifications that use the exact definition of Haskell functions.
For example, we will prove that the Haskell <code>fib</code> function is increasing.</p>
<h2 id="propositions">Propositions</h2>
<p>To begin with, we import <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/Language/Haskell/Liquid/ProofCombinators.hs">ProofCombinators</a>, a (Liquid) Haskell
library that defines and manipulates logical proofs.</p>
<pre><span class=hs-linenum>89: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Language</span><span class='hs-varop'>.</span><span class='hs-conid'>Haskell</span><span class='hs-varop'>.</span><span class='hs-conid'>Liquid</span><span class='hs-varop'>.</span><span class='hs-conid'>ProofCombinators</span>
</pre>
<p>A <code>Proof</code> is a data type that carries no run time information</p>
<pre><span class=hs-linenum>95: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Proof</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
</pre>
<p>but can be refined with desired logical propositions.
For example, the following type states that <code>1 + 1 == 2</code></p>
<pre><span class=hs-linenum>102: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>OnePlusOne</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span> <span class='hs-conid'>Proof</span> <span class='hs-keyglyph'>|</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span> <span class='hs-varop'>==</span> <span class='hs-num'>2</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>Since the <code>v</code> and <code>Proof</code> are irrelevant, we may as well abbreviate
the above to</p>
<pre><span class=hs-linenum>109: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>OnePlusOne'</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>{</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span> <span class='hs-varop'>==</span> <span class='hs-num'>2</span> <span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>As another example, the following function type declares
that <em>for each</em> <code>x</code> and <code>y</code> the plus operator commutes.</p>
<pre><span class=hs-linenum>117: </span><span class='hs-keyword'>{-@</span> <span class='hs-keyword'>type</span> <span class='hs-conid'>PlusComm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>x</span> <span class='hs-varop'>+</span> <span class='hs-varid'>y</span> <span class='hs-varop'>==</span> <span class='hs-varid'>y</span> <span class='hs-varop'>+</span> <span class='hs-varid'>x</span><span class='hs-layout'>}</span> <span class='hs-keyword'>@-}</span> 
</pre>
<h2 id="trivial-proofs">Trivial Proofs</h2>
<p>We prove the above theorems using Haskell programs.
The <code>ProofCombinators</code> module defines the <code>trivial</code> proof</p>
<pre><span class=hs-linenum>129: </span><span class='hs-definition'>trivial</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Proof</span> 
<span class=hs-linenum>130: </span><span class='hs-definition'>trivial</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
</pre>
<p>and the “casting” operator <code>(***)</code> that makes proof terms look
nice:</p>
<pre><span class=hs-linenum>137: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>QED</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>138: </span>
<span class=hs-linenum>139: </span><span class='hs-layout'>(</span><span class='hs-varop'>***</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>QED</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span>
<span class=hs-linenum>140: </span><span class='hs-keyword'>_</span> <span class='hs-varop'>***</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>()</span>
</pre>
<p>Using the underlying SMT’s knowledge on linear arithmetic,
we can trivially prove the above propositions.</p>
<pre><span class=hs-linenum>147: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>propOnePlueOne</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OnePlusOne</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>148: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | 1 + 1 == 2}</span><span class='hs-definition'>propOnePlueOne</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}</span><span class='hs-varid'>trivial</span></a> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span> 
<span class=hs-linenum>149: </span>
<span class=hs-linenum>150: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>propPlusComm</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PlusComm</span> <span class='hs-keyword'>@-}</span> 
<span class=hs-linenum>151: </span><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {VV : () | x1 + x2 == x2 + x1}</span><span class='hs-definition'>propPlusComm</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}</span><span class='hs-varid'>trivial</span></a> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span> 
</pre>
<p>We saw how we use SMT’s knowledge on linear arithmetic
to trivially prove arithmetic properties. But how can
we prove ``deep’’ properties on Haskell’s functions?</p>
<h2 id="refinement-reflection">Refinement Reflection</h2>
<p>Refinement Reflection allows deep specification and
verification by reflecting the code implementing a Haskell
function into the function’s output refinement type.</p>
<p>Refinement Reflection proceeds in 3 steps: definition, reflection, and application.
Consider reflecting the definition of <code>fib</code> into the logic</p>
<pre><span class=hs-linenum>171: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>reflect</span> <span class='hs-varid'>fib</span> <span class='hs-keyword'>@-}</span>
</pre>
<p>then the following three reflection steps will occur.</p>
<h2 id="step-1-definition">Step 1: Definition</h2>
<p>Reflection of the Haskell function <code>fib</code> defines in logic
an <em>uninterpreted</em> function <code>fib</code> that satisfies the congruence axiom.</p>
<p>In the logic the function <code>fib</code> is defined.</p>
<pre><span class=hs-linenum>185: </span><span class='hs-definition'>fib</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> 
</pre>
<p>SMT only knows that <code>fib</code> satisfies the congruence axiom.</p>
<pre><span class=hs-linenum>191: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibCongruence</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>j</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{i == j =&gt; fib i == fib j}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>192: </span><a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 == x2 =&gt; fib x1 == fib x2}</span><span class='hs-definition'>fibCongruence</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}</span><span class='hs-varid'>trivial</span></a> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span> 
</pre>
<p>Other than congruence, SMT knowns nothing for the function <code>fib</code>,
until reflection happens!</p>
<h2 id="step-2-reflection">Step 2: Reflection</h2>
<p>As a second step, Liquid Haskell connects the Haskell function <code>fib</code>
with the homonymous logical function,
by reflecting the implementation of <code>fib</code> in its result type.</p>
<p>The result type of <code>fib</code> is automatically strengthened to the following.</p>
<pre><span class=hs-linenum>210: </span><span class='hs-definition'>fib</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>==</span> <span class='hs-varid'>fib</span> <span class='hs-varid'>i</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fibP</span> <span class='hs-varid'>i</span> <span class='hs-layout'>}</span>
</pre>
<p>That is, the result satisfies the <code>fibP</code> predicate
exactly reflecting the implementation of <code>fib</code>.</p>
<pre><span class=hs-linenum>217: </span><span class='hs-definition'>fibP</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>i</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span> <span class='hs-keyword'>then</span> <span class='hs-num'>0</span> <span class='hs-keyword'>else</span>
<span class=hs-linenum>218: </span>         <span class='hs-keyword'>if</span> <span class='hs-varid'>i</span> <span class='hs-varop'>==</span> <span class='hs-num'>1</span> <span class='hs-keyword'>then</span> <span class='hs-num'>1</span> <span class='hs-keyword'>else</span>
<span class=hs-linenum>219: </span>         <span class='hs-varid'>fin</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varop'>+</span> <span class='hs-varid'>fib</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-comment'>-</span><span class='hs-num'>2</span><span class='hs-layout'>)</span>
</pre>
<h2 id="step-3-application">Step 3: Application</h2>
<p>With the reflected refinement type,
each application of <code>fib</code> automatically unfolds the definition of <code>fib</code>
once.
As an example, applying <code>fib</code> to <code>0</code>, <code>1</code>, and <code>2</code> allows us to prove that <code>fib 2 == 1</code>:</p>
<pre><span class=hs-linenum>231: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibTwo</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ fib 2 == 1 }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>232: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | fib 2 == 1}</span><span class='hs-definition'>fibTwo</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Int] | null v &lt;=&gt; false}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>0</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>2</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>Though valid, the above <code>fibTwo</code> proof is not pretty!</p>
<h2 id="structuring-proofs">Structuring Proofs</h2>
<p>To make our proofs look nice, we use combinators from
the <code>ProofCombinators</code> library, which exports a family
of operators <code>(*.)</code> where <code>*</code> comes from the theory of
linear arithmetic and the refinement type of <code>x *. y</code></p>
<ul>
<li><strong>requires</strong> that <code>x *. y</code> holds and</li>
<li><strong>ensures</strong> that the returned value is equal to <code>x</code>.</li>
</ul>
<p>For example, <code>(==.)</code> and <code>(&lt;=.)</code> are predefined in <code>ProofCombinators</code> as</p>
<pre><span class=hs-linenum>252: </span><span class='hs-layout'>(</span><span class='hs-varop'>==.</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-layout'>{</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span><span class='hs-varop'>==</span><span class='hs-varid'>y</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span><span class='hs-varop'>==</span><span class='hs-varid'>x</span><span class='hs-layout'>}</span>
<span class=hs-linenum>253: </span><span class='hs-definition'>x</span> <span class='hs-varop'>==.</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
<span class=hs-linenum>254: </span>
<span class=hs-linenum>255: </span><span class='hs-layout'>(</span><span class='hs-varop'>&lt;=.</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-layout'>{</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span><span class='hs-varop'>&lt;=</span><span class='hs-varid'>y</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>{</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span><span class='hs-varop'>==</span><span class='hs-varid'>x</span><span class='hs-layout'>}</span>
<span class=hs-linenum>256: </span><span class='hs-definition'>x</span> <span class='hs-varop'>&lt;=.</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span>
</pre>
<p>Using these predefined operators, we construct paper and pencil-like proofs
for the <code>fib</code> function.</p>
<pre><span class=hs-linenum>263: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibTwoPretty</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>{ fib 2 == 1 }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>264: </span><a class=annot href="#"><span class=annottext>{VV : () | fib 2 == 1}</span><span class='hs-definition'>fibTwoPretty</span></a> 
<span class=hs-linenum>265: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>2</span> 
<span class=hs-linenum>266: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>0</span> 
<span class=hs-linenum>267: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<h2 id="because-operator">Because operator</h2>
<p>To allow the reuse of existing proofs, <code>ProofCombinators</code> defines the because
operator <code>(∵)</code></p>
<pre><span class=hs-linenum>279: </span><span class='hs-layout'>(</span><span class='hs-varid'>∵</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Proof</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Proof</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<span class=hs-linenum>280: </span><span class='hs-definition'>f</span> <span class='hs-varid'>∵</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>y</span>
</pre>
<p>For example, <code>fib 3 == 2</code> holds because <code>fib 2 == 1</code>:</p>
<pre><span class=hs-linenum>286: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibThree</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{ fib 3 == 2 }</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>287: </span><a class=annot href="#"><span class=annottext>() -&gt; {VV : () | fib 3 == 2}</span><span class='hs-definition'>fibThree</span></a> <span class='hs-keyword'>_</span> 
<span class=hs-linenum>288: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>3</span> 
<span class=hs-linenum>289: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>2</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span>
<span class=hs-linenum>290: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a>     <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span>      <span class='hs-varid'>∵</span> <span class='hs-varid'>fibTwoPretty</span>
<span class=hs-linenum>291: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <span class='hs-num'>2</span> 
<span class=hs-linenum>292: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<h2 id="proofs-by-induction-i.e.-recursion">Proofs by Induction (i.e. Recursion)</h2>
<p>Next, combining the above operators we specify and prove that
<code>fib</code> is increasing, that is for each natural number <code>i</code>,
<code>fib i &lt;= fib (i+1)</code>.</p>
<p>We specify the theorem as a refinement type for <code>fubUp</code>
and use Haskell code to persuade Liquid Haskell that
the theorem holds.</p>
<pre><span class=hs-linenum>309: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibUp</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{fib i &lt;= fib (i+1)}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>310: </span><a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}</span><span class='hs-definition'>fibUp</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>i</span></a>
<span class=hs-linenum>311: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>0</span>
<span class=hs-linenum>312: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>0</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span>
<span class=hs-linenum>313: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>314: </span>
<span class=hs-linenum>315: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Bool</span><span class='hs-varid'>i</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-num'>1</span>
<span class=hs-linenum>316: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>0</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-num'>2</span>
<span class=hs-linenum>317: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>318: </span>
<span class=hs-linenum>319: </span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<span class=hs-linenum>320: </span>  <span class='hs-keyglyph'>=</span>   <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-varid'>i</span>
<span class=hs-linenum>321: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>322: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-varid'>i</span>     <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>2</span><span class='hs-layout'>)</span> <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}</span><span class='hs-varid'>fibUp</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>323: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-varid'>i</span>     <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}</span><span class='hs-varid'>fibUp</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>2</span><span class='hs-layout'>)</span>
<span class=hs-linenum>324: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;=.</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>i</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>325: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>The proof proceeds <em>by induction on</em> <code>i</code>.</p>
<ul>
<li><p>The base cases <code>i == 0</code> and <code>i == 1</code> are represented
as Haskell’s case splitting.</p></li>
<li><p>The inductive hypothesis is represented by recursive calls
on smaller inputs.</p></li>
</ul>
<p>Finally, the SMT solves arithmetic reasoning to conclude the proof.</p>
<h2 id="higher-order-theorems">Higher Order Theorems</h2>
<p>Refinement Reflection can be used to express and verify higher order theorems!
For example, <code>fMono</code> specifies that each locally increasing function is monotonic!</p>
<pre><span class=hs-linenum>345: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fMono</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>f</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<span class=hs-linenum>346: </span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>fUp</span><span class='hs-conop'>:</span><span class='hs-layout'>(</span><span class='hs-varid'>z</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{f z &lt;= f (z+1)}</span><span class='hs-layout'>)</span>
<span class=hs-linenum>347: </span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span>
<span class=hs-linenum>348: </span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>y</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Nat|x &lt; y}</span>
<span class=hs-linenum>349: </span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{f x &lt;= f y}</span> <span class='hs-varop'>/</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span> 
<span class=hs-linenum>350: </span>  <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>351: </span><a class=annot href="#"><span class=annottext>x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0
                                                                                                                                                                                          &amp;&amp; x5 &lt; v} -&gt; {VV : () | x1 x5 &lt;= x1 x6}</span><span class='hs-definition'>fMono</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | f x1 &lt;= f (x1 + 1)}</span><span class='hs-varid'>thm</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; x &lt; v}</span><span class='hs-varid'>y</span></a>  
<span class=hs-linenum>352: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class='hs-varop'>==</span></a> <span class='hs-varid'>y</span>
<span class=hs-linenum>353: </span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-varid'>y</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class='hs-varop'>==.</span></a> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>354: </span>         <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&gt;.</span></a> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-varid'>x</span>       <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}</span><span class='hs-varid'>thm</span></a> <span class='hs-varid'>x</span>
<span class=hs-linenum>355: </span>        <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
<span class=hs-linenum>356: </span>
<span class=hs-linenum>357: </span>  <span class='hs-keyglyph'>|</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>x</span></a> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class='hs-varop'>+</span></a> <span class='hs-num'>1</span> <a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 &lt; x2}</span><span class='hs-varop'>&lt;</span></a> <span class='hs-varid'>y</span>
<span class=hs-linenum>358: </span>  <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-varid'>x</span>
<span class=hs-linenum>359: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;.</span></a>  <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>         <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0
                                                                                                                                                                                          &amp;&amp; x5 &lt; v} -&gt; {VV : () | x1 x5 &lt;= x1 x6}</span><span class='hs-varid'>fMono</span></a> <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}</span><span class='hs-varid'>thm</span></a> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>360: </span>  <a class=annot href="#"><span class=annottext>GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class='hs-varop'>&lt;.</span></a>  <a class=annot href="#"><span class=annottext>{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class='hs-varid'>f</span></a> <span class='hs-varid'>y</span>             <span class='hs-varid'>∵</span> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}</span><span class='hs-varid'>thm</span></a> <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>y</span></a><a class=annot href="#"><span class=annottext>x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class='hs-comment'>-</span></a><span class='hs-num'>1</span><span class='hs-layout'>)</span>
<span class=hs-linenum>361: </span>  <span class='hs-varop'>***</span> <span class='hs-conid'>QED</span>
</pre>
<p>Again, the recursive implementation of <code>fMono</code> depicts the paper and pencil
proof of <code>fMono</code> by induction on the decreasing argument <code>/ [y]</code>.</p>
<p>Since <code>fib</code> is proven to be locally increasing by <code>fUp</code>, we use <code>fMono</code>
to prove that <code>fib</code> is monotonic.</p>
<pre><span class=hs-linenum>371: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>fibMono</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>n</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-keyword'>{Nat | n &lt; m }</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{fib n &lt;= fib m}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>372: </span><a class=annot href="#"><span class=annottext>x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:{v : GHC.Types.Int | v &gt;= 0
                                                           &amp;&amp; x1 &lt; v} -&gt; {VV : () | fib x1 &lt;= fib x2}</span><span class='hs-definition'>fibMono</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0
                                                                                                                                                                                              &amp;&amp; x5 &lt; v} -&gt; {v : () | x1 x5 &lt;= x1 x6} | v == RefinementReflection.fMono}</span><span class='hs-varid'>fMono</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class='hs-varid'>fib</span></a> <a class=annot href="#"><span class=annottext>{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | fib x1 &lt;= fib (x1 + 1)} | v == RefinementReflection.fibUp}</span><span class='hs-varid'>fibUp</span></a>
</pre>
<h2 id="conclusion">Conclusion</h2>
<p>We saw how refinement reflection turns Haskell
into a theorem prover by reflecting the code
implementing a Haskell function into the
function’s output refinement type.</p>
<p>Refinement Types are used to express theorems,
Haskell code is used to prove such theorems
expressing paper pencil proofs, and Liquid Haskell
verifies the validity of the proofs!</p>
<p>Proving <code>fib</code> monotonic is great, but this is Haskell!
Wouldn’t it be nice to prove theorems about inductive data types
and higher order functions? Like fusions and folds?
Or program equivalence on run-time optimizations like map-reduce?</p>
<p>Stay tuned!</p>
<p>Even better, if you happen you be in Nara for ICFP’16,
come to my <a href="http://cufp.org/2016/t6-niki-vazou-liquid-haskell-intro.html">CUFP tutorial</a> for more!</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2016/09/18/refinement-reflection.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2016/09/18/refinement-reflection.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>
]]></summary>
</entry>

</feed>
