<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    
    <head>
   <!-- Global Site Tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-106786912-1">
    </script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments)};
      gtag('js', new Date());
      gtag('config', 'UA-106786912-1');
    </script>


     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
 <!--
      loads the http over https ssl -
      welcome to my website!

	this theme is based off the Ice & Fire theme created by Lucas Gatsas
      https://www.twitter.com/LucasGatsas
      www.lucasgatsas.ch - switzerland.
  -->


<!-- Microsoft Internet Explorer documentMode compatMode setting IE Modus -->
<script type="text/javascript">
var IE = null;
if (window.navigator.appName == "Microsoft Internet Explorer") {
  if (document.documentMode) {

    IE = document.documentMode;
    } else {

        IE = 5;
          if (document.compatMode) {
      if (document.compatMode == "CSS1Compat")
      IE = 11;
      }
    }
  }
</script>

    <meta charset="utf-8">
    <!-- X-UA -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <link rel="author" title="Ranjit Jhala" href="http://ranjitjhala.github.io" />

    <meta name="google" content="notranslate" />
    <!-- Viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- index ROBOTS follow -->
    <meta name="robots" content="index, follow" />
    <!-- Site Desciption -->
    <meta name="description" content="LiquidHaskell Blog">
    <!-- Site Desciption -->
    <meta name="keywords" content="haskell, refinement types, liquid types, formal methods, type systems">
    <!-- Favicon -->
    <link rel="shortcut icon" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" type="image/x-icon" />
    <!-- Blog Title -->
    <title>LiquidHaskell</title>

    <!--     <title>{% if page.title %}{{ page.title }} - {{ site.title }}{% else %}{{ site.title }}{% endif %}</title>
-->
    <!-- Property Metas -->
    <meta property="og:image" content="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ix.png" />
    <meta property="og:title" content="LiquidHaskell Blog" />
    <meta property="og:site_name" content="LiquidHaskell Blog" />
    <!-- Canonical -->
    <link rel="canonical" href="{{ page.url | replace:'index.html','' | prepend: site.baseUrl | prepend: site.url }}">
    <!-- StyleSheet -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/bootstrap.min.css">
    <!-- <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/spaceg.stylesheets.css"> -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/ronacher.css" type="text/css">

    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/syntax.css">
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/liquid-light.css">

    <!-- Fonts
    <link href='https://fonts.googleapis.com/css?family=Merriweather:400,300,300italic,400italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900,400italic,700italic,900italic' rel='stylesheet' type='text/css'>
    -->

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>
	#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:url("/static/img/preloader.gif"); /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	ul, ol {margin-top: 0;margin-bottom: 10px;}
	.navbar-inverse {background-color: #FFF;border-color: #FFFFFF;}
</style>
<!--link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/prettify.css"-->
<style>
  /* HEADER IMAGE */
  header.intro-header {background: #6f5499;background: no-repeat center center;background-attachment: scroll;-webkit-background-size: cover;-moz-background-size: cover;background-size: cover;-o-background-size: cover;}

	/* Preloader */#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:; /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	li {list-style: none;}
            body.modal-open
            {overflow: hidden;padding-right: 0px;
        }
	article li {list-style: inherit;}
	article .figure {text-align: center}
    </style>
    <!-- end Loading front stylesheet here -->

    <link href="atom.xml" type="application/atom+xml" rel="alternate" title="LiquidHaskell-Blog ATOM Feed" />
    </head>

    <body>
	    
	<!-- 	
        <div id="preloader">
	    <div id="status">
	    </div>
	</div>  
	-->
	<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ucsd-progsys.github.io/liquidhaskell-blog" id="blog-title-left-top">LiquidHaskell</a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- <li class="dropdown">
                    <a href="#portfolioModal2" data-toggle="modal"><i class="fa fa-random" id="icon-top"></i></a>
                <ul class="dropdown-menu"></ul>
                </li>-->
                
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/blog.html">Blog</a></li>
                <li><a href="http://goto.ucsd.edu:8090/index.html#?demo=MonoidList.hs" target="_blank">Demo</a></li>
                <li><a href="http://ucsd-progsys.github.io/lh-workshop" target="_blank">Tutorial</a></li>
                <li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial" target="_blank">Book</a></li>
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html" target="_blank">About</a></li>
                <li><a href="http://www.github.com/ucsd-progsys/liquidhaskell" target="_blank"><i class="fa fa-twitter"></i>Download</a></li>
                <!--
                <li><a href="https://www.twitter.com/ranjitjhala" id="roundbutton" target="_blank"><i class="fa fa-twitter"></i>RanjitJhala</a></li>
                -->
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<!-- Portfolio Modals -->
    <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" class="img-responsive img-centered" alt title>
                            <p class="font-style-inline-small">
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow me</a>. <br>
                                <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                                <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>
                            </p>
                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<!-- Menu Modals Add New Sa.21.Feb.2015 03:22:25 -->
    <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <p class="font-style-inline-small">
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow</a>. <br>
                        <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                        <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>  <br>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/index.html">Home</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html">About</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/blog.html">Blog</a></li>
                    <li><a href="http://goto.ucsd.edu:8090/index.html#?demo=MonoidList.hs" target="_blank">Demo</a></li>
                    <li><a href="http://ucsd-progsys.github.io/lh-workshop" target="_blank">Tutorial</a></li>
                    <li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial" target="_blank">Book</a></li>
                    <li><a href="http://www.github.com/ucsd-progsys/liquidhaskell" target="_blank"><i class="fa fa-twitter"></i>Download</a></li>
                            </p>

                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


        <div id="content">
            <!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt title>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Refinement Reflection on ADTs</h1>
                    
                    <span class="meta">
		    
			Posted by Niki Vazou
		    
			Oct  6, 2016
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged 'reflection'." href="../../../../tags/reflection.html">reflection</a>, <a title="All pages tagged 'induction'." href="../../../../tags/induction.html">induction</a>, <a title="All pages tagged 'measures'." href="../../../../tags/measures.html">measures</a>
              
            </div>

            <br>
			            <h2 id="lists-are-monoids">Lists are Monoids</h2>
<p><a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2016/09/18/refinement-reflection.lhs/">Previously</a> we saw how Refinement Reflection
can be used to write Haskell functions that prove theorems about
other Haskell functions. Today, we will see how Refinement Reflection
works on <strong>recursive data types</strong>.
As an example, we will prove that <strong>lists are monoids</strong> (under nil and append).</p>
<p>Lets see how to express <strong>the monoid laws</strong> as liquid types, and then prove
the laws by writing plain Haskell functions that are checked by LiquidHaskell.</p>
<!-- more -->
<p><br></p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<p style="text-align:center">
<img class="center-block" src="http://www.aaronartprints.org/images/Paintings/4597.jpg" alt="Recursion" width="300">
<br>
Recursive Paper and Pencil Proofs.
“Drawing Hands” by Escher.
<br>
</p>
</div>
</div>
<div class="hidden">
<pre><span class="hs-linenum">46: </span><span class="hs-keyword">{-@</span> <span class="hs-conid">LIQUID</span> <span class="hs-str">"--higherorder"</span>     <span class="hs-keyword">@-}</span>
<span class="hs-linenum">47: </span><span class="hs-keyword">{-@</span> <span class="hs-conid">LIQUID</span> <span class="hs-str">"--totality"</span>        <span class="hs-keyword">@-}</span>
<span class="hs-linenum">48: </span><span class="hs-keyword">module</span> <span class="hs-conid">StructuralInduction</span> <span class="hs-keyword">where</span>
<span class="hs-linenum">49: </span><span class="hs-keyword">import</span> <span class="hs-conid">Language</span><span class="hs-varop">.</span><span class="hs-conid">Haskell</span><span class="hs-varop">.</span><span class="hs-conid">Liquid</span><span class="hs-varop">.</span><span class="hs-conid">ProofCombinators</span>
<span class="hs-linenum">50: </span>
<span class="hs-linenum">51: </span><span class="hs-keyword">import</span> <span class="hs-conid">Prelude</span> <span class="hs-varid">hiding</span> <span class="hs-layout">(</span><span class="hs-varid">length</span><span class="hs-layout">)</span>
<span class="hs-linenum">52: </span>
<span class="hs-linenum">53: </span><span class="hs-definition">length</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span>
<span class="hs-linenum">54: </span><span class="hs-definition">leftId</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Proof</span>
<span class="hs-linenum">55: </span><span class="hs-definition">rightId</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Proof</span>
<span class="hs-linenum">56: </span><span class="hs-definition">associativity</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Proof</span>
</pre>
</div>
<h2 id="lists">Lists</h2>
<p>First, lets define the <code>List a</code> data type</p>
<pre><span class="hs-linenum">66: </span><span class="hs-keyword">data</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">N</span> <span class="hs-keyglyph">|</span> <span class="hs-conid">C</span> <span class="hs-varid">a</span> <span class="hs-layout">(</span><span class="hs-conid">List</span> <span class="hs-varid">a</span><span class="hs-layout">)</span>
</pre>
<h2 id="induction-on-lists">Induction on Lists</h2>
<p>As we will see, <em>proofs</em> by structural induction will correspond to
<em>programs</em> that perform recursion on lists. To keep things legit,
we must verify that those programs are total and terminating.</p>
<p>To that end, lets define a <code>length</code> function that
computes the natural number that is the size of a
list.</p>
<pre><span class="hs-linenum">81: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">measure</span> <span class="hs-varid">length</span>               <span class="hs-keyword">@-}</span>
<span class="hs-linenum">82: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">length</span>      <span class="hs-keyglyph">::</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Nat</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">83: </span><a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                        &amp;&amp; v == length x1}</span><span class="hs-definition">length</span></a> <span class="hs-conid">N</span>        <span class="hs-keyglyph">=</span> <span class="hs-num">0</span>
<span class="hs-linenum">84: </span><span class="hs-definition">length</span> <span class="hs-layout">(</span><span class="hs-conid">C</span> <span class="hs-varid">x</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v == (1 : int)}</span><span class="hs-num">1</span></a> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a> <a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; v == length xs
                     &amp;&amp; v == length xs}</span><span class="hs-varid">length</span></a> <span class="hs-varid">xs</span>
</pre>
<p>We lift <code>length</code> in the logic, as a <a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2014/02/11/the-advantage-of-measures.lhs/">measure</a>.</p>
<p>We can now tell Liquid Haskell that when proving termination
on recursive functions with a list argument <code>xs</code>, it should
check whether the <code>length xs</code> is decreasing.</p>
<pre><span class="hs-linenum">94: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">data</span> <span class="hs-conid">List</span> <span class="hs-keyglyph">[</span><span class="hs-varid">length</span><span class="hs-keyglyph">]</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">N</span> <span class="hs-keyglyph">|</span> <span class="hs-conid">C</span> <span class="hs-layout">{</span><span class="hs-varid">hd</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span><span class="hs-layout">,</span> <span class="hs-varid">tl</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span><span class="hs-layout">}</span> <span class="hs-keyword">@-}</span>
</pre>
<h2 id="reflecting-lists-into-the-logic">Reflecting Lists into the Logic</h2>
<p>To talk about lists in the logic, we use the annotation</p>
<pre><span class="hs-linenum">104: </span><span class="hs-keyword">{-@</span> <span class="hs-conid">LIQUID</span> <span class="hs-str">"--exact-data-cons"</span> <span class="hs-keyword">@-}</span>
</pre>
<p>which <strong>automatically</strong> derives measures for</p>
<ul>
<li><em>testing</em> if a value has a given data constructor, and</li>
<li><em>extracting</em> the corresponding field’s value.</li>
</ul>
<p>For our example, LH will automatically derive the following
functions in the refinement logic.</p>
<pre><span class="hs-linenum">116: </span><span class="hs-definition">isN</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">L</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span>         <span class="hs-comment">-- Haskell's null</span>
<span class="hs-linenum">117: </span><span class="hs-definition">isC</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">L</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span>         <span class="hs-comment">-- Haskell's not . null</span>
<span class="hs-linenum">118: </span>
<span class="hs-linenum">119: </span><span class="hs-definition">select_C_1</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">L</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>     <span class="hs-comment">-- Haskell's head</span>
<span class="hs-linenum">120: </span><span class="hs-definition">select_C_2</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">L</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">L</span> <span class="hs-varid">a</span>   <span class="hs-comment">-- Haskell's tail</span>
</pre>
<p>A programmer <em>never</em> sees the above operators; they are internally
used by LH to <strong>reflect</strong> Haskell functions into the refinement logic,
as we shall see shortly.</p>
<h2 id="defining-the-monoid-operators">Defining the Monoid Operators</h2>
<p>A structure is a monoid, when it has two operators:</p>
<ul>
<li>the identity element <code>empty</code> and</li>
<li>an associative operator <code>&lt;&gt;</code>.</li>
</ul>
<p>Lets define these two operators for our <code>List</code>.</p>
<ul>
<li>the identity element is the empty list, and</li>
<li>the associative operator <code>&lt;&gt;</code> is list append.</li>
</ul>
<pre><span class="hs-linenum">141: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">reflect</span> <span class="hs-varid">empty</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">142: </span><span class="hs-definition">empty</span>  <span class="hs-keyglyph">::</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span>
<span class="hs-linenum">143: </span><a class="annot" href="#"><span class="annottext">{VV : (StructuralInduction.List a) | VV == empty
                                     &amp;&amp; VV == StructuralInduction.N}</span><span class="hs-definition">empty</span></a>  <span class="hs-keyglyph">=</span> <span class="hs-conid">N</span>
<span class="hs-linenum">144: </span>
<span class="hs-linenum">145: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">infix</span>   <span class="hs-varop">&lt;&gt;</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">146: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">reflect</span> <span class="hs-varop">&lt;&gt;</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">147: </span><span class="hs-layout">(</span><span class="hs-varop">&lt;&gt;</span><span class="hs-layout">)</span>           <span class="hs-keyglyph">::</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span>
<span class="hs-linenum">148: </span><span class="hs-conid">N</span>        <a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; {VV : (StructuralInduction.List a) | VV == &lt;&gt; x1 x2
                                                                                                           &amp;&amp; VV == (if is_N x1 then x2 else StructuralInduction.C (select_C_1 x1) (&lt;&gt; (select_C_2 x1) x2))}</span><span class="hs-varop">&lt;&gt;</span></a> <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-varid">ys</span></a> <span class="hs-keyglyph">=</span> <span class="hs-varid">ys</span>
<span class="hs-linenum">149: </span><span class="hs-layout">(</span><span class="hs-conid">C</span> <span class="hs-varid">x</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">ys</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class="hs-conid">C</span></a> <span class="hs-varid">x</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : (StructuralInduction.List a) | VV == &lt;&gt; xs ys
                                     &amp;&amp; VV == (if is_N xs then ys else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) ys))
                                     &amp;&amp; VV == &lt;&gt; xs ys}</span><span class="hs-varid">xs</span></a> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">ys</span><span class="hs-layout">)</span>
</pre>
<p>LiquidHaskell automatically checked that the recursive <code>(&lt;&gt;)</code>
is terminating, by checking that the <code>length</code> of its first
argument is decreasing. Since both the above operators are
provably terminating, LH lets us reflect them into logic.</p>
<p>As with our <a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2016/09/18/refinement-reflection.lhs/">previous</a>
<code>fibonacci</code> example, reflection of a function
into logic, means strengthening the result type
of the function with its implementation.</p>
<p>Thus, the <strong>automatically</strong> derived, strengthened
types for <code>empty</code> and <code>(&lt;&gt;)</code> will be</p>
<pre><span class="hs-linenum">166: </span><span class="hs-definition">empty</span>   <span class="hs-keyglyph">::</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-varop">==</span> <span class="hs-varid">empty</span> <span class="hs-varop">&amp;&amp;</span> <span class="hs-varid">v</span> <span class="hs-varop">==</span> <span class="hs-conid">N</span> <span class="hs-layout">}</span>
<span class="hs-linenum">167: </span>
<span class="hs-linenum">168: </span><span class="hs-layout">(</span><span class="hs-varop">&lt;&gt;</span><span class="hs-layout">)</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">ys</span><span class="hs-conop">:</span><span class="hs-conid">List</span> <span class="hs-varid">a</span>
<span class="hs-linenum">169: </span>     <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-varop">==</span> <span class="hs-varid">xs</span> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">ys</span> <span class="hs-varop">&amp;&amp;</span>
<span class="hs-linenum">170: </span>                    <span class="hs-varid">v</span> <span class="hs-varop">==</span> <span class="hs-keyword">if</span> <span class="hs-varid">isN</span> <span class="hs-varid">xs</span> <span class="hs-keyword">then</span> <span class="hs-varid">ys</span> <span class="hs-keyword">else</span>
<span class="hs-linenum">171: </span>                         <span class="hs-conid">C</span> <span class="hs-layout">(</span><span class="hs-varid">select_C_1</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">select_C_2</span> <span class="hs-varid">xs</span> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">ys</span><span class="hs-layout">)</span>
<span class="hs-linenum">172: </span>        <span class="hs-layout">}</span>
</pre>
<p>In effect, the derived checker and selector functions are used
to translate Haskell to logic. The above is just to <em>explain</em>
how LH reasons about the operators; the programmer never (directly)
reads or writes the operators <code>isN</code> or <code>select_C_1</code> etc.</p>
<h2 id="proving-the-monoid-laws">Proving the Monoid Laws</h2>
<p>Finally, we have set everything up, (actually LiquidHaskell
did most of the work for us) and we are ready to prove the
monoid laws for the <code>List</code>.</p>
<p>First we prove left identity of <code>empty</code>.</p>
<pre><span class="hs-linenum">190: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">leftId</span>  <span class="hs-keyglyph">::</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{ empty &lt;&gt; x == x }</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">191: </span><a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; empty x1 == x1}</span><span class="hs-definition">leftId</span></a> <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-varid">x</span></a>
<span class="hs-linenum">192: </span>   <span class="hs-keyglyph">=</span>   <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-varid">empty</span></a> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">x</span>
<span class="hs-linenum">193: </span>   <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class="hs-varop">==.</span></a> <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-conid">N</span></a> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">x</span>
<span class="hs-linenum">194: </span>   <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class="hs-varop">==.</span></a> <span class="hs-varid">x</span>
<span class="hs-linenum">195: </span>   <span class="hs-varop">***</span> <span class="hs-conid">QED</span>
</pre>
<p>This proof was trivial, because left identity is satisfied
by the way we defined <code>(&lt;&gt;)</code>.</p>
<p>Next, we prove right identity of <code>empty</code>.</p>
<pre><span class="hs-linenum">204: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">rightId</span>  <span class="hs-keyglyph">::</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{ x &lt;&gt; empty  == x }</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">205: </span><a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 empty == x1}</span><span class="hs-definition">rightId</span></a> <span class="hs-conid">N</span>
<span class="hs-linenum">206: </span>   <span class="hs-keyglyph">=</span>   <a class="annot" href="#"><span class="annottext">(StructuralInduction.List (GHC.Prim.Any *))</span><span class="hs-conid">N</span></a> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">empty</span>
<span class="hs-linenum">207: </span>   <a class="annot" href="#"><span class="annottext">(StructuralInduction.List (GHC.Prim.Any *)) -&gt; (StructuralInduction.List (GHC.Prim.Any *)) -&gt; (StructuralInduction.List (GHC.Prim.Any *))</span><span class="hs-varop">==.</span></a> <span class="hs-conid">N</span>
<span class="hs-linenum">208: </span>   <span class="hs-varop">***</span> <span class="hs-conid">QED</span>
<span class="hs-linenum">209: </span>
<span class="hs-linenum">210: </span><span class="hs-definition">rightId</span> <span class="hs-layout">(</span><span class="hs-conid">C</span> <span class="hs-varid">x</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span>
<span class="hs-linenum">211: </span>   <span class="hs-keyglyph">=</span>   <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class="hs-conid">C</span></a> <span class="hs-varid">x</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">empty</span>
<span class="hs-linenum">212: </span>   <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class="hs-varop">==.</span></a> <a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class="hs-conid">C</span></a> <span class="hs-varid">x</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-varid">xs</span></a> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">empty</span><span class="hs-layout">)</span>
<span class="hs-linenum">213: </span>   <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; () -&gt; (StructuralInduction.List a)</span><span class="hs-varop">==.</span></a> <a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class="hs-conid">C</span></a> <span class="hs-varid">x</span> <span class="hs-varid">xs</span>        <span class="hs-varid">∵</span> <a class="annot" href="#"><span class="annottext">{VV : () | &lt;&gt; xs empty == xs}</span><span class="hs-varid">rightId</span></a> <span class="hs-varid">xs</span>
<span class="hs-linenum">214: </span>   <span class="hs-varop">***</span> <span class="hs-conid">QED</span>
</pre>
<p>This proof is more tricky, as it requires <strong>structural induction</strong> which is
encoded in LH proofs simply as <strong>recursion</strong>. LH ensures that the inductive
hypothesis is appropriately applied by checking that the recursive proof is
total and terminating. In the <code>rightId</code> case, for termination, Liquid Haskell
checked that <code>length xs &lt; length (C x xs)</code>.</p>
<p>It turns out that we can prove lots of properties about lists using structural
induction, encoded in Haskell as</p>
<ul>
<li>case splitting,</li>
<li>recursive calls, and</li>
<li>rewriting,</li>
</ul>
<p>To see a last example, lets prove the associativity of <code>(&lt;&gt;)</code>.</p>
<pre><span class="hs-linenum">233: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">associativity</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">y</span><span class="hs-conop">:</span><span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">z</span><span class="hs-conop">:</span><span class="hs-conid">List</span> <span class="hs-varid">a</span>
<span class="hs-linenum">234: </span>                  <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{ x &lt;&gt; (y &lt;&gt; z) == (x &lt;&gt; y) &lt;&gt; z }</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">235: </span><a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; x3:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 (&lt;&gt; x2 x3) == &lt;&gt; (&lt;&gt; x1 x2) x3}</span><span class="hs-definition">associativity</span></a> <span class="hs-conid">N</span> <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-varid">y</span></a> <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-varid">z</span></a>
<span class="hs-linenum">236: </span>  <span class="hs-keyglyph">=</span>   <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-conid">N</span></a> <span class="hs-varop">&lt;&gt;</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class="hs-varid">y</span></a> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">z</span><span class="hs-layout">)</span>
<span class="hs-linenum">237: </span>  <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class="hs-varop">==.</span></a> <a class="annot" href="#"><span class="annottext">{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class="hs-varid">y</span></a> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">z</span>
<span class="hs-linenum">238: </span>  <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class="hs-varop">==.</span></a> <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-conid">N</span></a> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">y</span><span class="hs-layout">)</span> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">z</span>
<span class="hs-linenum">239: </span>  <span class="hs-varop">***</span> <span class="hs-conid">QED</span>
<span class="hs-linenum">240: </span>
<span class="hs-linenum">241: </span><span class="hs-definition">associativity</span> <span class="hs-layout">(</span><span class="hs-conid">C</span> <span class="hs-varid">x</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-varid">y</span> <span class="hs-varid">z</span>
<span class="hs-linenum">242: </span>  <span class="hs-keyglyph">=</span>  <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class="hs-conid">C</span></a> <span class="hs-varid">x</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-varop">&lt;&gt;</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class="hs-varid">y</span></a> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">z</span><span class="hs-layout">)</span>
<span class="hs-linenum">243: </span>  <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class="hs-varop">==.</span></a> <a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class="hs-conid">C</span></a> <span class="hs-varid">x</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-varid">xs</span></a> <span class="hs-varop">&lt;&gt;</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{v : (StructuralInduction.List a) | v == &lt;&gt; y z
                                    &amp;&amp; v == (if is_N y then z else StructuralInduction.C (select_C_1 y) (&lt;&gt; (select_C_2 y) z))
                                    &amp;&amp; v == &lt;&gt; y z}</span><span class="hs-varid">y</span></a> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">z</span><span class="hs-layout">)</span><span class="hs-layout">)</span>
<span class="hs-linenum">244: </span>  <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; () -&gt; (StructuralInduction.List a)</span><span class="hs-varop">==.</span></a> <a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class="hs-conid">C</span></a> <span class="hs-varid">x</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">{v : (StructuralInduction.List a) | v == &lt;&gt; xs y
                                    &amp;&amp; v == (if is_N xs then y else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) y))
                                    &amp;&amp; v == &lt;&gt; xs y}</span><span class="hs-varid">xs</span></a> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">y</span><span class="hs-layout">)</span> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">z</span><span class="hs-layout">)</span> <span class="hs-varid">∵</span> <a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; x2:(StructuralInduction.List a) -&gt; x3:(StructuralInduction.List a) -&gt; {VV : () | &lt;&gt; x1 (&lt;&gt; x2 x3) == &lt;&gt; (&lt;&gt; x1 x2) x3}</span><span class="hs-varid">associativity</span></a> <span class="hs-varid">xs</span> <span class="hs-varid">y</span> <span class="hs-varid">z</span>
<span class="hs-linenum">245: </span>  <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class="hs-varop">==.</span></a> <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class="hs-conid">C</span></a> <span class="hs-varid">x</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{v : (StructuralInduction.List a) | v == &lt;&gt; xs y
                                    &amp;&amp; v == (if is_N xs then y else StructuralInduction.C (select_C_1 xs) (&lt;&gt; (select_C_2 xs) y))
                                    &amp;&amp; v == &lt;&gt; xs y}</span><span class="hs-varid">xs</span></a> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">y</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">z</span>
<span class="hs-linenum">246: </span>  <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a) -&gt; (StructuralInduction.List a) -&gt; (StructuralInduction.List a)</span><span class="hs-varop">==.</span></a> <a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">(StructuralInduction.List a)</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">x1:(StructuralInduction.List a) -&gt; {v : (StructuralInduction.List a) | tl v == x1
                                                                       &amp;&amp; hd v == x
                                                                       &amp;&amp; select_C_2 v == x1
                                                                       &amp;&amp; select_C_1 v == x
                                                                       &amp;&amp; (is_C v &lt;=&gt; true)
                                                                       &amp;&amp; (is_N v &lt;=&gt; false)
                                                                       &amp;&amp; length v == 1 + length x1
                                                                       &amp;&amp; v == StructuralInduction.C x x1}</span><span class="hs-conid">C</span></a> <span class="hs-varid">x</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">y</span><span class="hs-layout">)</span> <span class="hs-varop">&lt;&gt;</span> <span class="hs-varid">z</span>
<span class="hs-linenum">247: </span>  <span class="hs-varop">***</span> <span class="hs-conid">QED</span>
</pre>
<p>The above proof of associativity reifies the paper and pencil
proof by structural induction.</p>
<p>With that, we can safely conclude that our user defined list
is a monoid!</p>
<h2 id="conclusion">Conclusion</h2>
<p>We saw how Refinement Reflection can be used to</p>
<ul>
<li>specify properties of <code>ADTs</code>,</li>
<li>naturally encode structural inductive proofs of these properties, and</li>
<li>have these proofs machine checked by Liquid Haskell.</li>
</ul>
<p>Why is this useful? Because the theorems we prove refer to your Haskell
functions! Thus you (or in the future, the compiler) can use properties like
monoid or monad laws to optimize your Haskell code. In the future, we will
present examples of code optimizations using monoid laws. Stay tuned!</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2016/10/06/structural-induction.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2016/10/06/structural-induction.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>

        </div>
        <div id="footer">
        </div>
      <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="https://ucsd-progsys.github.io/liquidhaskell-blog/feed.xml" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/ranjitjhala" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://plus.google.com/u/0/106612421534244742464" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/ucsd-progsys" target="_blank">
                            <span class="fa-stack fa-lg">

                              <i class="fa fa-arrow-circle-o-down"></i>
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
		    
                </ul>
                <p class="copyright text-muted">
                
                  Copyright &copy; Niki Vazou 2016-17.
                
                  Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>,
                  template by <a href="http://lucumr.pocoo.org">Armin Ronacher</a>,
                  suggest improvements <a href="https://github.com/ucsd-progsys/liquidhaskell-blog/">here</a>.
                </p>
            </div>
        </div>
    </div>
</footer>


<!-- jQuery -->
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/jquery.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/spaceg.stylesheets.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/bootstrap.min.js"></script>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/anim.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/scripts.js"></script>

    </body>
</html>
