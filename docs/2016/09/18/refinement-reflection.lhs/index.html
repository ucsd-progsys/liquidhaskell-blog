<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    
    <head>
   <!-- Global Site Tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-106786912-1">
    </script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments)};
      gtag('js', new Date());
      gtag('config', 'UA-106786912-1');
    </script>


     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
 <!--
      loads the http over https ssl -
      welcome to my website!

	this theme is based off the Ice & Fire theme created by Lucas Gatsas
      https://www.twitter.com/LucasGatsas
      www.lucasgatsas.ch - switzerland.
  -->


<!-- Microsoft Internet Explorer documentMode compatMode setting IE Modus -->
<script type="text/javascript">
var IE = null;
if (window.navigator.appName == "Microsoft Internet Explorer") {
  if (document.documentMode) {

    IE = document.documentMode;
    } else {

        IE = 5;
          if (document.compatMode) {
      if (document.compatMode == "CSS1Compat")
      IE = 11;
      }
    }
  }
</script>

    <meta charset="utf-8">
    <!-- X-UA -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <link rel="author" title="Ranjit Jhala" href="http://ranjitjhala.github.io" />

    <meta name="google" content="notranslate" />
    <!-- Viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- index ROBOTS follow -->
    <meta name="robots" content="index, follow" />
    <!-- Site Desciption -->
    <meta name="description" content="LiquidHaskell Blog">
    <!-- Site Desciption -->
    <meta name="keywords" content="haskell, refinement types, liquid types, formal methods, type systems">
    <!-- Favicon -->
    <link rel="shortcut icon" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" type="image/x-icon" />
    <!-- Blog Title -->
    <title>LiquidHaskell</title>

    <!--     <title>{% if page.title %}{{ page.title }} - {{ site.title }}{% else %}{{ site.title }}{% endif %}</title>
-->
    <!-- Property Metas -->
    <meta property="og:image" content="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ix.png" />
    <meta property="og:title" content="LiquidHaskell Blog" />
    <meta property="og:site_name" content="LiquidHaskell Blog" />
    <!-- Canonical -->
    <link rel="canonical" href="{{ page.url | replace:'index.html','' | prepend: site.baseUrl | prepend: site.url }}">
    <!-- StyleSheet -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/bootstrap.min.css">
    <!-- <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/spaceg.stylesheets.css"> -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/ronacher.css" type="text/css">

    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/syntax.css">
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/liquid-light.css">

    <!-- Fonts
    <link href='https://fonts.googleapis.com/css?family=Merriweather:400,300,300italic,400italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900,400italic,700italic,900italic' rel='stylesheet' type='text/css'>
    -->

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>
	#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:url("/static/img/preloader.gif"); /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	ul, ol {margin-top: 0;margin-bottom: 10px;}
	.navbar-inverse {background-color: #FFF;border-color: #FFFFFF;}
</style>
<!--link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/prettify.css"-->
<style>
  /* HEADER IMAGE */
  header.intro-header {background: #6f5499;background: no-repeat center center;background-attachment: scroll;-webkit-background-size: cover;-moz-background-size: cover;background-size: cover;-o-background-size: cover;}

	/* Preloader */#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:; /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	li {list-style: none;}
            body.modal-open
            {overflow: hidden;padding-right: 0px;
        }
	article li {list-style: inherit;}
	article .figure {text-align: center}
    </style>
    <!-- end Loading front stylesheet here -->

    <link href="atom.xml" type="application/atom+xml" rel="alternate" title="LiquidHaskell-Blog ATOM Feed" />
    </head>

    <body>
	    
	<!-- 	
        <div id="preloader">
	    <div id="status">
	    </div>
	</div>  
	-->
	<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ucsd-progsys.github.io/liquidhaskell-blog" id="blog-title-left-top">LiquidHaskell</a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- <li class="dropdown">
                    <a href="#portfolioModal2" data-toggle="modal"><i class="fa fa-random" id="icon-top"></i></a>
                <ul class="dropdown-menu"></ul>
                </li>-->
                
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/blog.html">Blog</a></li>
                <li><a href="http://goto.ucsd.edu:8090/index.html#?demo=RefinementReflection.hs" target="_blank">Demo</a></li>
                <li><a href="http://ucsd-progsys.github.io/lh-workshop" target="_blank">Tutorial</a></li>
                <li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial" target="_blank">Book</a></li>
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html" target="_blank">About</a></li>
                <li><a href="http://www.github.com/ucsd-progsys/liquidhaskell" target="_blank"><i class="fa fa-twitter"></i>Download</a></li>
                <!--
                <li><a href="https://www.twitter.com/ranjitjhala" id="roundbutton" target="_blank"><i class="fa fa-twitter"></i>RanjitJhala</a></li>
                -->
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<!-- Portfolio Modals -->
    <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" class="img-responsive img-centered" alt title>
                            <p class="font-style-inline-small">
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow me</a>. <br>
                                <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                                <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>
                            </p>
                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<!-- Menu Modals Add New Sa.21.Feb.2015 03:22:25 -->
    <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <p class="font-style-inline-small">
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow</a>. <br>
                        <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                        <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>  <br>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/index.html">Home</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html">About</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/blog.html">Blog</a></li>
                    <li><a href="http://goto.ucsd.edu:8090/index.html#?demo=RefinementReflection.hs" target="_blank">Demo</a></li>
                    <li><a href="http://ucsd-progsys.github.io/lh-workshop" target="_blank">Tutorial</a></li>
                    <li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial" target="_blank">Book</a></li>
                    <li><a href="http://www.github.com/ucsd-progsys/liquidhaskell" target="_blank"><i class="fa fa-twitter"></i>Download</a></li>
                            </p>

                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


        <div id="content">
            <!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt title>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Haskell as a Theorem Prover</h1>
                    
                    <span class="meta">
		    
			Posted by Niki Vazou
		    
			Sep 18, 2016
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged 'reflection'." href="../../../../tags/reflection.html">reflection</a>
              
            </div>

            <br>
			            <p>We’ve taught LiquidHaskell a new trick that we call ``Refinement Reflection’’
which lets us turn Haskell into a theorem prover capable of proving arbitrary
properties of code. The key idea is to <strong>reflect</strong> the code of the function into
its <strong>output type</strong>, which lets us then reason about the function at the
(refinement) type level. Lets see how to use refinement types to express a
theorem, for example that fibonacci is a monotonically increasing function,
then write plain Haskell code to reify a paper-and-pencil-style proof
for that theorem, that can be machine checked by LiquidHaskell.</p>
<!-- more -->
<p><br>
<br>
<br></p>
<div class="row-fluid">
<div class="span12 pagination-centered">
<img src="https://eyesofodysseus.files.wordpress.com/2013/06/full-moon-over-ocean-reflection.jpg" alt="Reflection" width="300">
</div>
</div>
<div class="hidden">
<pre><span class="hs-linenum">38: </span><span class="hs-keyword">{-@</span> <span class="hs-conid">LIQUID</span> <span class="hs-str">"--higherorder"</span>     <span class="hs-keyword">@-}</span>
<span class="hs-linenum">39: </span><span class="hs-keyword">{-@</span> <span class="hs-conid">LIQUID</span> <span class="hs-str">"--totality"</span>        <span class="hs-keyword">@-}</span>
<span class="hs-linenum">40: </span><span class="hs-keyword">module</span> <span class="hs-conid">RefinementReflection</span> <span class="hs-keyword">where</span>
<span class="hs-linenum">41: </span><span class="hs-keyword">import</span> <span class="hs-conid">Language</span><span class="hs-varop">.</span><span class="hs-conid">Haskell</span><span class="hs-varop">.</span><span class="hs-conid">Liquid</span><span class="hs-varop">.</span><span class="hs-conid">ProofCombinators</span>
<span class="hs-linenum">42: </span>
<span class="hs-linenum">43: </span><span class="hs-definition">fib</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span>
<span class="hs-linenum">44: </span><span class="hs-definition">propPlusComm</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Proof</span> 
<span class="hs-linenum">45: </span><span class="hs-definition">propOnePlueOne</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">()</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Proof</span> 
<span class="hs-linenum">46: </span><span class="hs-definition">fibTwo</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">()</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Proof</span> 
<span class="hs-linenum">47: </span><span class="hs-definition">fibCongruence</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Proof</span>
<span class="hs-linenum">48: </span><span class="hs-definition">fibUp</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Proof</span> 
<span class="hs-linenum">49: </span><span class="hs-definition">fibTwoPretty</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Proof</span> 
<span class="hs-linenum">50: </span><span class="hs-definition">fibThree</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">()</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Proof</span> 
<span class="hs-linenum">51: </span><span class="hs-definition">fMono</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span><span class="hs-layout">)</span>
<span class="hs-linenum">52: </span>      <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Proof</span><span class="hs-layout">)</span>
<span class="hs-linenum">53: </span>      <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span>
<span class="hs-linenum">54: </span>      <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span> 
<span class="hs-linenum">55: </span>      <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Proof</span> 
<span class="hs-linenum">56: </span><span class="hs-definition">fibMono</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Proof</span> 
<span class="hs-linenum">57: </span>
</pre>
</div>
<h2 id="shallow-vs.-deep-specifications">Shallow vs. Deep Specifications</h2>
<p>Up to now, we have been using Liquid Haskell to specify and verify “shallow”
specifications that abstractly describe the behavior of functions. For example,
below, we specify and verify that <code>fib</code>restricted to natural numbers, always
terminates returning a natural number.</p>
<pre><span class="hs-linenum">70: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">fib</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">i</span><span class="hs-conop">:</span><span class="hs-conid">Nat</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Nat</span> <span class="hs-varop">/</span> <span class="hs-keyglyph">[</span><span class="hs-varid">i</span><span class="hs-keyglyph">]</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">71: </span><a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}</span><span class="hs-definition">fib</span></a> <a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v &gt;= 0}</span><span class="hs-varid">i</span></a> <span class="hs-keyglyph">|</span> <a class="annot" href="#"><span class="annottext">GHC.Types.Bool</span><span class="hs-varid">i</span></a> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class="hs-varop">==</span></a> <span class="hs-num">0</span>    <span class="hs-keyglyph">=</span> <span class="hs-num">0</span> 
<span class="hs-linenum">72: </span>      <span class="hs-keyglyph">|</span> <a class="annot" href="#"><span class="annottext">GHC.Types.Bool</span><span class="hs-varid">i</span></a> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class="hs-varop">==</span></a> <span class="hs-num">1</span>    <span class="hs-keyglyph">=</span> <span class="hs-num">1</span> 
<span class="hs-linenum">73: </span>      <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}</span><span class="hs-varid">fib</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">i</span></a><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class="hs-comment">-</span></a><span class="hs-num">1</span><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a> <a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0}</span><span class="hs-varid">fib</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">i</span></a><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class="hs-comment">-</span></a><span class="hs-num">2</span><span class="hs-layout">)</span>
</pre>
<p>In this post we present how refinement reflection is used to verify
“deep” specifications that use the exact definition of Haskell functions.
For example, we will prove that the Haskell <code>fib</code> function is increasing.</p>
<h2 id="propositions">Propositions</h2>
<p>To begin with, we import <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/Language/Haskell/Liquid/ProofCombinators.hs">ProofCombinators</a>, a (Liquid) Haskell
library that defines and manipulates logical proofs.</p>
<pre><span class="hs-linenum">89: </span><span class="hs-keyword">import</span> <span class="hs-conid">Language</span><span class="hs-varop">.</span><span class="hs-conid">Haskell</span><span class="hs-varop">.</span><span class="hs-conid">Liquid</span><span class="hs-varop">.</span><span class="hs-conid">ProofCombinators</span>
</pre>
<p>A <code>Proof</code> is a data type that carries no run time information</p>
<pre><span class="hs-linenum">95: </span><span class="hs-keyword">type</span> <span class="hs-conid">Proof</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">()</span>
</pre>
<p>but can be refined with desired logical propositions.
For example, the following type states that <code>1 + 1 == 2</code></p>
<pre><span class="hs-linenum">102: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">OnePlusOne</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span> <span class="hs-conid">Proof</span> <span class="hs-keyglyph">|</span> <span class="hs-num">1</span> <span class="hs-varop">+</span> <span class="hs-num">1</span> <span class="hs-varop">==</span> <span class="hs-num">2</span><span class="hs-layout">}</span> <span class="hs-keyword">@-}</span>
</pre>
<p>Since the <code>v</code> and <code>Proof</code> are irrelevant, we may as well abbreviate
the above to</p>
<pre><span class="hs-linenum">109: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">OnePlusOne'</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span> <span class="hs-num">1</span> <span class="hs-varop">+</span> <span class="hs-num">1</span> <span class="hs-varop">==</span> <span class="hs-num">2</span> <span class="hs-layout">}</span> <span class="hs-keyword">@-}</span>
</pre>
<p>As another example, the following function type declares
that <em>for each</em> <code>x</code> and <code>y</code> the plus operator commutes.</p>
<pre><span class="hs-linenum">117: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">PlusComm</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">y</span><span class="hs-conop">:</span><span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">x</span> <span class="hs-varop">+</span> <span class="hs-varid">y</span> <span class="hs-varop">==</span> <span class="hs-varid">y</span> <span class="hs-varop">+</span> <span class="hs-varid">x</span><span class="hs-layout">}</span> <span class="hs-keyword">@-}</span> 
</pre>
<h2 id="trivial-proofs">Trivial Proofs</h2>
<p>We prove the above theorems using Haskell programs.
The <code>ProofCombinators</code> module defines the <code>trivial</code> proof</p>
<pre><span class="hs-linenum">129: </span><span class="hs-definition">trivial</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Proof</span> 
<span class="hs-linenum">130: </span><span class="hs-definition">trivial</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">()</span>
</pre>
<p>and the “casting” operator <code>(***)</code> that makes proof terms look
nice:</p>
<pre><span class="hs-linenum">137: </span><span class="hs-keyword">data</span> <span class="hs-conid">QED</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">QED</span>
<span class="hs-linenum">138: </span>
<span class="hs-linenum">139: </span><span class="hs-layout">(</span><span class="hs-varop">***</span><span class="hs-layout">)</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">QED</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Proof</span>
<span class="hs-linenum">140: </span><span class="hs-keyword">_</span> <span class="hs-varop">***</span> <span class="hs-keyword">_</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">()</span>
</pre>
<p>Using the underlying SMT’s knowledge on linear arithmetic,
we can trivially prove the above propositions.</p>
<pre><span class="hs-linenum">147: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">propOnePlueOne</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">_</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">OnePlusOne</span> <span class="hs-keyword">@-}</span> 
<span class="hs-linenum">148: </span><a class="annot" href="#"><span class="annottext">() -&gt; {VV : () | 1 + 1 == 2}</span><span class="hs-definition">propOnePlueOne</span></a> <span class="hs-keyword">_</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}</span><span class="hs-varid">trivial</span></a> <span class="hs-varop">***</span> <span class="hs-conid">QED</span> 
<span class="hs-linenum">149: </span>
<span class="hs-linenum">150: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">propPlusComm</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">PlusComm</span> <span class="hs-keyword">@-}</span> 
<span class="hs-linenum">151: </span><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {VV : () | x1 + x2 == x2 + x1}</span><span class="hs-definition">propPlusComm</span></a> <span class="hs-keyword">_</span> <span class="hs-keyword">_</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}</span><span class="hs-varid">trivial</span></a> <span class="hs-varop">***</span> <span class="hs-conid">QED</span> 
</pre>
<p>We saw how we use SMT’s knowledge on linear arithmetic
to trivially prove arithmetic properties. But how can
we prove ``deep’’ properties on Haskell’s functions?</p>
<h2 id="refinement-reflection">Refinement Reflection</h2>
<p>Refinement Reflection allows deep specification and
verification by reflecting the code implementing a Haskell
function into the function’s output refinement type.</p>
<p>Refinement Reflection proceeds in 3 steps: definition, reflection, and application.
Consider reflecting the definition of <code>fib</code> into the logic</p>
<pre><span class="hs-linenum">171: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">reflect</span> <span class="hs-varid">fib</span> <span class="hs-keyword">@-}</span>
</pre>
<p>then the following three reflection steps will occur.</p>
<h2 id="step-1-definition">Step 1: Definition</h2>
<p>Reflection of the Haskell function <code>fib</code> defines in logic
an <em>uninterpreted</em> function <code>fib</code> that satisfies the congruence axiom.</p>
<p>In the logic the function <code>fib</code> is defined.</p>
<pre><span class="hs-linenum">185: </span><span class="hs-definition">fib</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span> 
</pre>
<p>SMT only knows that <code>fib</code> satisfies the congruence axiom.</p>
<pre><span class="hs-linenum">191: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">fibCongruence</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">i</span><span class="hs-conop">:</span><span class="hs-conid">Nat</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">j</span><span class="hs-conop">:</span><span class="hs-conid">Nat</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{i == j =&gt; fib i == fib j}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">192: </span><a class="annot" href="#"><span class="annottext">x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 == x2 =&gt; fib x1 == fib x2}</span><span class="hs-definition">fibCongruence</span></a> <span class="hs-keyword">_</span> <span class="hs-keyword">_</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{v : Language.Haskell.Liquid.ProofCombinators.QED | v == Language.Haskell.Liquid.ProofCombinators.QED}</span><span class="hs-varid">trivial</span></a> <span class="hs-varop">***</span> <span class="hs-conid">QED</span> 
</pre>
<p>Other than congruence, SMT knowns nothing for the function <code>fib</code>,
until reflection happens!</p>
<h2 id="step-2-reflection">Step 2: Reflection</h2>
<p>As a second step, Liquid Haskell connects the Haskell function <code>fib</code>
with the homonymous logical function,
by reflecting the implementation of <code>fib</code> in its result type.</p>
<p>The result type of <code>fib</code> is automatically strengthened to the following.</p>
<pre><span class="hs-linenum">210: </span><span class="hs-definition">fib</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">i</span><span class="hs-conop">:</span><span class="hs-conid">Nat</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Nat</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-varop">==</span> <span class="hs-varid">fib</span> <span class="hs-varid">i</span> <span class="hs-varop">&amp;&amp;</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">fibP</span> <span class="hs-varid">i</span> <span class="hs-layout">}</span>
</pre>
<p>That is, the result satisfies the <code>fibP</code> predicate
exactly reflecting the implementation of <code>fib</code>.</p>
<pre><span class="hs-linenum">217: </span><span class="hs-definition">fibP</span> <span class="hs-varid">i</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">if</span> <span class="hs-varid">i</span> <span class="hs-varop">==</span> <span class="hs-num">0</span> <span class="hs-keyword">then</span> <span class="hs-num">0</span> <span class="hs-keyword">else</span>
<span class="hs-linenum">218: </span>         <span class="hs-keyword">if</span> <span class="hs-varid">i</span> <span class="hs-varop">==</span> <span class="hs-num">1</span> <span class="hs-keyword">then</span> <span class="hs-num">1</span> <span class="hs-keyword">else</span>
<span class="hs-linenum">219: </span>         <span class="hs-varid">fin</span> <span class="hs-layout">(</span><span class="hs-varid">i</span><span class="hs-comment">-</span><span class="hs-num">1</span><span class="hs-layout">)</span> <span class="hs-varop">+</span> <span class="hs-varid">fib</span> <span class="hs-layout">(</span><span class="hs-varid">i</span><span class="hs-comment">-</span><span class="hs-num">2</span><span class="hs-layout">)</span>
</pre>
<h2 id="step-3-application">Step 3: Application</h2>
<p>With the reflected refinement type,
each application of <code>fib</code> automatically unfolds the definition of <code>fib</code>
once.
As an example, applying <code>fib</code> to <code>0</code>, <code>1</code>, and <code>2</code> allows us to prove that <code>fib 2 == 1</code>:</p>
<pre><span class="hs-linenum">231: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">fibTwo</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">_</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{ fib 2 == 1 }</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">232: </span><a class="annot" href="#"><span class="annottext">() -&gt; {VV : () | fib 2 == 1}</span><span class="hs-definition">fibTwo</span></a> <span class="hs-keyword">_</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{v : [GHC.Types.Int] | null v &lt;=&gt; false}</span><span class="hs-keyglyph">[</span></a><a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">0</span><span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">1</span><span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">2</span><span class="hs-keyglyph">]</span> <span class="hs-varop">***</span> <span class="hs-conid">QED</span>
</pre>
<p>Though valid, the above <code>fibTwo</code> proof is not pretty!</p>
<h2 id="structuring-proofs">Structuring Proofs</h2>
<p>To make our proofs look nice, we use combinators from
the <code>ProofCombinators</code> library, which exports a family
of operators <code>(*.)</code> where <code>*</code> comes from the theory of
linear arithmetic and the refinement type of <code>x *. y</code></p>
<ul>
<li><strong>requires</strong> that <code>x *. y</code> holds and</li>
<li><strong>ensures</strong> that the returned value is equal to <code>x</code>.</li>
</ul>
<p>For example, <code>(==.)</code> and <code>(&lt;=.)</code> are predefined in <code>ProofCombinators</code> as</p>
<pre><span class="hs-linenum">252: </span><span class="hs-layout">(</span><span class="hs-varop">==.</span><span class="hs-layout">)</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">y</span><span class="hs-conop">:</span><span class="hs-layout">{</span><span class="hs-varid">a</span><span class="hs-keyglyph">|</span> <span class="hs-varid">x</span><span class="hs-varop">==</span><span class="hs-varid">y</span><span class="hs-layout">}</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-varid">a</span><span class="hs-keyglyph">|</span> <span class="hs-varid">v</span><span class="hs-varop">==</span><span class="hs-varid">x</span><span class="hs-layout">}</span>
<span class="hs-linenum">253: </span><span class="hs-definition">x</span> <span class="hs-varop">==.</span> <span class="hs-keyword">_</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">x</span>
<span class="hs-linenum">254: </span>
<span class="hs-linenum">255: </span><span class="hs-layout">(</span><span class="hs-varop">&lt;=.</span><span class="hs-layout">)</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">y</span><span class="hs-conop">:</span><span class="hs-layout">{</span><span class="hs-varid">a</span><span class="hs-keyglyph">|</span> <span class="hs-varid">x</span><span class="hs-varop">&lt;=</span><span class="hs-varid">y</span><span class="hs-layout">}</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-varid">a</span><span class="hs-keyglyph">|</span> <span class="hs-varid">v</span><span class="hs-varop">==</span><span class="hs-varid">x</span><span class="hs-layout">}</span>
<span class="hs-linenum">256: </span><span class="hs-definition">x</span> <span class="hs-varop">&lt;=.</span> <span class="hs-keyword">_</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">x</span>
</pre>
<p>Using these predefined operators, we construct paper and pencil-like proofs
for the <code>fib</code> function.</p>
<pre><span class="hs-linenum">263: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">fibTwoPretty</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">{ fib 2 == 1 }</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">264: </span><a class="annot" href="#"><span class="annottext">{VV : () | fib 2 == 1}</span><span class="hs-definition">fibTwoPretty</span></a> 
<span class="hs-linenum">265: </span>  <span class="hs-keyglyph">=</span>   <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">2</span> 
<span class="hs-linenum">266: </span>  <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class="hs-varop">==.</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">1</span> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">0</span> 
<span class="hs-linenum">267: </span>  <span class="hs-varop">***</span> <span class="hs-conid">QED</span>
</pre>
<h2 id="because-operator">Because operator</h2>
<p>To allow the reuse of existing proofs, <code>ProofCombinators</code> defines the because
operator <code>(∵)</code></p>
<pre><span class="hs-linenum">279: </span><span class="hs-layout">(</span><span class="hs-varid">∵</span><span class="hs-layout">)</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Proof</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Proof</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>
<span class="hs-linenum">280: </span><span class="hs-definition">f</span> <span class="hs-varid">∵</span> <span class="hs-varid">y</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">f</span> <span class="hs-varid">y</span>
</pre>
<p>For example, <code>fib 3 == 2</code> holds because <code>fib 2 == 1</code>:</p>
<pre><span class="hs-linenum">286: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">fibThree</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">_</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{ fib 3 == 2 }</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">287: </span><a class="annot" href="#"><span class="annottext">() -&gt; {VV : () | fib 3 == 2}</span><span class="hs-definition">fibThree</span></a> <span class="hs-keyword">_</span> 
<span class="hs-linenum">288: </span>  <span class="hs-keyglyph">=</span>   <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">3</span> 
<span class="hs-linenum">289: </span>  <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class="hs-varop">==.</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">2</span> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">1</span>
<span class="hs-linenum">290: </span>  <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class="hs-varop">==.</span></a> <a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-num">1</span></a>     <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a> <span class="hs-num">1</span>      <span class="hs-varid">∵</span> <span class="hs-varid">fibTwoPretty</span>
<span class="hs-linenum">291: </span>  <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class="hs-varop">==.</span></a> <span class="hs-num">2</span> 
<span class="hs-linenum">292: </span>  <span class="hs-varop">***</span> <span class="hs-conid">QED</span>
</pre>
<h2 id="proofs-by-induction-i.e.-recursion">Proofs by Induction (i.e. Recursion)</h2>
<p>Next, combining the above operators we specify and prove that
<code>fib</code> is increasing, that is for each natural number <code>i</code>,
<code>fib i &lt;= fib (i+1)</code>.</p>
<p>We specify the theorem as a refinement type for <code>fubUp</code>
and use Haskell code to persuade Liquid Haskell that
the theorem holds.</p>
<pre><span class="hs-linenum">309: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">fibUp</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">i</span><span class="hs-conop">:</span><span class="hs-conid">Nat</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{fib i &lt;= fib (i+1)}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">310: </span><a class="annot" href="#"><span class="annottext">x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}</span><span class="hs-definition">fibUp</span></a> <a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v &gt;= 0}</span><span class="hs-varid">i</span></a>
<span class="hs-linenum">311: </span>  <span class="hs-keyglyph">|</span> <a class="annot" href="#"><span class="annottext">GHC.Types.Bool</span><span class="hs-varid">i</span></a> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class="hs-varop">==</span></a> <span class="hs-num">0</span>
<span class="hs-linenum">312: </span>  <span class="hs-keyglyph">=</span>   <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">0</span> <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class="hs-varop">&lt;.</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">1</span>
<span class="hs-linenum">313: </span>  <span class="hs-varop">***</span> <span class="hs-conid">QED</span>
<span class="hs-linenum">314: </span>
<span class="hs-linenum">315: </span>  <span class="hs-keyglyph">|</span> <a class="annot" href="#"><span class="annottext">GHC.Types.Bool</span><span class="hs-varid">i</span></a> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class="hs-varop">==</span></a> <span class="hs-num">1</span>
<span class="hs-linenum">316: </span>  <span class="hs-keyglyph">=</span>   <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">1</span> <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class="hs-varop">&lt;=.</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">1</span> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">0</span> <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class="hs-varop">&lt;=.</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-num">2</span>
<span class="hs-linenum">317: </span>  <span class="hs-varop">***</span> <span class="hs-conid">QED</span>
<span class="hs-linenum">318: </span>
<span class="hs-linenum">319: </span>  <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span>
<span class="hs-linenum">320: </span>  <span class="hs-keyglyph">=</span>   <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-varid">i</span>
<span class="hs-linenum">321: </span>  <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class="hs-varop">==.</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">i</span></a><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class="hs-comment">-</span></a><span class="hs-num">1</span><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">i</span></a><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class="hs-comment">-</span></a><span class="hs-num">2</span><span class="hs-layout">)</span>
<span class="hs-linenum">322: </span>  <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class="hs-varop">&lt;=.</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-varid">i</span>     <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">i</span></a><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class="hs-comment">-</span></a><span class="hs-num">2</span><span class="hs-layout">)</span> <span class="hs-varid">∵</span> <a class="annot" href="#"><span class="annottext">x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}</span><span class="hs-varid">fibUp</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">i</span></a><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class="hs-comment">-</span></a><span class="hs-num">1</span><span class="hs-layout">)</span>
<span class="hs-linenum">323: </span>  <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class="hs-varop">&lt;=.</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-varid">i</span>     <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">i</span></a><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class="hs-comment">-</span></a><span class="hs-num">1</span><span class="hs-layout">)</span> <span class="hs-varid">∵</span> <a class="annot" href="#"><span class="annottext">x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | fib x1 &lt;= fib (x1 + 1)}</span><span class="hs-varid">fibUp</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">i</span></a><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class="hs-comment">-</span></a><span class="hs-num">2</span><span class="hs-layout">)</span>
<span class="hs-linenum">324: </span>  <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class="hs-varop">&lt;=.</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">i</span></a><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a><span class="hs-num">1</span><span class="hs-layout">)</span>
<span class="hs-linenum">325: </span>  <span class="hs-varop">***</span> <span class="hs-conid">QED</span>
</pre>
<p>The proof proceeds <em>by induction on</em> <code>i</code>.</p>
<ul>
<li><p>The base cases <code>i == 0</code> and <code>i == 1</code> are represented
as Haskell’s case splitting.</p></li>
<li><p>The inductive hypothesis is represented by recursive calls
on smaller inputs.</p></li>
</ul>
<p>Finally, the SMT solves arithmetic reasoning to conclude the proof.</p>
<h2 id="higher-order-theorems">Higher Order Theorems</h2>
<p>Refinement Reflection can be used to express and verify higher order theorems!
For example, <code>fMono</code> specifies that each locally increasing function is monotonic!</p>
<pre><span class="hs-linenum">345: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">fMono</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">f</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Nat</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span><span class="hs-layout">)</span>
<span class="hs-linenum">346: </span>          <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">fUp</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-varid">z</span><span class="hs-conop">:</span><span class="hs-conid">Nat</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{f z &lt;= f (z+1)}</span><span class="hs-layout">)</span>
<span class="hs-linenum">347: </span>          <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-conid">Nat</span>
<span class="hs-linenum">348: </span>          <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">y</span><span class="hs-conop">:</span><span class="hs-keyword">{Nat|x &lt; y}</span>
<span class="hs-linenum">349: </span>          <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{f x &lt;= f y}</span> <span class="hs-varop">/</span> <span class="hs-keyglyph">[</span><span class="hs-varid">y</span><span class="hs-keyglyph">]</span> 
<span class="hs-linenum">350: </span>  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">351: </span><a class="annot" href="#"><span class="annottext">x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0
                                                                                                                                                                                          &amp;&amp; x5 &lt; v} -&gt; {VV : () | x1 x5 &lt;= x1 x6}</span><span class="hs-definition">fMono</span></a> <a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int</span><span class="hs-varid">f</span></a> <a class="annot" href="#"><span class="annottext">x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | f x1 &lt;= f (x1 + 1)}</span><span class="hs-varid">thm</span></a> <a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v &gt;= 0}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v &gt;= 0
                     &amp;&amp; x &lt; v}</span><span class="hs-varid">y</span></a>  
<span class="hs-linenum">352: </span>  <span class="hs-keyglyph">|</span> <a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a> <span class="hs-num">1</span> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == x2}</span><span class="hs-varop">==</span></a> <span class="hs-varid">y</span>
<span class="hs-linenum">353: </span>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class="hs-varid">f</span></a> <span class="hs-varid">y</span> <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; GHC.Types.Int</span><span class="hs-varop">==.</span></a> <a class="annot" href="#"><span class="annottext">{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class="hs-varid">f</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a> <span class="hs-num">1</span><span class="hs-layout">)</span>
<span class="hs-linenum">354: </span>         <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class="hs-varop">&gt;.</span></a> <a class="annot" href="#"><span class="annottext">{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class="hs-varid">f</span></a> <span class="hs-varid">x</span>       <span class="hs-varid">∵</span> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}</span><span class="hs-varid">thm</span></a> <span class="hs-varid">x</span>
<span class="hs-linenum">355: </span>        <span class="hs-varop">***</span> <span class="hs-conid">QED</span>
<span class="hs-linenum">356: </span>
<span class="hs-linenum">357: </span>  <span class="hs-keyglyph">|</span> <a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a> <span class="hs-num">1</span> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 &lt; x2}</span><span class="hs-varop">&lt;</span></a> <span class="hs-varid">y</span>
<span class="hs-linenum">358: </span>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class="hs-varid">f</span></a> <span class="hs-varid">x</span>
<span class="hs-linenum">359: </span>  <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class="hs-varop">&lt;.</span></a>  <a class="annot" href="#"><span class="annottext">{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class="hs-varid">f</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">y</span></a><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class="hs-comment">-</span></a><span class="hs-num">1</span><span class="hs-layout">)</span>         <span class="hs-varid">∵</span> <a class="annot" href="#"><span class="annottext">x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {VV : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0
                                                                                                                                                                                          &amp;&amp; x5 &lt; v} -&gt; {VV : () | x1 x5 &lt;= x1 x6}</span><span class="hs-varid">fMono</span></a> <a class="annot" href="#"><span class="annottext">{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class="hs-varid">f</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}</span><span class="hs-varid">thm</span></a> <span class="hs-varid">x</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">y</span></a><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class="hs-comment">-</span></a><span class="hs-num">1</span><span class="hs-layout">)</span>
<span class="hs-linenum">360: </span>  <a class="annot" href="#"><span class="annottext">GHC.Types.Int -&gt; GHC.Types.Int -&gt; () -&gt; GHC.Types.Int</span><span class="hs-varop">&lt;.</span></a>  <a class="annot" href="#"><span class="annottext">{v : {v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int | v == f}</span><span class="hs-varid">f</span></a> <span class="hs-varid">y</span>             <span class="hs-varid">∵</span> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | f x1 &lt;= f (x1 + 1)} | v == thm}</span><span class="hs-varid">thm</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">GHC.Types.Int</span><span class="hs-varid">y</span></a><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int -&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class="hs-comment">-</span></a><span class="hs-num">1</span><span class="hs-layout">)</span>
<span class="hs-linenum">361: </span>  <span class="hs-varop">***</span> <span class="hs-conid">QED</span>
</pre>
<p>Again, the recursive implementation of <code>fMono</code> depicts the paper and pencil
proof of <code>fMono</code> by induction on the decreasing argument <code>/ [y]</code>.</p>
<p>Since <code>fib</code> is proven to be locally increasing by <code>fUp</code>, we use <code>fMono</code>
to prove that <code>fib</code> is monotonic.</p>
<pre><span class="hs-linenum">371: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">fibMono</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">n</span><span class="hs-conop">:</span><span class="hs-conid">Nat</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">m</span><span class="hs-conop">:</span><span class="hs-keyword">{Nat | n &lt; m }</span>  <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{fib n &lt;= fib m}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">372: </span><a class="annot" href="#"><span class="annottext">x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; x2:{v : GHC.Types.Int | v &gt;= 0
                                                           &amp;&amp; x1 &lt; v} -&gt; {VV : () | fib x1 &lt;= fib x2}</span><span class="hs-definition">fibMono</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{v : x1:({v : GHC.Types.Int | v &gt;= 0} -&gt; GHC.Types.Int) -&gt; (x4:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | x1 x4 &lt;= x1 (x4 + 1)}) -&gt; x5:{v : GHC.Types.Int | v &gt;= 0} -&gt; x6:{v : GHC.Types.Int | v &gt;= 0
                                                                                                                                                                                              &amp;&amp; x5 &lt; v} -&gt; {v : () | x1 x5 &lt;= x1 x6} | v == RefinementReflection.fMono}</span><span class="hs-varid">fMono</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : GHC.Types.Int | v &gt;= 0
                                                             &amp;&amp; v == fib x1
                                                             &amp;&amp; v == (if x1 == 0 then 0 else (if x1 == 1 then 1 else fib (x1 - 1) + fib (x1 - 2)))} | v == fib}</span><span class="hs-varid">fib</span></a> <a class="annot" href="#"><span class="annottext">{v : x1:{v : GHC.Types.Int | v &gt;= 0} -&gt; {v : () | fib x1 &lt;= fib (x1 + 1)} | v == RefinementReflection.fibUp}</span><span class="hs-varid">fibUp</span></a>
</pre>
<h2 id="conclusion">Conclusion</h2>
<p>We saw how refinement reflection turns Haskell
into a theorem prover by reflecting the code
implementing a Haskell function into the
function’s output refinement type.</p>
<p>Refinement Types are used to express theorems,
Haskell code is used to prove such theorems
expressing paper pencil proofs, and Liquid Haskell
verifies the validity of the proofs!</p>
<p>Proving <code>fib</code> monotonic is great, but this is Haskell!
Wouldn’t it be nice to prove theorems about inductive data types
and higher order functions? Like fusions and folds?
Or program equivalence on run-time optimizations like map-reduce?</p>
<p>Stay tuned!</p>
<p>Even better, if you happen you be in Nara for ICFP’16,
come to my <a href="http://cufp.org/2016/t6-niki-vazou-liquid-haskell-intro.html">CUFP tutorial</a> for more!</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2016/09/18/refinement-reflection.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2016/09/18/refinement-reflection.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>

        </div>
        <div id="footer">
        </div>
      <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="https://ucsd-progsys.github.io/liquidhaskell-blog/feed.xml" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/ranjitjhala" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://plus.google.com/u/0/106612421534244742464" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/ucsd-progsys" target="_blank">
                            <span class="fa-stack fa-lg">

                              <i class="fa fa-arrow-circle-o-down"></i>
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
		    
                </ul>
                <p class="copyright text-muted">
                
                  Copyright &copy; Niki Vazou 2016-17.
                
                  Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>,
                  template by <a href="http://lucumr.pocoo.org">Armin Ronacher</a>,
                  suggest improvements <a href="https://github.com/ucsd-progsys/liquidhaskell-blog/">here</a>.
                </p>
            </div>
        </div>
    </div>
</footer>


<!-- jQuery -->
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/jquery.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/spaceg.stylesheets.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/bootstrap.min.js"></script>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/anim.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/scripts.js"></script>

    </body>
</html>
