<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
 <!--
      loads the http over https ssl -
      welcome to my website!

	this theme is based off the Ice & Fire theme created by Lucas Gatsas
      https://www.twitter.com/LucasGatsas
      www.lucasgatsas.ch - switzerland.
  -->


<!-- Microsoft Internet Explorer documentMode compatMode setting IE Modus -->
<script type="text/javascript">
var IE = null;
if (window.navigator.appName == "Microsoft Internet Explorer") {
  if (document.documentMode) {

    IE = document.documentMode;
    } else {

        IE = 5;
          if (document.compatMode) {
      if (document.compatMode == "CSS1Compat")
      IE = 11;
      }
    }
  }
</script>

    <meta charset="utf-8">
    <!-- X-UA -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <link rel="author" title="Ranjit Jhala" href="http://ranjitjhala.github.io" />

    <meta name="google" content="notranslate" />
    <!-- Viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- index ROBOTS follow -->
    <meta name="robots" content="index, follow" />
    <!-- Site Desciption -->
    <meta name="description" content="LiquidHaskell Blog">
    <!-- Site Desciption -->
    <meta name="keywords" content="haskell, refinement types, liquid types, formal methods, type systems">
    <!-- Favicon -->
    <link rel="shortcut icon" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" type="image/x-icon" />
    <!-- Blog Title -->
    <title>LiquidHaskell</title>

    <!--     <title>{% if page.title %}{{ page.title }} - {{ site.title }}{% else %}{{ site.title }}{% endif %}</title>
-->
    <!-- Property Metas -->
    <meta property="og:image" content="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ix.png" />
    <meta property="og:title" content="LiquidHaskell Blog" />
    <meta property="og:site_name" content="LiquidHaskell Blog" />
    <!-- Canonical -->
    <link rel="canonical" href="{{ page.url | replace:'index.html','' | prepend: site.baseUrl | prepend: site.url }}">
    <!-- StyleSheet -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/bootstrap.min.css">
    <!-- <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/spaceg.stylesheets.css"> -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/ronacher.css" type="text/css">

    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/syntax.css">
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/liquid-light.css">

    <!-- Fonts
    <link href='https://fonts.googleapis.com/css?family=Merriweather:400,300,300italic,400italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900,400italic,700italic,900italic' rel='stylesheet' type='text/css'>
    -->

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>
	#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:url("/static/img/preloader.gif"); /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	ul, ol {margin-top: 0;margin-bottom: 10px;}
	.navbar-inverse {background-color: #FFF;border-color: #FFFFFF;}
</style>
<!--link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/prettify.css"-->
<style>
  /* HEADER IMAGE */
  header.intro-header {background: #6f5499;background: no-repeat center center;background-attachment: scroll;-webkit-background-size: cover;-moz-background-size: cover;background-size: cover;-o-background-size: cover;}

	/* Preloader */#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:; /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	li {list-style: none;}
            body.modal-open
            {overflow: hidden;padding-right: 0px;
        }
	article li {list-style: inherit;}
	article .figure {text-align: center}
    </style>
    <!-- end Loading front stylesheet here -->
    </head>

    <body>
	<div id="preloader">
	    <div id="status">

	    </div>

	</div>  
	<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ucsd-progsys.github.io/liquidhaskell-blog" id="blog-title-left-top">LiquidHaskell</a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- <li class="dropdown">
                    <a href="#portfolioModal2" data-toggle="modal"><i class="fa fa-random" id="icon-top"></i></a>
                <ul class="dropdown-menu"></ul>
                </li>-->
                
                <li><a href="http://goto.ucsd.edu:8090/index.html#?demo=SimpleRefinements.hs" target="_blank">Demo</a></li>
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html" target="_blank">About</a></li>
                <li><a href="http://ucsd-progsys.github.io/lh-workshop" target="_blank">Tutorial</a></li>
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/archive.html" target="_blank">Archive</a></li>
                <li><a href="http://www.github.com/ucsd-progsys/liquidhaskell" target="_blank"><i class="fa fa-twitter"></i>Github</a></li>
                <!--
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/archive.html">Archive</a></li>
                <li><a href="https://www.twitter.com/ranjitjhala" id="roundbutton" target="_blank"><i class="fa fa-twitter"></i>RanjitJhala</a></li>
                -->
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<!-- Portfolio Modals -->
    <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" class="img-responsive img-centered" alt title>
                            <p class="font-style-inline-small">
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow me</a>. <br>
                                <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                                <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>
                            </p>
                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<!-- Menu Modals Add New Sa.21.Feb.2015 03:22:25 -->
    <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <p class="font-style-inline-small">
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow</a>. <br>
                        <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                        <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>  <br>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/">Home</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html">About Me</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/archive.html/">Archive</a></li>
                            </p>

                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


        <div id="content">
            <!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt title>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>KMeans Clustering I</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			February 16, 2013
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

			<p><a href="../blog/2013/01/31/safely-catching-a-list-by-its-tail.lhs/">Last time</a> we introduced a new specification mechanism called a <em>measure</em> and demonstrated how to use it to encode the <em>length</em> of a list. We saw how measures could be used to verify that functions like <code>head</code> and <code>tail</code> were only called with non-empty lists (whose length was strictly positive). As several folks pointed out, once LiquidHaskell can reason about lengths, it can do a lot more than just analyze non-emptiness.</p>
<p>Indeed!</p>
<p>Over the next <em>two</em> posts, lets see how one might implement a Kmeans algorithm that clusters <code>n</code>-dimensional points groups, and how LiquidHaskell can help us write and enforce various dimensionality invariants along the way.</p>
<!-- more -->
<!-- For example, XXX pointed out that we can use the type system to give an *upper* bound on the size of a list, e.g. using lists
     upper bounded by a gigantic `MAX_INT` value as a proxy for finite lists. -->
<pre><span class="hs-linenum">33: </span><span class="hs-keyword">module</span> <span class="hs-conid">KMeansHelper</span> <span class="hs-keyword">where</span>
<span class="hs-linenum">34: </span>
<span class="hs-linenum">35: </span><span class="hs-keyword">import</span> <span class="hs-conid">Prelude</span>                          <span class="hs-varid">hiding</span>  <span class="hs-layout">(</span><span class="hs-varid">zipWith</span><span class="hs-layout">)</span>
<span class="hs-linenum">36: </span><span class="hs-keyword">import</span> <span class="hs-conid">Data</span><span class="hs-varop">.</span><span class="hs-conid">List</span>                                <span class="hs-layout">(</span><span class="hs-varid">span</span><span class="hs-layout">)</span>
<span class="hs-linenum">37: </span><span class="hs-keyword">import</span> <span class="hs-conid">Language</span><span class="hs-varop">.</span><span class="hs-conid">Haskell</span><span class="hs-varop">.</span><span class="hs-conid">Liquid</span><span class="hs-varop">.</span><span class="hs-conid">Prelude</span>          <span class="hs-layout">(</span><span class="hs-varid">liquidError</span><span class="hs-layout">)</span>
</pre>
<p>Rather than reinvent the wheel, we will modify an existing implementation of K-Means, <a href="http://hackage.haskell.org/package/kmeans">available on hackage</a>. This may not be the most efficient implementation, but its a nice introduction to the algorithm, and the general invariants will hold for more sophisticated implementations.</p>
<p>We have broken this entry into two convenient, bite-sized chunks:</p>
<ul>
<li><p><strong>Part I</strong> Introduces the basic types and list operations needed by KMeans,</p></li>
<li><p><strong>Part II</strong> Describes how the operations are used in the KMeans implementation.</p></li>
</ul>
<h2 id="the-game-clustering-points">The Game: Clustering Points</h2>
<p>The goal of <a href="http://en.wikipedia.org/wiki/K-means_clustering">K-Means clustering</a> is the following. Given</p>
<ul>
<li><p><strong>Input</strong> : A set of <em>points</em> represented by <em>n-dimensional points</em> in <em>Euclidian</em> space, return</p></li>
<li><p><strong>Output</strong> : A partitioning of the points, into K clusters, in a manner that minimizes sum of distances between each point and its cluster center.</p></li>
</ul>
<h2 id="the-players-types">The Players: Types</h2>
<p>Lets make matters concrete by creating types for the different elements of the algorithm.</p>
<p><strong>1. Fixed-Length Lists</strong> We will represent n-dimensional points using good old Haskell lists, refined with a predicate that describes the dimensionality (i.e. length.) To simplify matters, lets package this into a <em>type alias</em> that denotes lists of a given length <code>N</code>.</p>
<pre><span class="hs-linenum">75: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-conid">N</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span> <span class="hs-conop">:</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varid">len</span> <span class="hs-varid">v</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">N</span><span class="hs-layout">}</span> <span class="hs-keyword">@-}</span>
</pre>
<p><strong>2. Points</strong> Next, we can represent an <code>N</code>-dimensional point as list of <code>Double</code> of length <code>N</code>,</p>
<pre><span class="hs-linenum">81: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">Point</span> <span class="hs-conid">N</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">List</span> <span class="hs-conid">Double</span> <span class="hs-conid">N</span> <span class="hs-keyword">@-}</span>
</pre>
<p><strong>3. Clusters</strong> A cluster is a <strong>non-empty</strong> list of points,</p>
<pre><span class="hs-linenum">87: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">NonEmptyList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span> <span class="hs-conop">:</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varid">len</span> <span class="hs-varid">v</span><span class="hs-layout">)</span> <span class="hs-varop">&gt;</span> <span class="hs-num">0</span><span class="hs-layout">}</span> <span class="hs-keyword">@-}</span>
</pre>
<p><strong>4. Clustering</strong> And finally, a clustering is a list of (non-empty) clusters.</p>
<pre><span class="hs-linenum">93: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">Clustering</span> <span class="hs-varid">a</span>  <span class="hs-keyglyph">=</span> <span class="hs-keyglyph">[</span><span class="hs-layout">(</span><span class="hs-conid">NonEmptyList</span> <span class="hs-varid">a</span><span class="hs-layout">)</span><span class="hs-keyglyph">]</span> <span class="hs-keyword">@-}</span>
</pre>
<p><strong>Notation:</strong> When defining refinement type aliases, we use uppercase variables like <code>N</code> to distinguish value- parameters from the lowercase type parameters like <code>a</code>.</p>
<p><strong>Aside:</strong> By the way, if you are familiar with the <em>index-style</em> length encoding e.g. as found in <a href="http://www.cs.bu.edu/~hwxi/DML/DML.html">DML</a> or <a href="http://code.haskell.org/Agda/examples/Vec.agda">Agda</a>, then its worth noting that despite appearances, our <code>List</code> and <code>Point</code> definitions are <em>not</em> indexed. We’re just using the indices to define abbreviations for the refinement predicates, and we have deliberately chosen the predicates to facilitate SMT based checking and inference.</p>
<h1 id="basic-operations-on-points-and-clusters">Basic Operations on Points and Clusters</h1>
<p>Ok, with the types firmly in hand, let us go forth and develop the KMeans clustering implementation. We will use a variety of small helper functions (of the kind found in <code>Data.List</code>.) Lets get started by looking at them through our newly <em>refined</em> eyes.</p>
<h2 id="grouping">Grouping</h2>
<p>The first such function is <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html#v:groupBy">groupBy</a>. We can refine its type so that instead of just producing a <code>[[a]]</code> we know that it produces a <code>Clustering a</code> which is a list of <em>non-empty</em> lists.</p>
<pre><span class="hs-linenum">124: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">groupBy</span>       <span class="hs-keyglyph">::</span><span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Clustering</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">125: </span><a class="annot" href="#"><span class="annottext">(a -&gt; a -&gt; (GHC.Types.Bool))
-&gt; [a] -&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) &gt;= 0)}</span><span class="hs-definition">groupBy</span></a> <span class="hs-keyword">_</span>  <span class="hs-conid">[]</span>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [{VV : [{VV : a | false}] | false}] | (len([VV]) = 0)}</span><span class="hs-conid">[]</span></a>
<span class="hs-linenum">126: </span><span class="hs-definition">groupBy</span> <span class="hs-varid">eq</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | (VV = x)}</span><span class="hs-varid">x</span></a><a class="annot" href="#"><span class="annottext">y:a -&gt; ys:[a] -&gt; {VV : [a] | (len([VV]) = (1 + len([ys])))}</span><span class="hs-conop">:</span></a><a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = ys),
            (VV = ys),
            (len([VV]) = len([ys])),
            (len([VV]) &gt;= 0)}</span><span class="hs-varid">ys</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">y:{VV : [a] | (len([VV]) &gt; 0)}
-&gt; ys:[{VV : [a] | (len([VV]) &gt; 0)}]
-&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) = (1 + len([ys])))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">(a -&gt; a -&gt; (GHC.Types.Bool))
-&gt; [a] -&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) &gt;= 0)}</span><span class="hs-varid">groupBy</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">eq</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = zs),
            (VV = zs),
            (len([VV]) = len([zs])),
            (len([VV]) &gt;= 0)}</span><span class="hs-varid">zs</span></a>
<span class="hs-linenum">127: </span>  <span class="hs-keyword">where</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = ys),(len([VV]) = len([ys])),(len([VV]) &gt;= 0)}</span><span class="hs-varid">ys</span></a><span class="hs-layout">,</span><a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = zs),(len([VV]) = len([zs])),(len([VV]) &gt;= 0)}</span><span class="hs-varid">zs</span></a><span class="hs-layout">)</span>   <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">(a -&gt; (GHC.Types.Bool)) -&gt; [a] -&gt; ([a] , [a])</span><span class="hs-varid">span</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">a -&gt; a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">eq</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV = x)}</span><span class="hs-varid">x</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}</span><span class="hs-varid">xs</span></a>
</pre>
<p>Intuitively, its pretty easy to see how LiquidHaskell verifies the refined specification:</p>
<ul>
<li>Each element of the output list is of the form <code>x:ys</code></li>
<li>For any list <code>ys</code> the length is non-negative, i.e. <code>(len ys) &gt;= 0</code></li>
<li>The <code>len</code> of <code>x:ys</code> is <code>1 + (len ys)</code>, that is, strictly positive.</li>
</ul>
<h2 id="partitioning">Partitioning</h2>
<p>Next, lets look the function</p>
<pre><span class="hs-linenum">143: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">partition</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">size</span><span class="hs-conop">:</span><span class="hs-conid">PosInt</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Clustering</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">144: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">PosInt</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-varop">&gt;</span> <span class="hs-num">0</span> <span class="hs-layout">}</span> <span class="hs-keyword">@-}</span>
</pre>
<p>which is given a <em>strictly positive</em> integer argument, a list of <code>a</code> values, and returns a <code>Clustering a</code>, that is, a list of non-empty lists. (Each inner list has a length that is less than <code>size</code>, but we shall elide this for simplicity.)</p>
<p>The function is implemented in a straightforward manner, using the library functions <code>take</code> and <code>drop</code></p>
<pre><span class="hs-linenum">156: </span><a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV &gt; 0)}
-&gt; [a] -&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) &gt;= 0)}</span><span class="hs-definition">partition</span></a> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV &gt; 0)}</span><span class="hs-varid">size</span></a> <span class="hs-conid">[]</span>       <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [{VV : [{VV : a | false}] | false}] | (len([VV]) = 0)}</span><span class="hs-conid">[]</span></a>
<span class="hs-linenum">157: </span><span class="hs-definition">partition</span> <span class="hs-varid">size</span> <span class="hs-varid">ys</span><span class="hs-keyglyph">@</span><span class="hs-layout">(</span><span class="hs-keyword">_</span><span class="hs-conop">:</span><span class="hs-keyword">_</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = zs),(len([VV]) &gt;= 0)}</span><span class="hs-varid">zs</span></a> <a class="annot" href="#"><span class="annottext">y:{VV : [a] | (len([VV]) &gt; 0)}
-&gt; ys:[{VV : [a] | (len([VV]) &gt; 0)}]
-&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) = (1 + len([ys])))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV &gt; 0)}
-&gt; [a] -&gt; {VV : [{VV : [a] | (len([VV]) &gt; 0)}] | (len([VV]) &gt;= 0)}</span><span class="hs-varid">partition</span></a> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV = size),(VV &gt; 0)}</span><span class="hs-varid">size</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = zs'),(len([VV]) &gt;= 0)}</span><span class="hs-varid">zs'</span></a>
<span class="hs-linenum">158: </span>  <span class="hs-keyword">where</span>
<span class="hs-linenum">159: </span>    <a class="annot" href="#"><span class="annottext">[a]</span><span class="hs-varid">zs</span></a>                  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">n:{VV : (GHC.Types.Int) | (VV &gt;= 0)}
-&gt; xs:[a]
-&gt; {VV : [a] | (len([VV]) = ((len([xs]) &lt; n) ? len([xs]) : n))}</span><span class="hs-varid">take</span></a> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV = size),(VV &gt; 0)}</span><span class="hs-varid">size</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (len([VV]) &gt;= 0)}</span><span class="hs-varid">ys</span></a>
<span class="hs-linenum">160: </span>    <a class="annot" href="#"><span class="annottext">[a]</span><span class="hs-varid">zs'</span></a>                 <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">n:{VV : (GHC.Types.Int) | (VV &gt;= 0)}
-&gt; xs:[a]
-&gt; {VV : [a] | (len([VV]) = ((len([xs]) &lt; n) ? 0 : (len([xs]) - n)))}</span><span class="hs-varid">drop</span></a> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV = size),(VV &gt; 0)}</span><span class="hs-varid">size</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (len([VV]) &gt;= 0)}</span><span class="hs-varid">ys</span></a>
</pre>
<p>To verify that a valid <code>Clustering</code> is produced, LiquidHaskell needs only verify that the list <code>zs</code> above is non-empty, by suitably connecting the properties of the inputs <code>size</code> and <code>ys</code> with the output.</p>
We have <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/GHC/List.lhs#L334">verified elsewhere</a> that
<pre><span class="hs-linenum">168: </span><span class="hs-definition">take</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">n</span><span class="hs-conop">:</span><span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-varop">&gt;=</span> <span class="hs-num">0</span> <span class="hs-layout">}</span>
<span class="hs-linenum">169: </span>     <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span>
<span class="hs-linenum">170: </span>     <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varid">len</span> <span class="hs-varid">v</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-keyword">if</span> <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-varid">len</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-varop">&lt;</span> <span class="hs-varid">n</span><span class="hs-layout">)</span> <span class="hs-keyword">then</span> <span class="hs-layout">(</span><span class="hs-varid">len</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyword">else</span> <span class="hs-varid">n</span><span class="hs-layout">)</span> <span class="hs-layout">}</span>
</pre>
<p>In other words, the output list’s length is the <em>smaller of</em> the input list’s length and <code>n</code>. Thus, since both <code>size</code> and the <code>(len ys)</code> are greater than <code>1</code>, LiquidHaskell deduces that the list returned by <code>take size ys</code> has a length greater than <code>1</code>, i.e., is non-empty.</p>
<h2 id="zipping">Zipping</h2>
<p>To compute the <em>Euclidean distance</em> between two points, we will use the <code>zipWith</code> function. We must make sure that it is invoked on points with the same number of dimensions, so we write</p>
<pre><span class="hs-linenum">186: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">zipWith</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">c</span><span class="hs-layout">)</span>
<span class="hs-linenum">187: </span>            <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">List</span> <span class="hs-varid">b</span> <span class="hs-layout">(</span><span class="hs-varid">len</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">List</span> <span class="hs-varid">c</span> <span class="hs-layout">(</span><span class="hs-varid">len</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">188: </span><a class="annot" href="#"><span class="annottext">(a -&gt; b -&gt; c)
-&gt; x4:[a]
-&gt; x2:{VV : [b] | (len([VV]) = len([x4])),(len([VV]) &gt;= 0)}
-&gt; {VV : [c] | (len([VV]) = len([x4])),
               (len([VV]) = len([x2])),
               (len([VV]) &gt;= 0)}</span><span class="hs-definition">zipWith</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; b -&gt; c</span><span class="hs-varid">f</span></a> <span class="hs-layout">(</span><span class="hs-varid">a</span><span class="hs-conop">:</span><span class="hs-keyword">as</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">b</span><span class="hs-conop">:</span><span class="hs-varid">bs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">a -&gt; b -&gt; c</span><span class="hs-varid">f</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV = a)}</span><span class="hs-varid">a</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV = b)}</span><span class="hs-varid">b</span></a> <a class="annot" href="#"><span class="annottext">y:a -&gt; ys:[a] -&gt; {VV : [a] | (len([VV]) = (1 + len([ys])))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">(a -&gt; b -&gt; c)
-&gt; x4:[a]
-&gt; x2:{VV : [b] | (len([VV]) = len([x4])),(len([VV]) &gt;= 0)}
-&gt; {VV : [c] | (len([VV]) = len([x4])),
               (len([VV]) = len([x2])),
               (len([VV]) &gt;= 0)}</span><span class="hs-varid">zipWith</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; b -&gt; c</span><span class="hs-varid">f</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = as),(len([VV]) &gt;= 0)}</span><span class="hs-keyword">as</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = bs),(len([VV]) &gt;= 0)}</span><span class="hs-varid">bs</span></a>
<span class="hs-linenum">189: </span><span class="hs-definition">zipWith</span> <span class="hs-keyword">_</span> <span class="hs-conid">[]</span> <span class="hs-conid">[]</span>         <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [{VV : a | false}] | (len([VV]) = 0)}</span><span class="hs-conid">[]</span></a>
</pre>
<p>The type stipulates that the second input list and the output have the same length as the first input. Furthermore, it rules out the case where one list is empty and the other is not, as in that case the former’s length is zero while the latter’s is not.</p>
<h2 id="transposing">Transposing</h2>
<p>The last basic operation that we will require is a means to <em>transpose</em> a <code>Matrix</code>, which itself is just a list of lists:</p>
<pre><span class="hs-linenum">204: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">Matrix</span> <span class="hs-varid">a</span> <span class="hs-conid">Rows</span> <span class="hs-conid">Cols</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">List</span> <span class="hs-layout">(</span><span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-conid">Cols</span><span class="hs-layout">)</span> <span class="hs-conid">Rows</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
</pre>
<p>The <code>transpose</code> operation flips the rows and columns. I confess that I can never really understand matrices without concrete examples, and even then, barely.</p>
So, lets say we have a <em>matrix</em>
<pre><span class="hs-linenum">212: </span><span class="hs-definition">m1</span>  <span class="hs-keyglyph">::</span> <span class="hs-conid">Matrix</span> <span class="hs-conid">Int</span> <span class="hs-num">4</span> <span class="hs-num">2</span>
<span class="hs-linenum">213: </span><span class="hs-definition">m1</span>  <span class="hs-keyglyph">=</span>  <span class="hs-keyglyph">[</span> <span class="hs-keyglyph">[</span><span class="hs-num">1</span><span class="hs-layout">,</span> <span class="hs-num">2</span><span class="hs-keyglyph">]</span>
<span class="hs-linenum">214: </span>       <span class="hs-layout">,</span> <span class="hs-keyglyph">[</span><span class="hs-num">3</span><span class="hs-layout">,</span> <span class="hs-num">4</span><span class="hs-keyglyph">]</span>
<span class="hs-linenum">215: </span>       <span class="hs-layout">,</span> <span class="hs-keyglyph">[</span><span class="hs-num">5</span><span class="hs-layout">,</span> <span class="hs-num">6</span><span class="hs-keyglyph">]</span>
<span class="hs-linenum">216: </span>       <span class="hs-layout">,</span> <span class="hs-keyglyph">[</span><span class="hs-num">7</span><span class="hs-layout">,</span> <span class="hs-num">8</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">]</span>
</pre>
then the matrix <code>m2 = transpose 2 3 m1</code> should be
<pre><span class="hs-linenum">220: </span><span class="hs-definition">m2</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Matrix</span> <span class="hs-conid">Int</span> <span class="hs-num">2</span> <span class="hs-num">4</span>
<span class="hs-linenum">221: </span><span class="hs-definition">m2</span>  <span class="hs-keyglyph">=</span>  <span class="hs-keyglyph">[</span> <span class="hs-keyglyph">[</span><span class="hs-num">1</span><span class="hs-layout">,</span> <span class="hs-num">3</span><span class="hs-layout">,</span> <span class="hs-num">5</span><span class="hs-layout">,</span> <span class="hs-num">7</span><span class="hs-keyglyph">]</span>
<span class="hs-linenum">222: </span>       <span class="hs-layout">,</span> <span class="hs-keyglyph">[</span><span class="hs-num">2</span><span class="hs-layout">,</span> <span class="hs-num">4</span><span class="hs-layout">,</span> <span class="hs-num">6</span><span class="hs-layout">,</span> <span class="hs-num">8</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">]</span>
</pre>
<p>We will use a <code>Matrix a m n</code> to represent a <em>single cluster</em> of <code>m</code> points each of which has <code>n</code> dimensions. We will transpose the matrix to make it easy to <em>sum</em> and <em>average</em> the points along <em>each</em> dimension, in order to compute the <em>center</em> of the cluster.</p>
<p>As you can work out from the above, the code for <code>transpose</code> is quite straightforward: each <em>output row</em> is simply the list of <code>head</code>s of the <em>input rows</em>:</p>
<pre><span class="hs-linenum">235: </span><span class="hs-definition">transpose</span>       <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span><span class="hs-keyglyph">]</span>
<span class="hs-linenum">236: </span>
<span class="hs-linenum">237: </span><a class="annot" href="#"><span class="annottext">c:(GHC.Types.Int)
-&gt; r:{VV : (GHC.Types.Int) | (VV &gt; 0)}
-&gt; {v : [{VV : [a] | (len([VV]) = c)}] | (len([v]) = r)}
-&gt; {v : [{VV : [a] | (len([VV]) = r)}] | (len([v]) = c)}</span><span class="hs-definition">transpose</span></a> <span class="hs-num">0</span> <span class="hs-keyword">_</span> <span class="hs-keyword">_</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [{VV : [{VV : a | false}] | false}] | (len([VV]) = 0)}</span><span class="hs-conid">[]</span></a>
<span class="hs-linenum">238: </span>
<span class="hs-linenum">239: </span><span class="hs-definition">transpose</span> <span class="hs-varid">c</span> <span class="hs-varid">r</span> <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-varid">col00</span> <span class="hs-conop">:</span> <span class="hs-varid">col01s</span><span class="hs-layout">)</span> <span class="hs-conop">:</span> <span class="hs-varid">row1s</span><span class="hs-layout">)</span>
<span class="hs-linenum">240: </span>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = row0'),(len([VV]) &gt;= 0)}</span><span class="hs-varid">row0'</span></a> <a class="annot" href="#"><span class="annottext">y:{VV : [a] | (len([VV]) = len([row0'])),
              (len([VV]) = len([rest])),
              (len([VV]) &gt; 0)}
-&gt; ys:[{VV : [a] | (len([VV]) = len([row0'])),
                   (len([VV]) = len([rest])),
                   (len([VV]) &gt; 0)}]
-&gt; {VV : [{VV : [a] | (len([VV]) = len([row0'])),
                      (len([VV]) = len([rest])),
                      (len([VV]) &gt; 0)}] | (len([VV]) = (1 + len([ys])))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">{v : [[a]] | (v = row1s'),(len([v]) &gt;= 0)}</span><span class="hs-varid">row1s'</span></a>
<span class="hs-linenum">241: </span>    <span class="hs-keyword">where</span>
<span class="hs-linenum">242: </span>      <a class="annot" href="#"><span class="annottext">[a]</span><span class="hs-varid">row0'</span></a>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : a | (VV = col00)}</span><span class="hs-varid">col00</span></a>  <a class="annot" href="#"><span class="annottext">y:a -&gt; ys:[a] -&gt; {VV : [a] | (len([VV]) = (1 + len([ys])))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (len([VV]) = len([row1s])),(len([VV]) &gt;= 0)}</span><span class="hs-keyglyph">[</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV = col0)}</span><span class="hs-varid">col0</span></a>  <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varid">col0</span> <span class="hs-conop">:</span> <span class="hs-keyword">_</span><span class="hs-layout">)</span>  <span class="hs-keyglyph">&lt;-</span> <a class="annot" href="#"><span class="annottext">{VV : [[a]] | (VV = row1s),(len([VV]) &gt;= 0)}</span><span class="hs-varid">row1s</span></a> <span class="hs-keyglyph">]</span>
<span class="hs-linenum">243: </span>      <a class="annot" href="#"><span class="annottext">[{VV : [a] | (len([VV]) = len([col01s])),(len([VV]) &gt;= 0)}]</span><span class="hs-varid">rest</span></a>   <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = col01s),(len([VV]) &gt;= 0)}</span><span class="hs-varid">col01s</span></a> <a class="annot" href="#"><span class="annottext">y:{VV : [a] | (len([VV]) = len([col01s])),(len([VV]) &gt;= 0)}
-&gt; ys:[{VV : [a] | (len([VV]) = len([col01s])),(len([VV]) &gt;= 0)}]
-&gt; {VV : [{VV : [a] | (len([VV]) = len([col01s])),
                      (len([VV]) &gt;= 0)}] | (len([VV]) = (1 + len([ys])))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : [a] | (len([VV]) = len([col01s])),
                   (len([VV]) &gt;= 0)}] | (len([VV]) = len([row1s])),(len([VV]) &gt;= 0)}</span><span class="hs-keyglyph">[</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = col1s),(len([VV]) &gt;= 0)}</span><span class="hs-varid">col1s</span></a> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-keyword">_</span> <span class="hs-conop">:</span> <span class="hs-varid">col1s</span><span class="hs-layout">)</span> <span class="hs-keyglyph">&lt;-</span> <a class="annot" href="#"><span class="annottext">{VV : [[a]] | (VV = row1s),(len([VV]) &gt;= 0)}</span><span class="hs-varid">row1s</span></a> <span class="hs-keyglyph">]</span>
<span class="hs-linenum">244: </span>      <a class="annot" href="#"><span class="annottext">[[a]]</span><span class="hs-varid">row1s'</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">c:(GHC.Types.Int)
-&gt; r:{VV : (GHC.Types.Int) | (VV &gt; 0)}
-&gt; {v : [{VV : [a] | (len([VV]) = c)}] | (len([v]) = r)}
-&gt; {v : [{VV : [a] | (len([VV]) = r)}] | (len([v]) = c)}</span><span class="hs-varid">transpose</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">(GHC.Types.Int)</span><span class="hs-varid">c</span></a><a class="annot" href="#"><span class="annottext">x:(GHC.Types.Int)
-&gt; y:(GHC.Types.Int) -&gt; {VV : (GHC.Types.Int) | (VV = (x - y))}</span><span class="hs-comment">-</span></a><a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV = (1  :  int))}</span><span class="hs-num">1</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV &gt; 0)}</span><span class="hs-varid">r</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : [a] | (len([VV]) = len([col01s])),
                   (len([VV]) &gt;= 0)}] | (VV = rest),(len([VV]) &gt;= 0)}</span><span class="hs-varid">rest</span></a>
</pre>
<p>LiquidHaskell verifies that</p>
<pre><span class="hs-linenum">250: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">transpose</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">c</span><span class="hs-conop">:</span><span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">r</span><span class="hs-conop">:</span><span class="hs-conid">PosInt</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Matrix</span> <span class="hs-varid">a</span> <span class="hs-varid">r</span> <span class="hs-varid">c</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Matrix</span> <span class="hs-varid">a</span> <span class="hs-varid">c</span> <span class="hs-varid">r</span> <span class="hs-keyword">@-}</span>
</pre>
<p>Try to work it out for yourself on pencil and paper.</p>
<p>If you like you can get a hint by seeing how LiquidHaskell figures it out. Lets work <em>backwards</em>.</p>
LiquidHaskell verifies the output type by inferring that
<pre><span class="hs-linenum">259: </span><span class="hs-definition">row0'</span>        <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-varid">r</span><span class="hs-layout">)</span>
<span class="hs-linenum">260: </span><span class="hs-definition">row1s'</span>       <span class="hs-keyglyph">::</span> <span class="hs-conid">List</span> <span class="hs-layout">(</span><span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-varid">r</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">c</span> <span class="hs-comment">-</span> <span class="hs-num">1</span><span class="hs-layout">)</span> <span class="hs-comment">-- i.e. Matrix a (c - 1) r</span>
</pre>
and so, by simply using the <em>measure-refined</em> type for <code>:</code>
<pre><span class="hs-linenum">264: </span><span class="hs-layout">(</span><span class="hs-conop">:</span><span class="hs-layout">)</span>          <span class="hs-keyglyph">::</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span> <span class="hs-varid">v</span> <span class="hs-conop">:</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varid">len</span> <span class="hs-varid">v</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-num">1</span> <span class="hs-varop">+</span> <span class="hs-layout">(</span><span class="hs-varid">len</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-layout">}</span>
</pre>
LiquidHaskell deduces that
<pre><span class="hs-linenum">268: </span><span class="hs-definition">row0</span> <span class="hs-conop">:</span> <span class="hs-varid">rows'</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">List</span> <span class="hs-layout">(</span><span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-varid">r</span><span class="hs-layout">)</span> <span class="hs-varid">c</span>
</pre>
That is,
<pre><span class="hs-linenum">272: </span><span class="hs-definition">row0</span> <span class="hs-conop">:</span> <span class="hs-varid">rows'</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Matrix</span> <span class="hs-varid">a</span> <span class="hs-varid">c</span> <span class="hs-varid">r</span>
</pre>
<p>Excellent! Now, lets work backwards. How does it infer the types of <code>row0'</code> and <code>row1s'</code>?</p>
<p>The first case is easy: <code>row0'</code> is just the list of <em>heads</em> of each row, hence a <code>List a r</code>.</p>
Now, lets look at <code>row1s'</code>. Notice that <code>row1s</code> is the matrix of all <em>except</em> the first row of the input Matrix, and so
<pre><span class="hs-linenum">280: </span><span class="hs-definition">row1s</span>        <span class="hs-keyglyph">::</span> <span class="hs-conid">Matrix</span> <span class="hs-varid">a</span> <span class="hs-layout">(</span><span class="hs-varid">r</span><span class="hs-comment">-</span><span class="hs-num">1</span><span class="hs-layout">)</span> <span class="hs-varid">c</span>
</pre>
and so, as
<pre><span class="hs-linenum">284: </span><span class="hs-definition">col01s</span>       <span class="hs-keyglyph">::</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-layout">(</span><span class="hs-varid">c</span><span class="hs-comment">-</span><span class="hs-num">1</span><span class="hs-layout">)</span>
<span class="hs-linenum">285: </span><span class="hs-definition">col1s</span>        <span class="hs-keyglyph">::</span> <span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-layout">(</span><span class="hs-varid">c</span><span class="hs-comment">-</span><span class="hs-num">1</span><span class="hs-layout">)</span>
</pre>
LiquidHaskell deduces that since <code>rest</code> is the concatenation of <code>r-1</code> tails from <code>row1s</code>
<pre><span class="hs-linenum">289: </span><span class="hs-definition">rest</span>         <span class="hs-keyglyph">=</span> <span class="hs-varid">col01s</span> <span class="hs-conop">:</span> <span class="hs-keyglyph">[</span> <span class="hs-varid">col1s</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-keyword">_</span> <span class="hs-conop">:</span> <span class="hs-varid">col1s</span><span class="hs-layout">)</span> <span class="hs-keyglyph">&lt;-</span> <span class="hs-varid">row1s</span> <span class="hs-keyglyph">]</span>
</pre>
the type of <code>rest</code> is
<pre><span class="hs-linenum">293: </span><span class="hs-definition">rest</span>         <span class="hs-keyglyph">::</span> <span class="hs-conid">List</span> <span class="hs-layout">(</span><span class="hs-conid">List</span> <span class="hs-varid">a</span> <span class="hs-layout">(</span><span class="hs-varid">c</span> <span class="hs-comment">-</span> <span class="hs-num">1</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-varid">r</span>
</pre>
which is just
<pre><span class="hs-linenum">297: </span><span class="hs-definition">rest</span>         <span class="hs-keyglyph">::</span> <span class="hs-conid">Matrix</span> <span class="hs-varid">a</span> <span class="hs-varid">r</span> <span class="hs-layout">(</span><span class="hs-varid">c</span><span class="hs-comment">-</span><span class="hs-num">1</span><span class="hs-layout">)</span>
</pre>
<p>Now, LiquidHaskell deduces <code>row1s' :: Matrix a (c-1) r</code> by inductively plugging in the output type of the recursive call, thereby checking the function’s signature.</p>
<p><em>Whew!</em> That was a fair bit of work, wasn’t it!</p>
<p>Happily, we didn’t have to do <em>any</em> of it. Instead, using the SMT solver, LiquidHaskell ploughs through calculations like that and guarantees to us that <code>transpose</code> indeed flips the dimensions of the inner and outer lists.</p>
<p><strong>Aside: Comprehensions vs. Map</strong> Incidentally, the code above is essentially that of <code>transpose</code> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#transpose">from the Prelude</a> with some extra local variables for exposition. You could instead use a <code>map head</code> and <code>map tail</code> and I encourage you to go ahead and <a href="http://goto.ucsd.edu/~rjhala/liquid/haskell/demo/#?demo=KMeansHelper.hs">see for yourself.</a></p>
<h2 id="intermission">Intermission</h2>
<p>Time for a break – <a href="http://www.youtube.com/watch?v=8uDuls5TyNE">go see a cat video!</a> – or skip it, stretch your legs, and return post-haste for the <a href="../blog/2013/02/17/kmeans-clustering-II.lhs/">next installment</a>, in which we will use the types and functions described above, to develop the clustering algorithm.</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

            </div>
        </div>
    </div>
</article>
<hr>

        </div>
        <div id="footer">
        </div>
      <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="https://ucsd-progsys.github.io/liquidhaskell-blog/feed.xml" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/ranjitjhala" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://plus.google.com/u/0/106612421534244742464" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/ucsd-progsys" target="_blank">
                            <span class="fa-stack fa-lg">

                              <i class="fa fa-arrow-circle-o-down"></i>
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
		    
                </ul>
                <p class="copyright text-muted">
                
                  Copyright &copy; Ranjit Jhala 2016-17.
                
                  Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
                </p>
            </div>
        </div>
    </div>
</footer>


<!-- jQuery -->
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/jquery-3.1.1.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/spaceg.stylesheets.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/bootstrap.min.js"></script>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/scripts.js"></script>

    </body>
</html>
