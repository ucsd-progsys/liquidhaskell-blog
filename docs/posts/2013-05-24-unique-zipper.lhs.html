<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
 <!--
      loads the http over https ssl -
      welcome to my website!

	this theme is based off the Ice & Fire theme created by Lucas Gatsas
      https://www.twitter.com/LucasGatsas
      www.lucasgatsas.ch - switzerland.
  -->


<!-- Microsoft Internet Explorer documentMode compatMode setting IE Modus -->
<script type="text/javascript">
var IE = null;
if (window.navigator.appName == "Microsoft Internet Explorer") {
  if (document.documentMode) {

    IE = document.documentMode;
    } else {

        IE = 5;
          if (document.compatMode) {
      if (document.compatMode == "CSS1Compat")
      IE = 11;
      }
    }
  }
</script>

    <meta charset="utf-8">
    <!-- X-UA -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <link rel="author" title="Ranjit Jhala" href="http://ranjitjhala.github.io" />

    <meta name="google" content="notranslate" />
    <!-- Viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- index ROBOTS follow -->
    <meta name="robots" content="index, follow" />
    <!-- Site Desciption -->
    <meta name="description" content="LiquidHaskell Blog">
    <!-- Site Desciption -->
    <meta name="keywords" content="haskell, refinement types, liquid types, formal methods, type systems">
    <!-- Favicon -->
    <link rel="shortcut icon" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" type="image/x-icon" />
    <!-- Blog Title -->
    <title>LiquidHaskell</title>

    <!--     <title>{% if page.title %}{{ page.title }} - {{ site.title }}{% else %}{{ site.title }}{% endif %}</title>
-->
    <!-- Property Metas -->
    <meta property="og:image" content="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ix.png" />
    <meta property="og:title" content="LiquidHaskell Blog" />
    <meta property="og:site_name" content="LiquidHaskell Blog" />
    <!-- Canonical -->
    <link rel="canonical" href="{{ page.url | replace:'index.html','' | prepend: site.baseUrl | prepend: site.url }}">
    <!-- StyleSheet -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/bootstrap.min.css">
    <!-- <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/spaceg.stylesheets.css"> -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/ronacher.css" type="text/css">

    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/syntax.css">
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/liquid-light.css">

    <!-- Fonts
    <link href='https://fonts.googleapis.com/css?family=Merriweather:400,300,300italic,400italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900,400italic,700italic,900italic' rel='stylesheet' type='text/css'>
    -->

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>
	#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:url("/static/img/preloader.gif"); /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	ul, ol {margin-top: 0;margin-bottom: 10px;}
	.navbar-inverse {background-color: #FFF;border-color: #FFFFFF;}
</style>
<!--link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/prettify.css"-->
<style>
  /* HEADER IMAGE */
  header.intro-header {background: #6f5499;background: no-repeat center center;background-attachment: scroll;-webkit-background-size: cover;-moz-background-size: cover;background-size: cover;-o-background-size: cover;}

	/* Preloader */#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:; /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	li {list-style: none;}
            body.modal-open
            {overflow: hidden;padding-right: 0px;
        }
	article li {list-style: inherit;}
	article .figure {text-align: center}
    </style>
    <!-- end Loading front stylesheet here -->
    </head>

    <body>
	<div id="preloader">
	    <div id="status">

	    </div>

	</div>  
	<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ucsd-progsys.github.io/liquidhaskell-blog" id="blog-title-left-top">LiquidHaskell</a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- <li class="dropdown">
                    <a href="#portfolioModal2" data-toggle="modal"><i class="fa fa-random" id="icon-top"></i></a>
                <ul class="dropdown-menu"></ul>
                </li>-->
                
                <li><a href="http://goto.ucsd.edu:8090/index.html#?demo=SimpleRefinements.hs" target="_blank">Demo</a></li>
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html" target="_blank">About</a></li>
                <li><a href="http://ucsd-progsys.github.io/lh-workshop" target="_blank">Tutorial</a></li>
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/archive.html" target="_blank">Archive</a></li>
                <li><a href="http://www.github.com/ucsd-progsys/liquidhaskell" target="_blank"><i class="fa fa-twitter"></i>Github</a></li>
                <!--
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/archive.html">Archive</a></li>
                <li><a href="https://www.twitter.com/ranjitjhala" id="roundbutton" target="_blank"><i class="fa fa-twitter"></i>RanjitJhala</a></li>
                -->
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<!-- Portfolio Modals -->
    <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" class="img-responsive img-centered" alt title>
                            <p class="font-style-inline-small">
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow me</a>. <br>
                                <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                                <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>
                            </p>
                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<!-- Menu Modals Add New Sa.21.Feb.2015 03:22:25 -->
    <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <p class="font-style-inline-small">
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow</a>. <br>
                        <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                        <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>  <br>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/">Home</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html">About Me</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/archive.html/">Archive</a></li>
                            </p>

                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


        <div id="content">
            <!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt title>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Unique Zippers</h1>
                    
                    <span class="meta">
		    
			Posted by Niki Vazou
		    
			May 24, 2013
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

			<p><strong>The story so far:</strong> <a href="blog/2013/03/26/talking-about-sets.lhs/">Previously</a> we saw how we can use LiquidHaskell to talk about set of values and specifically the <em>set of values</em> in a list.</p>
<p>Often, we want to enforce the invariant that a particular data structure contains <em>no duplicates</em>. For example, we may have a structure that holds a collection of file handles, or other resources, where the presence of duplicates could lead to unpleasant leaks.</p>
<p>In this post, we will see how to use LiquidHaskell to talk about the set of duplicate values in data structures, and hence, let us specify and verify uniqueness, that is, the absence of duplicates.</p>
<!-- more -->
<p>To begin, lets extend our vocabulary to talk about the <em>set of duplicate values</em> in lists. By constraining this set to be empty, we can specify a list without duplicates, or an <strong>unique list</strong>. Once we express uniqueness on lists, it is straightforward to describe uniqueness on other data structures that contain lists. As an example, we will illustrate the properties of a <strong>unique zipper</strong>.</p>
<pre><span class="hs-linenum">37: </span><span class="hs-keyword">module</span> <span class="hs-conid">UniqueZipper</span> <span class="hs-keyword">where</span>
<span class="hs-linenum">38: </span>
<span class="hs-linenum">39: </span><span class="hs-keyword">import</span> <span class="hs-conid">Prelude</span>  <span class="hs-varid">hiding</span> <span class="hs-layout">(</span><span class="hs-varid">reverse</span><span class="hs-layout">,</span> <span class="hs-layout">(</span><span class="hs-varop">++</span><span class="hs-layout">)</span><span class="hs-layout">,</span> <span class="hs-varid">filter</span><span class="hs-layout">)</span>
<span class="hs-linenum">40: </span><span class="hs-keyword">import</span> <span class="hs-conid">Data</span><span class="hs-varop">.</span><span class="hs-conid">Set</span> <span class="hs-varid">hiding</span> <span class="hs-layout">(</span><span class="hs-varid">filter</span><span class="hs-layout">)</span>
</pre>
<h1 id="a-quick-recap">A Quick Recap</h1>
In the previous post we used a measure for the elements of a list, from <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/Data/Set.spec">Data/Set.spec</a>
<pre><span class="hs-linenum">48: </span><span class="hs-definition">measure</span> <span class="hs-varid">listElts</span> <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span>
<span class="hs-linenum">49: </span><span class="hs-definition">listElts</span> <span class="hs-layout">(</span><span class="hs-conid">[]</span><span class="hs-layout">)</span>    <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varop">?</span> <span class="hs-layout">(</span><span class="hs-conid">Set_emp</span> <span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
<span class="hs-linenum">50: </span><span class="hs-definition">listElts</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span>  <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cup</span> <span class="hs-layout">(</span><span class="hs-conid">Set_sng</span> <span class="hs-varid">x</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-layout">}</span>
</pre>
<p>With this measure we defined predicate aliases that describe relations between lists:</p>
<pre><span class="hs-linenum">57: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">EqElts</span>  <span class="hs-conid">X</span> <span class="hs-conid">Y</span>      <span class="hs-keyglyph">=</span> 
<span class="hs-linenum">58: </span>      <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">X</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">Y</span><span class="hs-layout">)</span><span class="hs-layout">)</span>                        <span class="hs-keyword">@-}</span>
<span class="hs-linenum">59: </span>
<span class="hs-linenum">60: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">DisjointElts</span> <span class="hs-conid">X</span> <span class="hs-conid">Y</span> <span class="hs-keyglyph">=</span> 
<span class="hs-linenum">61: </span>      <span class="hs-layout">(</span><span class="hs-conid">Set_emp</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cap</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">X</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">Y</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">)</span>        <span class="hs-keyword">@-}</span>
<span class="hs-linenum">62: </span>
<span class="hs-linenum">63: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">SubElts</span> <span class="hs-conid">X</span> <span class="hs-conid">Y</span>      <span class="hs-keyglyph">=</span> 
<span class="hs-linenum">64: </span>      <span class="hs-layout">(</span><span class="hs-conid">Set_sub</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">X</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">Y</span><span class="hs-layout">)</span><span class="hs-layout">)</span>                  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">65: </span>
<span class="hs-linenum">66: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">UnionElts</span> <span class="hs-conid">X</span> <span class="hs-conid">Y</span> <span class="hs-conid">Z</span>  <span class="hs-keyglyph">=</span> 
<span class="hs-linenum">67: </span>      <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">X</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cup</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">Y</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">Z</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">68: </span>
<span class="hs-linenum">69: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">ListElt</span> <span class="hs-conid">N</span> <span class="hs-conid">X</span>      <span class="hs-keyglyph">=</span> 
<span class="hs-linenum">70: </span>      <span class="hs-layout">(</span><span class="hs-conid">Set_mem</span> <span class="hs-conid">N</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">X</span><span class="hs-layout">)</span><span class="hs-layout">)</span>                             <span class="hs-keyword">@-}</span>
</pre>
<p>These predicates were our vocabulary on specifying properties of list functions. Remember, that <code>reverse</code> returns an output list that has the same elements, i.e., <code>EqElts</code>, with the input list. We can extend these predicates and express list uniqueness. So reversing a unique list should again return an output list that has the same elements as the input list, and also it is unique.</p>
<h1 id="describing-unique-lists">Describing Unique Lists</h1>
<p>To describe unique lists, we follow two steps:</p>
<ol style="list-style-type: decimal">
<li>we describe the set of duplicate values of a list; and</li>
<li>we demand this set to be empty.</li>
</ol>
<p>Towards the first step, we define a measure <code>dups</code> that returns the duplicate values of its input list. This measure is recursively defined: The duplicates of an empty list is the empty set. We compute the duplicates of a non-empty list, namely <code>x:xs</code>, as follows:</p>
<ul>
<li><p>If <code>x</code> is an element of <code>xs</code>, then <code>x</code> is a duplicate. Hence, <code>dups</code> is <code>x</code> plus the (recursively computed) duplicates in <code>xs</code>.</p></li>
<li><p>Otherwise, we can ignore <code>x</code> and recursively compute the duplicates of <code>xs</code>.</p></li>
</ul>
<p>The above intuition can be formalized as a measure:</p>
<pre><span class="hs-linenum">105: </span><span class="hs-keyword">{-@</span>
<span class="hs-linenum">106: </span>  <span class="hs-varid">measure</span> <span class="hs-varid">dups</span> <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span>
<span class="hs-linenum">107: </span>  <span class="hs-varid">dups</span><span class="hs-layout">(</span><span class="hs-conid">[]</span><span class="hs-layout">)</span>   <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varop">?</span> <span class="hs-layout">(</span><span class="hs-conid">Set_emp</span> <span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
<span class="hs-linenum">108: </span>  <span class="hs-varid">dups</span><span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-keyword">if</span> <span class="hs-layout">(</span><span class="hs-conid">Set_mem</span> <span class="hs-varid">x</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span><span class="hs-layout">)</span>
<span class="hs-linenum">109: </span>                         <span class="hs-keyword">then</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cup</span> <span class="hs-layout">(</span><span class="hs-conid">Set_sng</span> <span class="hs-varid">x</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">dups</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span><span class="hs-layout">)</span>
<span class="hs-linenum">110: </span>                         <span class="hs-keyword">else</span> <span class="hs-layout">(</span><span class="hs-varid">dups</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-layout">}</span>
<span class="hs-linenum">111: </span>  <span class="hs-keyword">@-}</span>
</pre>
<p>With <code>dups</code> in hand, it is direct to describe unique lists:</p>
<p>A list is unique, if the set of duplicates, as computed by <code>dups</code> is empty.</p>
<p>We create a type alias for unique lists and name it <code>UList</code>.</p>
<pre><span class="hs-linenum">121: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">ListUnique</span> <span class="hs-conid">X</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">Set_emp</span> <span class="hs-layout">(</span><span class="hs-varid">dups</span> <span class="hs-conid">X</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">122: </span>
<span class="hs-linenum">123: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">UList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-conid">ListUnique</span> <span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">}</span>     <span class="hs-keyword">@-}</span>
</pre>
<h1 id="functions-on-unique-lists">Functions on Unique Lists</h1>
<p>In the previous post, we proved interesting properties about the list trilogy, i.e., <code>append</code>, <code>reverse</code>, and <code>filter</code>. Now, we will prove that apart from these properties, all these functions preserve list uniqueness.</p>
<h2 id="append">Append</h2>
<p>To begin with, we proved that the output of append indeed includes the elements from both the input lists. Now, we can also prove that if both input lists are unique <em>and their elements are disjoint</em>, then the output list is also unique.</p>
<pre><span class="hs-linenum">145: </span><span class="hs-keyword">infixr</span> <span class="hs-num">5</span> <span class="hs-varop">++</span>
<span class="hs-linenum">146: </span><span class="hs-keyword">{-@</span> <span class="hs-layout">(</span><span class="hs-varop">++</span><span class="hs-layout">)</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">UList</span> <span class="hs-varid">a</span><span class="hs-layout">)</span>
<span class="hs-linenum">147: </span>         <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">ys</span><span class="hs-conop">:</span><span class="hs-keyword">{v:</span> <span class="hs-conid">UList</span> <span class="hs-varid">a</span> <span class="hs-keyword">| (DisjointElts v xs)}</span>
<span class="hs-linenum">148: </span>         <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span> <span class="hs-conid">UList</span> <span class="hs-varid">a</span> <span class="hs-keyword">| (UnionElts v xs ys)}</span>
<span class="hs-linenum">149: </span>  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">150: </span><span class="hs-layout">(</span><span class="hs-varop">++</span><span class="hs-layout">)</span>         <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span>
<span class="hs-linenum">151: </span><span class="hs-conid">[]</span> <a class="annot" href="#"><span class="annottext">forall a.
xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; ys:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts xs)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts ys)))}</span><span class="hs-varop">++</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | ((Set_emp (dups VV)))}</span><span class="hs-varid">ys</span></a>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == ys) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">ys</span></a>
<span class="hs-linenum">152: </span><span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-varop">++</span> <span class="hs-varid">ys</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == x)}</span><span class="hs-varid">x</span></a><a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class="hs-conop">:</span></a><span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a> <a class="annot" href="#"><span class="annottext">xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; ys:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts xs)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts ys)))}</span><span class="hs-varop">++</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == ys) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">ys</span></a><span class="hs-layout">)</span>
</pre>
<h2 id="reverse">Reverse</h2>
<p>Next, we can prove that if a unique list is reversed, the output list has the same elements as the input, and also it is unique.</p>
<pre><span class="hs-linenum">163: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">reverse</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">UList</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span> <span class="hs-conid">UList</span> <span class="hs-varid">a</span> <span class="hs-keyword">| (EqElts v xs)}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">164: </span><span class="hs-definition">reverse</span> <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span>
<span class="hs-linenum">165: </span><a class="annot" href="#"><span class="annottext">forall a.
xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (listElts xs))}</span><span class="hs-definition">reverse</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((len VV) == 0)}
-&gt; x2:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts x1)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x1) (listElts x2))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x2) (listElts x1))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">go</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-conid">[]</span></a>
<span class="hs-linenum">166: </span>  <span class="hs-keyword">where</span>
<span class="hs-linenum">167: </span>    <a class="annot" href="#"><span class="annottext">a:{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((len VV) &gt;= 0)}
-&gt; x1:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts a)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts a) (listElts x1))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x1) (listElts a))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">go</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">a</span></a> <span class="hs-conid">[]</span>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == a) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">a</span></a>
<span class="hs-linenum">168: </span>    <span class="hs-varid">go</span> <span class="hs-varid">a</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">a:{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((len VV) &gt;= 0)}
-&gt; x1:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts a)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts a) (listElts x1))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x1) (listElts a))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">go</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | (VV == x)}</span><span class="hs-varid">x</span></a><a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class="hs-conop">:</span></a><a class="annot" href="#"><span class="annottext">{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == a) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">a</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a> 
</pre>
<h2 id="filter">Filter</h2>
<p>Finally, filtering a unique list returns a list with a subset of values of the input list, that once again is unique!</p>
<pre><span class="hs-linenum">178: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">filter</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span><span class="hs-layout">)</span> 
<span class="hs-linenum">179: </span>           <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">UList</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> 
<span class="hs-linenum">180: </span>           <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span><span class="hs-conid">UList</span> <span class="hs-varid">a</span> <span class="hs-keyword">| (SubElts v xs)}</span> 
<span class="hs-linenum">181: </span>  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">182: </span><a class="annot" href="#"><span class="annottext">forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; x2:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts x2))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-definition">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <span class="hs-conid">[]</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
{VV : [{VV : a | false}]&lt;p&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0)}</span><span class="hs-conid">[]</span></a>
<span class="hs-linenum">183: </span><span class="hs-definition">filter</span> <span class="hs-varid">p</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> 
<span class="hs-linenum">184: </span>  <span class="hs-keyglyph">|</span> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == x)}</span><span class="hs-varid">x</span></a>       <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; x2:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts x2))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a>
<span class="hs-linenum">185: </span>  <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; x2:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts x2))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a>
</pre>
<h1 id="unique-zipper">Unique Zipper</h1>
<p>That was easy enough! Now, lets look at a slightly more interesting structure fashioned from lists. A <a href="http://en.wikipedia.org/wiki/Zipper_(data_structure)">zipper</a> is an aggregate data stucture that is used to arbitrary traverse the structure and update its contents.</p>
<p>We define a zipper as a data type that contains an element (called <code>focus</code>) that we are currently using, a list of elements (called <code>up</code>) before the current one, and a list of elements (called <code>down</code>) after the current one.</p>
<pre><span class="hs-linenum">202: </span><span class="hs-keyword">data</span> <span class="hs-conid">Zipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">Zipper</span> <span class="hs-layout">{</span> <a class="annot" href="#"><span class="annottext">forall a. (UniqueZipper.Zipper a) -&gt; a</span><span class="hs-varid">focus</span></a> <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span>       <span class="hs-comment">-- focused element in this set</span>
<span class="hs-linenum">203: </span>                       <span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">forall a. (UniqueZipper.Zipper a) -&gt; [a]</span><span class="hs-varid">up</span></a>    <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span>     <span class="hs-comment">-- elements to the left</span>
<span class="hs-linenum">204: </span>                       <span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">forall a. (UniqueZipper.Zipper a) -&gt; [a]</span><span class="hs-varid">down</span></a>  <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-layout">}</span>   <span class="hs-comment">-- elements to the right</span>
</pre>
<p>One well-known application of zippers is in the <a href="http://xmonad.org/">XMonad</a> tiling window manager. The set of windows being managed is stored in a zipper similar to the above. The <code>focus</code> happily coincides with the window currently in focus, and the <code>up</code> and <code>down</code> to the list of windows that come before and after it.</p>
<p>One crucial invariant maintained by XMonad is that the zipper structure is unique – i.e. each window appears at most once inside the zipper.</p>
<p>Lets see how we can state and check that all the values in a zipper are unique.</p>
<p>To start with, we would like to refine the <code>Zipper</code> data declaration to express that both the lists in the structure are unique <strong>and</strong> do not include <code>focus</code> in their values.</p>
<p>LiquidHaskell allow us to refine data type declarations, using the liquid comments. So, apart from above definition definition for the <code>Zipper</code>, we add a refined one, stating that the data structure always enjoys the desired properties.</p>
<pre><span class="hs-linenum">229: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">data</span> <span class="hs-conid">Zipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">Zipper</span> <span class="hs-layout">{</span> <span class="hs-varid">focus</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span>
<span class="hs-linenum">230: </span>                           <span class="hs-layout">,</span> <span class="hs-varid">up</span>    <span class="hs-keyglyph">::</span> <span class="hs-conid">UListDif</span> <span class="hs-varid">a</span> <span class="hs-varid">focus</span>
<span class="hs-linenum">231: </span>                           <span class="hs-layout">,</span> <span class="hs-varid">down</span>  <span class="hs-keyglyph">::</span> <span class="hs-conid">UListDif</span> <span class="hs-varid">a</span> <span class="hs-varid">focus</span><span class="hs-layout">}</span>
<span class="hs-linenum">232: </span>  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">233: </span>
<span class="hs-linenum">234: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">UListDif</span> <span class="hs-varid">a</span> <span class="hs-conid">N</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">UList</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varid">not</span> <span class="hs-layout">(</span><span class="hs-conid">ListElt</span> <span class="hs-conid">N</span> <span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">}</span> <span class="hs-keyword">@-}</span>
</pre>
<p>It is worth noting that the above is kind of <em>dependent</em> record in that the types of the <code>up</code> and <code>down</code> fields depend on the value of the <code>focus</code> field.</p>
<p>With this annotation any time we use a <code>Zipper</code> in the code LiquidHaskell knows that the <code>up</code> and <code>down</code> components are unique lists that do not include <code>focus</code>. Moreover, when a new <code>Zipper</code> is constructed LiquidHaskell proves that this property holds, otherwise a liquid type error is reported.</p>
<p>Hold on a minute!</p>
<p>The awake reader will have noticed that values inside the <code>Zipper</code> as specified so far, are <em>not unique</em>, as nothing prevents a value from appearing in both the <code>up</code> and the <code>down</code> components.</p>
<p>So, we have to specify that the contents of those two fields are <em>disjoint</em>.</p>
<p>One way to achieve this is by defining two measures <code>getUp</code> and <code>getDown</code> that return the relevant parts of the <code>Zipper</code></p>
<pre><span class="hs-linenum">260: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">measure</span> <span class="hs-varid">getUp</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">forall</span> <span class="hs-varid">a</span><span class="hs-varop">.</span> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> 
<span class="hs-linenum">261: </span>    <span class="hs-varid">getUp</span> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">focus</span> <span class="hs-varid">up</span> <span class="hs-varid">down</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">up</span>
<span class="hs-linenum">262: </span>  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">263: </span>
<span class="hs-linenum">264: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">measure</span> <span class="hs-varid">getDown</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">forall</span> <span class="hs-varid">a</span><span class="hs-varop">.</span> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> 
<span class="hs-linenum">265: </span>    <span class="hs-varid">getDown</span> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">focus</span> <span class="hs-varid">up</span> <span class="hs-varid">down</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">down</span>
<span class="hs-linenum">266: </span>  <span class="hs-keyword">@-}</span>
</pre>
<p>With these definitions, we create a type alias <code>UZipper</code> that states that the two list components are disjoint, and hence, that we have a <em>unique zipper</em> with no duplicates.</p>
<pre><span class="hs-linenum">274: </span><span class="hs-keyword">{-@</span> 
<span class="hs-linenum">275: </span>  <span class="hs-keyword">type</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Zipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-conid">DisjointElts</span> <span class="hs-layout">(</span><span class="hs-varid">getUp</span> <span class="hs-varid">v</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">getDown</span> <span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">}</span> 
<span class="hs-linenum">276: </span>  <span class="hs-keyword">@-}</span>
</pre>
<h1 id="functions-on-unique-zippers">Functions on Unique Zippers</h1>
<p>Now that we have defined a unique zipper, it is straightforward for LiquidHaskell to prove that operations on zippers preserve uniqueness.</p>
<h2 id="differentiation">Differentiation</h2>
<p>We can prove that a zipper that built from elements from a unique list is indeed unique.</p>
<pre><span class="hs-linenum">293: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">differentiate</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">UList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Maybe</span> <span class="hs-layout">(</span><span class="hs-conid">UZipper</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">294: </span><a class="annot" href="#"><span class="annottext">forall a.
{VV : [a] | ((Set_emp (dups VV)))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class="hs-definition">differentiate</span></a> <span class="hs-conid">[]</span>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall a. {VV : (Data.Maybe.Maybe a) | (((isJust VV)) &lt;=&gt; false)}</span><span class="hs-conid">Nothing</span></a>
<span class="hs-linenum">295: </span><span class="hs-definition">differentiate</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}) | (((isJust VV)) &lt;=&gt; true) &amp;&amp; ((fromJust VV) == x)}</span><span class="hs-conid">Just</span></a> <a class="annot" href="#"><span class="annottext">({VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}))
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class="hs-varop">$</span></a> <a class="annot" href="#"><span class="annottext">focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class="hs-conid">Zipper</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-conid">[]</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a>
</pre>
<h2 id="integration">Integration</h2>
<p>And vice versa, all elements of a unique zipper yield a unique list.</p>
<pre><span class="hs-linenum">304: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">integrate</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">UList</span> <span class="hs-varid">a</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">305: </span><a class="annot" href="#"><span class="annottext">forall a.
{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : [a] | ((Set_emp (dups VV)))}</span><span class="hs-definition">integrate</span></a> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">x</span> <span class="hs-varid">l</span> <span class="hs-varid">r</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (listElts xs))}</span><span class="hs-varid">reverse</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == l) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">l</span></a> <a class="annot" href="#"><span class="annottext">xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; ys:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts xs)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts ys)))}</span><span class="hs-varop">++</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == r) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">r</span></a>
</pre>
<p>Recall the types for <code>++</code> and <code>reverse</code> that we proved earlier – hover your mouse over the identifiers to refresh your memory. Those types are essential for establishing the type of <code>integrate</code>.</p>
<ul>
<li><p>By the definition of <code>UZipper</code> we know that <code>l</code> is a unique list and that <code>x</code> is not an element of <code>l</code>.</p></li>
<li><p>Thus via the type of <code>reverse</code> we know that <code>reverse l</code> is also unique and disjoint from <code>x</code> and <code>r</code>.</p></li>
<li><p>Finally, using the previously established type for <code>++</code> LiquidHaskell can prove that since <code>x : r</code> is a unique list with elements disjoint from <code>reverse l</code> the concatenation of the two lists is also a unique list.</p></li>
</ul>
<p>With the exact same reasoning, we use the above list operations to create more zipper operations.</p>
<h2 id="reverse-1">Reverse</h2>
<p>We can reverse a unique zipper</p>
<pre><span class="hs-linenum">332: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">reverseZipper</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">333: </span><span class="hs-definition">reverseZipper</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Zipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Zipper</span> <span class="hs-varid">a</span>
<span class="hs-linenum">334: </span><a class="annot" href="#"><span class="annottext">forall a.
{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-definition">reverseZipper</span></a> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">t</span> <span class="hs-varid">ls</span> <span class="hs-varid">rs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class="hs-conid">Zipper</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == t)}</span><span class="hs-varid">t</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">rs</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">ls</span></a>
</pre>
<h2 id="shifting-focus">Shifting Focus</h2>
<p>More the focus up or down</p>
<pre><span class="hs-linenum">343: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">focusUp</span>   <span class="hs-keyglyph">::</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">344: </span><a class="annot" href="#"><span class="annottext">forall a.
{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-definition">focusUp</span></a> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">t</span> <span class="hs-conid">[]</span> <span class="hs-varid">rs</span><span class="hs-layout">)</span>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class="hs-conid">Zipper</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == x) &amp;&amp; (VV == x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == xs) &amp;&amp; (VV == xs) &amp;&amp; ((len VV) == (len xs)) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts xs))) &amp;&amp; ((listElts VV) == (listElts xs)) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-conid">[]</span></a> 
<span class="hs-linenum">345: </span>  <span class="hs-keyword">where</span> 
<span class="hs-linenum">346: </span>    <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | (VV == x)}</span><span class="hs-varid">x</span></a><span class="hs-conop">:</span><a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == xs) &amp;&amp; ((len VV) == (len xs)) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts xs))) &amp;&amp; ((listElts VV) == (listElts xs)) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a><span class="hs-layout">)</span>                   <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (listElts xs))}</span><span class="hs-varid">reverse</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | (VV == t)}</span><span class="hs-varid">t</span></a><a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class="hs-conop">:</span></a><a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">rs</span></a><span class="hs-layout">)</span>
<span class="hs-linenum">347: </span>
<span class="hs-linenum">348: </span><span class="hs-definition">focusUp</span> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">t</span> <span class="hs-layout">(</span><span class="hs-varid">l</span><span class="hs-conop">:</span><span class="hs-varid">ls</span><span class="hs-layout">)</span> <span class="hs-varid">rs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class="hs-conid">Zipper</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == l)}</span><span class="hs-varid">l</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">ls</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | (VV == t)}</span><span class="hs-varid">t</span></a><a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class="hs-conop">:</span></a><a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">rs</span></a><span class="hs-layout">)</span>
<span class="hs-linenum">349: </span>
<span class="hs-linenum">350: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">focusDown</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">351: </span><a class="annot" href="#"><span class="annottext">forall a.
{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-definition">focusDown</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-varid">reverseZipper</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;q :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool, p :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool&gt;.
(x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; {VV : (UniqueZipper.Zipper a)&lt;p x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})
-&gt; (y:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
    -&gt; {VV : (UniqueZipper.Zipper a)&lt;q y&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})
-&gt; x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; exists [z:{VV : (UniqueZipper.Zipper a)&lt;q x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}].{VV : (UniqueZipper.Zipper a)&lt;p z&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-varop">.</span></a> <a class="annot" href="#"><span class="annottext">{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-varid">focusUp</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;q :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool, p :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool&gt;.
(x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; {VV : (UniqueZipper.Zipper a)&lt;p x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})
-&gt; (y:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
    -&gt; {VV : (UniqueZipper.Zipper a)&lt;q y&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})
-&gt; x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; exists [z:{VV : (UniqueZipper.Zipper a)&lt;q x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}].{VV : (UniqueZipper.Zipper a)&lt;p z&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-varop">.</span></a> <a class="annot" href="#"><span class="annottext">{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-varid">reverseZipper</span></a>
</pre>
<h2 id="filter-1">Filter</h2>
<p>Finally, using the filter operation on lists allows LiquidHaskell to prove that filtering a zipper also preserves uniqueness.</p>
<pre><span class="hs-linenum">361: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">filterZipper</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Maybe</span> <span class="hs-layout">(</span><span class="hs-conid">UZipper</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">362: </span><a class="annot" href="#"><span class="annottext">forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class="hs-definition">filterZipper</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">f</span> <span class="hs-varid">ls</span> <span class="hs-varid">rs</span><span class="hs-layout">)</span> 
<span class="hs-linenum">363: </span>  <span class="hs-keyglyph">=</span> <span class="hs-keyword">case</span> <a class="annot" href="#"><span class="annottext">(a -&gt; (GHC.Types.Bool))
-&gt; xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts xs)))}</span><span class="hs-varid">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | (VV == f)}</span><span class="hs-varid">f</span></a><a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class="hs-conop">:</span></a><a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem f (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">rs</span></a><span class="hs-layout">)</span> <span class="hs-keyword">of</span>
<span class="hs-linenum">364: </span>      <span class="hs-varid">f'</span><span class="hs-conop">:</span><span class="hs-varid">rs'</span> <span class="hs-keyglyph">-&gt;</span> <a class="annot" href="#"><span class="annottext">x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}) | (((isJust VV)) &lt;=&gt; true) &amp;&amp; ((fromJust VV) == x)}</span><span class="hs-conid">Just</span></a> <a class="annot" href="#"><span class="annottext">({VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}))
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class="hs-varop">$</span></a> <a class="annot" href="#"><span class="annottext">focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class="hs-conid">Zipper</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == f')}</span><span class="hs-varid">f'</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">(a -&gt; (GHC.Types.Bool))
-&gt; xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts xs)))}</span><span class="hs-varid">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem f (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">ls</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == rs') &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">rs'</span></a>
<span class="hs-linenum">365: </span>      <span class="hs-conid">[]</span>     <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">case</span> <a class="annot" href="#"><span class="annottext">(a -&gt; (GHC.Types.Bool))
-&gt; xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts xs)))}</span><span class="hs-varid">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem f (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">ls</span></a> <span class="hs-keyword">of</span>                  
<span class="hs-linenum">366: </span>                  <span class="hs-varid">f'</span><span class="hs-conop">:</span><span class="hs-varid">ls'</span> <span class="hs-keyglyph">-&gt;</span> <a class="annot" href="#"><span class="annottext">x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}) | (((isJust VV)) &lt;=&gt; true) &amp;&amp; ((fromJust VV) == x)}</span><span class="hs-conid">Just</span></a> <a class="annot" href="#"><span class="annottext">({VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}))
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class="hs-varop">$</span></a> <a class="annot" href="#"><span class="annottext">focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class="hs-conid">Zipper</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == f')}</span><span class="hs-varid">f'</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == ls') &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">ls'</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-conid">[]</span></a>
<span class="hs-linenum">367: </span>                  <span class="hs-conid">[]</span>     <span class="hs-keyglyph">-&gt;</span> <a class="annot" href="#"><span class="annottext">forall a. {VV : (Data.Maybe.Maybe a) | (((isJust VV)) &lt;=&gt; false)}</span><span class="hs-conid">Nothing</span></a>
</pre>
<h1 id="conclusion">Conclusion</h1>
<p>That’s all for now! This post illustrated</p>
<ol style="list-style-type: decimal">
<li><p>How we can use set theory to express properties the values of the list, such as list uniqueness.</p></li>
<li><p>How we can use LuquidHaskell to prove that these properties are preserved through list operations.</p></li>
<li><p>How we can embed this properties in complicated data structures that use lists, such as a zipper.</p></li>
</ol>
<pre><span class="hs-linenum">390: </span><span class="hs-comment">-- TODO: Dummy function to provide qualifier hint.</span>
<span class="hs-linenum">391: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">q</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span>  <span class="hs-keyword">{v:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyword">|(not (Set_mem x (listElts v)))}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">392: </span><span class="hs-definition">q</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span>
<span class="hs-linenum">393: </span><a class="annot" href="#"><span class="annottext">forall a. x:a -&gt; {VV : [a] | (not (((Set_mem x (listElts VV)))))}</span><span class="hs-definition">q</span></a> <span class="hs-keyword">_</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
{VV : [{VV : a | false}]&lt;p&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0)}</span><span class="hs-conid">[]</span></a>
</pre>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

            </div>
        </div>
    </div>
</article>
<hr>

        </div>
        <div id="footer">
        </div>
      <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="https://ucsd-progsys.github.io/liquidhaskell-blog/feed.xml" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/ranjitjhala" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://plus.google.com/u/0/106612421534244742464" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/ucsd-progsys" target="_blank">
                            <span class="fa-stack fa-lg">

                              <i class="fa fa-arrow-circle-o-down"></i>
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
		    
                </ul>
                <p class="copyright text-muted">
                
                  Copyright &copy; Niki Vazou 2016-17.
                
                  Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
                </p>
            </div>
        </div>
    </div>
</footer>


<!-- jQuery -->
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/jquery-3.1.1.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/spaceg.stylesheets.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/bootstrap.min.js"></script>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/scripts.js"></script>

    </body>
</html>
