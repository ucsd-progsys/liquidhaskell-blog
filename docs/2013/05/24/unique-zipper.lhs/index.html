<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    
    <head>
   <!-- Global Site Tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-106786912-1">
    </script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments)};
      gtag('js', new Date());
      gtag('config', 'UA-106786912-1');
    </script>


     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
 <!--
      loads the http over https ssl -
      welcome to my website!

	this theme is based off the Ice & Fire theme created by Lucas Gatsas
      https://www.twitter.com/LucasGatsas
      www.lucasgatsas.ch - switzerland.
  -->


<!-- Microsoft Internet Explorer documentMode compatMode setting IE Modus -->
<script type="text/javascript">
var IE = null;
if (window.navigator.appName == "Microsoft Internet Explorer") {
  if (document.documentMode) {

    IE = document.documentMode;
    } else {

        IE = 5;
          if (document.compatMode) {
      if (document.compatMode == "CSS1Compat")
      IE = 11;
      }
    }
  }
</script>

    <meta charset="utf-8">
    <!-- X-UA -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <link rel="author" title="Ranjit Jhala" href="http://ranjitjhala.github.io" />

    <meta name="google" content="notranslate" />
    <!-- Viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- index ROBOTS follow -->
    <meta name="robots" content="index, follow" />
    <!-- Site Desciption -->
    <meta name="description" content="LiquidHaskell Blog">
    <!-- Site Desciption -->
    <meta name="keywords" content="haskell, refinement types, liquid types, formal methods, type systems">
    <!-- Favicon -->
    <link rel="shortcut icon" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" type="image/x-icon" />
    <!-- Blog Title -->
    <title>LiquidHaskell</title>

    <!--     <title>{% if page.title %}{{ page.title }} - {{ site.title }}{% else %}{{ site.title }}{% endif %}</title>
-->
    <!-- Property Metas -->
    <meta property="og:image" content="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ix.png" />
    <meta property="og:title" content="LiquidHaskell Blog" />
    <meta property="og:site_name" content="LiquidHaskell Blog" />
    <!-- Canonical -->
    <link rel="canonical" href="{{ page.url | replace:'index.html','' | prepend: site.baseUrl | prepend: site.url }}">
    <!-- StyleSheet -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/bootstrap.min.css">
    <!-- <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/spaceg.stylesheets.css"> -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/ronacher.css" type="text/css">

    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/syntax.css">
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/liquid-light.css">

    <!-- Fonts
    <link href='https://fonts.googleapis.com/css?family=Merriweather:400,300,300italic,400italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900,400italic,700italic,900italic' rel='stylesheet' type='text/css'>
    -->

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>
	#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:url("/static/img/preloader.gif"); /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	ul, ol {margin-top: 0;margin-bottom: 10px;}
	.navbar-inverse {background-color: #FFF;border-color: #FFFFFF;}
</style>
<!--link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/prettify.css"-->
<style>
  /* HEADER IMAGE */
  header.intro-header {background: #6f5499;background: no-repeat center center;background-attachment: scroll;-webkit-background-size: cover;-moz-background-size: cover;background-size: cover;-o-background-size: cover;}

	/* Preloader */#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:; /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	li {list-style: none;}
            body.modal-open
            {overflow: hidden;padding-right: 0px;
        }
	article li {list-style: inherit;}
	article .figure {text-align: center}
    </style>
    <!-- end Loading front stylesheet here -->

    <link href="atom.xml" type="application/atom+xml" rel="alternate" title="LiquidHaskell-Blog ATOM Feed" />
    </head>

    <body>
	    
	<!-- 	
        <div id="preloader">
	    <div id="status">
	    </div>
	</div>  
	-->
	<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ucsd-progsys.github.io/liquidhaskell-blog" id="blog-title-left-top">LiquidHaskell</a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- <li class="dropdown">
                    <a href="#portfolioModal2" data-toggle="modal"><i class="fa fa-random" id="icon-top"></i></a>
                <ul class="dropdown-menu"></ul>
                </li>-->
                
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/blog.html">Blog</a></li>
                <li><a href="http://goto.ucsd.edu:8090/index.html#?demo=UniqueZipper.hs" target="_blank">Demo</a></li>
                <li><a href="http://ucsd-progsys.github.io/lh-workshop" target="_blank">Tutorial</a></li>
                <li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial" target="_blank">Book</a></li>
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html" target="_blank">About</a></li>
                <li><a href="http://www.github.com/ucsd-progsys/liquidhaskell" target="_blank"><i class="fa fa-twitter"></i>Download</a></li>
                <!--
                <li><a href="https://www.twitter.com/ranjitjhala" id="roundbutton" target="_blank"><i class="fa fa-twitter"></i>RanjitJhala</a></li>
                -->
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<!-- Portfolio Modals -->
    <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" class="img-responsive img-centered" alt title>
                            <p class="font-style-inline-small">
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow me</a>. <br>
                                <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                                <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>
                            </p>
                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<!-- Menu Modals Add New Sa.21.Feb.2015 03:22:25 -->
    <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <p class="font-style-inline-small">
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow</a>. <br>
                        <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                        <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>  <br>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/index.html">Home</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html">About</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/blog.html">Blog</a></li>
                    <li><a href="http://goto.ucsd.edu:8090/index.html#?demo=UniqueZipper.hs" target="_blank">Demo</a></li>
                    <li><a href="http://ucsd-progsys.github.io/lh-workshop" target="_blank">Tutorial</a></li>
                    <li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial" target="_blank">Book</a></li>
                    <li><a href="http://www.github.com/ucsd-progsys/liquidhaskell" target="_blank"><i class="fa fa-twitter"></i>Download</a></li>
                            </p>

                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


        <div id="content">
            <!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt title>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Unique Zippers</h1>
                    
                    <span class="meta">
		    
			Posted by Niki Vazou
		    
			May 24, 2013
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged 'basic'." href="../../../../tags/basic.html">basic</a>, <a title="All pages tagged 'measures'." href="../../../../tags/measures.html">measures</a>, <a title="All pages tagged 'sets'." href="../../../../tags/sets.html">sets</a>, <a title="All pages tagged 'uniqueness'." href="../../../../tags/uniqueness.html">uniqueness</a>
              
            </div>

            <br>
			            <p><strong>The story so far:</strong> <a href="blog/2013/03/26/talking-about-sets.lhs/">Previously</a> we saw
how we can use LiquidHaskell to talk about set of values
and specifically the <em>set of values</em> in a list.</p>
<p>Often, we want to enforce the invariant that a particular data structure
contains <em>no duplicates</em>. For example, we may have a structure that holds
a collection of file handles, or other resources, where the presence of
duplicates could lead to unpleasant leaks.</p>
<p>In this post, we will see how to use LiquidHaskell to talk
about the set of duplicate values in data structures, and
hence, let us specify and verify uniqueness, that is, the
absence of duplicates.</p>
<!-- more -->
<p>To begin, lets extend our vocabulary to talk about the <em>set of duplicate
values</em> in lists. By constraining this set to be empty, we can specify a
list without duplicates, or an <strong>unique list</strong>. Once we express uniqueness
on lists, it is straightforward to describe uniqueness on other data
structures that contain lists. As an example, we will illustrate the
properties of a <strong>unique zipper</strong>.</p>
<pre><span class="hs-linenum">37: </span><span class="hs-keyword">module</span> <span class="hs-conid">UniqueZipper</span> <span class="hs-keyword">where</span>
<span class="hs-linenum">38: </span>
<span class="hs-linenum">39: </span><span class="hs-keyword">import</span> <span class="hs-conid">Prelude</span>  <span class="hs-varid">hiding</span> <span class="hs-layout">(</span><span class="hs-varid">reverse</span><span class="hs-layout">,</span> <span class="hs-layout">(</span><span class="hs-varop">++</span><span class="hs-layout">)</span><span class="hs-layout">,</span> <span class="hs-varid">filter</span><span class="hs-layout">)</span>
<span class="hs-linenum">40: </span><span class="hs-keyword">import</span> <span class="hs-conid">Data</span><span class="hs-varop">.</span><span class="hs-conid">Set</span> <span class="hs-varid">hiding</span> <span class="hs-layout">(</span><span class="hs-varid">filter</span><span class="hs-layout">)</span>
</pre>
<h1 id="a-quick-recap">A Quick Recap</h1>
In the previous post we used a measure for the elements of a list, from <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/Data/Set.spec">Data/Set.spec</a>
<pre><span class="hs-linenum">48: </span><span class="hs-definition">measure</span> <span class="hs-varid">listElts</span> <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span>
<span class="hs-linenum">49: </span><span class="hs-definition">listElts</span> <span class="hs-layout">(</span><span class="hs-conid">[]</span><span class="hs-layout">)</span>    <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varop">?</span> <span class="hs-layout">(</span><span class="hs-conid">Set_emp</span> <span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
<span class="hs-linenum">50: </span><span class="hs-definition">listElts</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span>  <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cup</span> <span class="hs-layout">(</span><span class="hs-conid">Set_sng</span> <span class="hs-varid">x</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-layout">}</span>
</pre>
<p>With this measure we defined predicate aliases
that describe relations between lists:</p>
<pre><span class="hs-linenum">57: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">EqElts</span>  <span class="hs-conid">X</span> <span class="hs-conid">Y</span>      <span class="hs-keyglyph">=</span> 
<span class="hs-linenum">58: </span>      <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">X</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">Y</span><span class="hs-layout">)</span><span class="hs-layout">)</span>                        <span class="hs-keyword">@-}</span>
<span class="hs-linenum">59: </span>
<span class="hs-linenum">60: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">DisjointElts</span> <span class="hs-conid">X</span> <span class="hs-conid">Y</span> <span class="hs-keyglyph">=</span> 
<span class="hs-linenum">61: </span>      <span class="hs-layout">(</span><span class="hs-conid">Set_emp</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cap</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">X</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">Y</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">)</span>        <span class="hs-keyword">@-}</span>
<span class="hs-linenum">62: </span>
<span class="hs-linenum">63: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">SubElts</span> <span class="hs-conid">X</span> <span class="hs-conid">Y</span>      <span class="hs-keyglyph">=</span> 
<span class="hs-linenum">64: </span>      <span class="hs-layout">(</span><span class="hs-conid">Set_sub</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">X</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">Y</span><span class="hs-layout">)</span><span class="hs-layout">)</span>                  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">65: </span>
<span class="hs-linenum">66: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">UnionElts</span> <span class="hs-conid">X</span> <span class="hs-conid">Y</span> <span class="hs-conid">Z</span>  <span class="hs-keyglyph">=</span> 
<span class="hs-linenum">67: </span>      <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">X</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cup</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">Y</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">Z</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">68: </span>
<span class="hs-linenum">69: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">ListElt</span> <span class="hs-conid">N</span> <span class="hs-conid">X</span>      <span class="hs-keyglyph">=</span> 
<span class="hs-linenum">70: </span>      <span class="hs-layout">(</span><span class="hs-conid">Set_mem</span> <span class="hs-conid">N</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">X</span><span class="hs-layout">)</span><span class="hs-layout">)</span>                             <span class="hs-keyword">@-}</span>
</pre>
<p>These predicates were our vocabulary on specifying properties of list functions.
Remember, that <code>reverse</code> returns an output list that has the same elements, i.e., <code>EqElts</code>, with the input list.
We can extend these predicates and express list uniqueness.
So reversing a unique list should again return an output list that has the same
elements as the input list, and also it is unique.</p>
<h1 id="describing-unique-lists">Describing Unique Lists</h1>
<p>To describe unique lists, we follow two steps:</p>
<ol type="1">
<li>we describe the set of duplicate values of a list; and</li>
<li>we demand this set to be empty.</li>
</ol>
<p>Towards the first step, we define a measure <code>dups</code>
that returns the duplicate values of its input list.
This measure is recursively defined:
The duplicates of an empty list is the empty set.
We compute the duplicates of a non-empty list,
namely <code>x:xs</code>, as follows:</p>
<ul>
<li><p>If <code>x</code> is an element of <code>xs</code>, then <code>x</code> is a duplicate.
Hence, <code>dups</code> is <code>x</code> plus the (recursively computed)
duplicates in <code>xs</code>.</p></li>
<li><p>Otherwise, we can ignore <code>x</code> and recursively compute
the duplicates of <code>xs</code>.</p></li>
</ul>
<p>The above intuition can be formalized as a measure:</p>
<pre><span class="hs-linenum">105: </span><span class="hs-keyword">{-@</span>
<span class="hs-linenum">106: </span>  <span class="hs-varid">measure</span> <span class="hs-varid">dups</span> <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span>
<span class="hs-linenum">107: </span>  <span class="hs-varid">dups</span><span class="hs-layout">(</span><span class="hs-conid">[]</span><span class="hs-layout">)</span>   <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varop">?</span> <span class="hs-layout">(</span><span class="hs-conid">Set_emp</span> <span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
<span class="hs-linenum">108: </span>  <span class="hs-varid">dups</span><span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-keyword">if</span> <span class="hs-layout">(</span><span class="hs-conid">Set_mem</span> <span class="hs-varid">x</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span><span class="hs-layout">)</span>
<span class="hs-linenum">109: </span>                         <span class="hs-keyword">then</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cup</span> <span class="hs-layout">(</span><span class="hs-conid">Set_sng</span> <span class="hs-varid">x</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">dups</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span><span class="hs-layout">)</span>
<span class="hs-linenum">110: </span>                         <span class="hs-keyword">else</span> <span class="hs-layout">(</span><span class="hs-varid">dups</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-layout">}</span>
<span class="hs-linenum">111: </span>  <span class="hs-keyword">@-}</span>
</pre>
<p>With <code>dups</code> in hand, it is direct to describe unique lists:</p>
<p>A list is unique, if the set of duplicates, as computed by <code>dups</code> is empty.</p>
<p>We create a type alias for unique lists and name it <code>UList</code>.</p>
<pre><span class="hs-linenum">121: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">ListUnique</span> <span class="hs-conid">X</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">Set_emp</span> <span class="hs-layout">(</span><span class="hs-varid">dups</span> <span class="hs-conid">X</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">122: </span>
<span class="hs-linenum">123: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">UList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-conid">ListUnique</span> <span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">}</span>     <span class="hs-keyword">@-}</span>
</pre>
<h1 id="functions-on-unique-lists">Functions on Unique Lists</h1>
<p>In the previous post, we proved interesting properties about
the list trilogy, i.e., <code>append</code>, <code>reverse</code>, and <code>filter</code>.
Now, we will prove that apart from these properties,
all these functions preserve list uniqueness.</p>
<h2 id="append">Append</h2>
<p>To begin with, we proved that the output of append
indeed includes the elements from both the input lists.
Now, we can also prove that if both input lists are
unique <em>and their elements are disjoint</em>, then the
output list is also unique.</p>
<pre><span class="hs-linenum">145: </span><span class="hs-keyword">infixr</span> <span class="hs-num">5</span> <span class="hs-varop">++</span>
<span class="hs-linenum">146: </span><span class="hs-keyword">{-@</span> <span class="hs-layout">(</span><span class="hs-varop">++</span><span class="hs-layout">)</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">UList</span> <span class="hs-varid">a</span><span class="hs-layout">)</span>
<span class="hs-linenum">147: </span>         <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">ys</span><span class="hs-conop">:</span><span class="hs-keyword">{v:</span> <span class="hs-conid">UList</span> <span class="hs-varid">a</span> <span class="hs-keyword">| (DisjointElts v xs)}</span>
<span class="hs-linenum">148: </span>         <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span> <span class="hs-conid">UList</span> <span class="hs-varid">a</span> <span class="hs-keyword">| (UnionElts v xs ys)}</span>
<span class="hs-linenum">149: </span>  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">150: </span><span class="hs-layout">(</span><span class="hs-varop">++</span><span class="hs-layout">)</span>         <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span>
<span class="hs-linenum">151: </span><span class="hs-conid">[]</span> <a class="annot" href="#"><span class="annottext">forall a.
xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; ys:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts xs)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts ys)))}</span><span class="hs-varop">++</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | ((Set_emp (dups VV)))}</span><span class="hs-varid">ys</span></a>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == ys) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">ys</span></a>
<span class="hs-linenum">152: </span><span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-varop">++</span> <span class="hs-varid">ys</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == x)}</span><span class="hs-varid">x</span></a><a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class="hs-conop">:</span></a><span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a> <a class="annot" href="#"><span class="annottext">xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; ys:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts xs)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts ys)))}</span><span class="hs-varop">++</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == ys) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">ys</span></a><span class="hs-layout">)</span>
</pre>
<h2 id="reverse">Reverse</h2>
<p>Next, we can prove that if a unique list is reversed,
the output list has the same elements as the input,
and also it is unique.</p>
<pre><span class="hs-linenum">163: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">reverse</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">UList</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span> <span class="hs-conid">UList</span> <span class="hs-varid">a</span> <span class="hs-keyword">| (EqElts v xs)}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">164: </span><span class="hs-definition">reverse</span> <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span>
<span class="hs-linenum">165: </span><a class="annot" href="#"><span class="annottext">forall a.
xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (listElts xs))}</span><span class="hs-definition">reverse</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((len VV) == 0)}
-&gt; x2:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts x1)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x1) (listElts x2))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x2) (listElts x1))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">go</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-conid">[]</span></a>
<span class="hs-linenum">166: </span>  <span class="hs-keyword">where</span>
<span class="hs-linenum">167: </span>    <a class="annot" href="#"><span class="annottext">a:{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((len VV) &gt;= 0)}
-&gt; x1:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts a)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts a) (listElts x1))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x1) (listElts a))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">go</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">a</span></a> <span class="hs-conid">[]</span>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == a) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">a</span></a>
<span class="hs-linenum">168: </span>    <span class="hs-varid">go</span> <span class="hs-varid">a</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">a:{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((len VV) &gt;= 0)}
-&gt; x1:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts a)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts a) (listElts x1))) &amp;&amp; ((listElts VV) == (Set_cup (listElts x1) (listElts a))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">go</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | (VV == x)}</span><span class="hs-varid">x</span></a><a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class="hs-conop">:</span></a><a class="annot" href="#"><span class="annottext">{VV : [a] | ((Set_emp (dups VV))) &amp;&amp; (VV == a) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">a</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a> 
</pre>
<h2 id="filter">Filter</h2>
<p>Finally, filtering a unique list returns a list with a subset of
values of the input list, that once again is unique!</p>
<pre><span class="hs-linenum">178: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">filter</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span><span class="hs-layout">)</span> 
<span class="hs-linenum">179: </span>           <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">UList</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> 
<span class="hs-linenum">180: </span>           <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span><span class="hs-conid">UList</span> <span class="hs-varid">a</span> <span class="hs-keyword">| (SubElts v xs)}</span> 
<span class="hs-linenum">181: </span>  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">182: </span><a class="annot" href="#"><span class="annottext">forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; x2:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts x2))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-definition">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <span class="hs-conid">[]</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
{VV : [{VV : a | false}]&lt;p&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0)}</span><span class="hs-conid">[]</span></a>
<span class="hs-linenum">183: </span><span class="hs-definition">filter</span> <span class="hs-varid">p</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> 
<span class="hs-linenum">184: </span>  <span class="hs-keyglyph">|</span> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == x)}</span><span class="hs-varid">x</span></a>       <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; x2:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts x2))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a>
<span class="hs-linenum">185: </span>  <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; x2:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts x2))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a>
</pre>
<h1 id="unique-zipper">Unique Zipper</h1>
<p>That was easy enough! Now, lets look at a slightly more interesting
structure fashioned from lists. A <a href="http://en.wikipedia.org/wiki/Zipper_(data_structure)">zipper</a> is an aggregate
data stucture that is used to arbitrary traverse the structure and update
its contents.</p>
<p>We define a zipper as a data type that contains an element (called <code>focus</code>)
that we are currently using, a list of elements (called <code>up</code>) before
the current one, and a list of elements (called <code>down</code>) after the current one.</p>
<pre><span class="hs-linenum">202: </span><span class="hs-keyword">data</span> <span class="hs-conid">Zipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">Zipper</span> <span class="hs-layout">{</span> <a class="annot" href="#"><span class="annottext">forall a. (UniqueZipper.Zipper a) -&gt; a</span><span class="hs-varid">focus</span></a> <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span>       <span class="hs-comment">-- focused element in this set</span>
<span class="hs-linenum">203: </span>                       <span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">forall a. (UniqueZipper.Zipper a) -&gt; [a]</span><span class="hs-varid">up</span></a>    <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span>     <span class="hs-comment">-- elements to the left</span>
<span class="hs-linenum">204: </span>                       <span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">forall a. (UniqueZipper.Zipper a) -&gt; [a]</span><span class="hs-varid">down</span></a>  <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-layout">}</span>   <span class="hs-comment">-- elements to the right</span>
</pre>
<p>One well-known application of zippers is in the
<a href="http://xmonad.org/">XMonad</a> tiling window manager.
The set of windows being managed is stored in a zipper
similar to the above. The <code>focus</code> happily coincides with
the window currently in focus, and the <code>up</code> and <code>down</code>
to the list of windows that come before and after it.</p>
<p>One crucial invariant maintained by XMonad is that the zipper structure is
unique – i.e. each window appears at most once inside the zipper.</p>
<p>Lets see how we can state and check that all the values in a zipper are unique.</p>
<p>To start with, we would like to refine the <code>Zipper</code> data declaration
to express that both the lists in the structure are unique <strong>and</strong>
do not include <code>focus</code> in their values.</p>
<p>LiquidHaskell allow us to refine data type declarations, using the liquid comments.
So, apart from above definition definition for the <code>Zipper</code>, we add a refined one,
stating that the data structure always enjoys the desired properties.</p>
<pre><span class="hs-linenum">229: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">data</span> <span class="hs-conid">Zipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">Zipper</span> <span class="hs-layout">{</span> <span class="hs-varid">focus</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span>
<span class="hs-linenum">230: </span>                           <span class="hs-layout">,</span> <span class="hs-varid">up</span>    <span class="hs-keyglyph">::</span> <span class="hs-conid">UListDif</span> <span class="hs-varid">a</span> <span class="hs-varid">focus</span>
<span class="hs-linenum">231: </span>                           <span class="hs-layout">,</span> <span class="hs-varid">down</span>  <span class="hs-keyglyph">::</span> <span class="hs-conid">UListDif</span> <span class="hs-varid">a</span> <span class="hs-varid">focus</span><span class="hs-layout">}</span>
<span class="hs-linenum">232: </span>  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">233: </span>
<span class="hs-linenum">234: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">UListDif</span> <span class="hs-varid">a</span> <span class="hs-conid">N</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">UList</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varid">not</span> <span class="hs-layout">(</span><span class="hs-conid">ListElt</span> <span class="hs-conid">N</span> <span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">}</span> <span class="hs-keyword">@-}</span>
</pre>
<p>It is worth noting that the above is kind of <em>dependent</em> record in that
the types of the <code>up</code> and <code>down</code> fields depend on the value of the <code>focus</code>
field.</p>
<p>With this annotation any time we use a <code>Zipper</code> in the code LiquidHaskell
knows that the <code>up</code> and <code>down</code> components are unique lists
that do not include <code>focus</code>. Moreover, when a new <code>Zipper</code> is constructed
LiquidHaskell proves that this property holds, otherwise a liquid type
error is reported.</p>
<p>Hold on a minute!</p>
<p>The awake reader will have noticed that values inside the <code>Zipper</code> as
specified so far, are <em>not unique</em>, as nothing prevents a value from
appearing in both the <code>up</code> and the <code>down</code> components.</p>
<p>So, we have to specify that the contents of those two fields are <em>disjoint</em>.</p>
<p>One way to achieve this is by defining two measures <code>getUp</code> and <code>getDown</code>
that return the relevant parts of the <code>Zipper</code></p>
<pre><span class="hs-linenum">260: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">measure</span> <span class="hs-varid">getUp</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">forall</span> <span class="hs-varid">a</span><span class="hs-varop">.</span> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> 
<span class="hs-linenum">261: </span>    <span class="hs-varid">getUp</span> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">focus</span> <span class="hs-varid">up</span> <span class="hs-varid">down</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">up</span>
<span class="hs-linenum">262: </span>  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">263: </span>
<span class="hs-linenum">264: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">measure</span> <span class="hs-varid">getDown</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">forall</span> <span class="hs-varid">a</span><span class="hs-varop">.</span> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> 
<span class="hs-linenum">265: </span>    <span class="hs-varid">getDown</span> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">focus</span> <span class="hs-varid">up</span> <span class="hs-varid">down</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">down</span>
<span class="hs-linenum">266: </span>  <span class="hs-keyword">@-}</span>
</pre>
<p>With these definitions, we create a type alias <code>UZipper</code>
that states that the two list components are disjoint, and hence,
that we have a <em>unique zipper</em> with no duplicates.</p>
<pre><span class="hs-linenum">274: </span><span class="hs-keyword">{-@</span> 
<span class="hs-linenum">275: </span>  <span class="hs-keyword">type</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Zipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-conid">DisjointElts</span> <span class="hs-layout">(</span><span class="hs-varid">getUp</span> <span class="hs-varid">v</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">getDown</span> <span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">}</span> 
<span class="hs-linenum">276: </span>  <span class="hs-keyword">@-}</span>
</pre>
<h1 id="functions-on-unique-zippers">Functions on Unique Zippers</h1>
<p>Now that we have defined a unique zipper, it is straightforward for
LiquidHaskell to prove that operations on zippers preserve uniqueness.</p>
<h2 id="differentiation">Differentiation</h2>
<p>We can prove that a zipper that built from elements from a unique list is
indeed unique.</p>
<pre><span class="hs-linenum">293: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">differentiate</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">UList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Maybe</span> <span class="hs-layout">(</span><span class="hs-conid">UZipper</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">294: </span><a class="annot" href="#"><span class="annottext">forall a.
{VV : [a] | ((Set_emp (dups VV)))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class="hs-definition">differentiate</span></a> <span class="hs-conid">[]</span>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall a. {VV : (Data.Maybe.Maybe a) | (((isJust VV)) &lt;=&gt; false)}</span><span class="hs-conid">Nothing</span></a>
<span class="hs-linenum">295: </span><span class="hs-definition">differentiate</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}) | (((isJust VV)) &lt;=&gt; true) &amp;&amp; ((fromJust VV) == x)}</span><span class="hs-conid">Just</span></a> <a class="annot" href="#"><span class="annottext">({VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}))
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class="hs-varop">$</span></a> <a class="annot" href="#"><span class="annottext">focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class="hs-conid">Zipper</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-conid">[]</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a>
</pre>
<h2 id="integration">Integration</h2>
<p>And vice versa, all elements of a unique zipper yield a unique list.</p>
<pre><span class="hs-linenum">304: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">integrate</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">UList</span> <span class="hs-varid">a</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">305: </span><a class="annot" href="#"><span class="annottext">forall a.
{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : [a] | ((Set_emp (dups VV)))}</span><span class="hs-definition">integrate</span></a> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">x</span> <span class="hs-varid">l</span> <span class="hs-varid">r</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (listElts xs))}</span><span class="hs-varid">reverse</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == l) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">l</span></a> <a class="annot" href="#"><span class="annottext">xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; ys:{VV : [a] | ((Set_emp (Set_cap (listElts VV) (listElts xs)))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts ys)))}</span><span class="hs-varop">++</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == r) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">r</span></a>
</pre>
<p>Recall the types for <code>++</code> and <code>reverse</code> that we proved earlier – hover
your mouse over the identifiers to refresh your memory. Those types are
essential for establishing the type of <code>integrate</code>.</p>
<ul>
<li><p>By the definition of <code>UZipper</code> we know that <code>l</code> is a unique list
and that <code>x</code> is not an element of <code>l</code>.</p></li>
<li><p>Thus via the type of <code>reverse</code> we know that <code>reverse l</code> is also
unique and disjoint from <code>x</code> and <code>r</code>.</p></li>
<li><p>Finally, using the previously established type for <code>++</code>
LiquidHaskell can prove that since <code>x : r</code> is a unique
list with elements disjoint from <code>reverse l</code> the concatenation
of the two lists is also a unique list.</p></li>
</ul>
<p>With the exact same reasoning, we use the above list operations to create more zipper operations.</p>
<h2 id="reverse-1">Reverse</h2>
<p>We can reverse a unique zipper</p>
<pre><span class="hs-linenum">332: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">reverseZipper</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">333: </span><span class="hs-definition">reverseZipper</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Zipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Zipper</span> <span class="hs-varid">a</span>
<span class="hs-linenum">334: </span><a class="annot" href="#"><span class="annottext">forall a.
{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-definition">reverseZipper</span></a> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">t</span> <span class="hs-varid">ls</span> <span class="hs-varid">rs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class="hs-conid">Zipper</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == t)}</span><span class="hs-varid">t</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">rs</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">ls</span></a>
</pre>
<h2 id="shifting-focus">Shifting Focus</h2>
<p>More the focus up or down</p>
<pre><span class="hs-linenum">343: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">focusUp</span>   <span class="hs-keyglyph">::</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">344: </span><a class="annot" href="#"><span class="annottext">forall a.
{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-definition">focusUp</span></a> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">t</span> <span class="hs-conid">[]</span> <span class="hs-varid">rs</span><span class="hs-layout">)</span>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class="hs-conid">Zipper</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == x) &amp;&amp; (VV == x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == xs) &amp;&amp; (VV == xs) &amp;&amp; ((len VV) == (len xs)) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts xs))) &amp;&amp; ((listElts VV) == (listElts xs)) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-conid">[]</span></a> 
<span class="hs-linenum">345: </span>  <span class="hs-keyword">where</span> 
<span class="hs-linenum">346: </span>    <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | (VV == x)}</span><span class="hs-varid">x</span></a><span class="hs-conop">:</span><a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem x (listElts VV))))) &amp;&amp; (not (((Set_mem x (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == xs) &amp;&amp; ((len VV) == (len xs)) &amp;&amp; ((listElts VV) == (Set_cup (listElts xs) (listElts xs))) &amp;&amp; ((listElts VV) == (listElts xs)) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a><span class="hs-layout">)</span>                   <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((listElts VV) == (listElts xs))}</span><span class="hs-varid">reverse</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | (VV == t)}</span><span class="hs-varid">t</span></a><a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class="hs-conop">:</span></a><a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">rs</span></a><span class="hs-layout">)</span>
<span class="hs-linenum">347: </span>
<span class="hs-linenum">348: </span><span class="hs-definition">focusUp</span> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">t</span> <span class="hs-layout">(</span><span class="hs-varid">l</span><span class="hs-conop">:</span><span class="hs-varid">ls</span><span class="hs-layout">)</span> <span class="hs-varid">rs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class="hs-conid">Zipper</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == l)}</span><span class="hs-varid">l</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">ls</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | (VV == t)}</span><span class="hs-varid">t</span></a><a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class="hs-conop">:</span></a><a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem t (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">rs</span></a><span class="hs-layout">)</span>
<span class="hs-linenum">349: </span>
<span class="hs-linenum">350: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">focusDown</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">351: </span><a class="annot" href="#"><span class="annottext">forall a.
{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-definition">focusDown</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-varid">reverseZipper</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;q :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool, p :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool&gt;.
(x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; {VV : (UniqueZipper.Zipper a)&lt;p x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})
-&gt; (y:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
    -&gt; {VV : (UniqueZipper.Zipper a)&lt;q y&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})
-&gt; x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; exists [z:{VV : (UniqueZipper.Zipper a)&lt;q x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}].{VV : (UniqueZipper.Zipper a)&lt;p z&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-varop">.</span></a> <a class="annot" href="#"><span class="annottext">{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-varid">focusUp</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;q :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool, p :: (UniqueZipper.Zipper a)-&gt; (UniqueZipper.Zipper a)-&gt; Bool&gt;.
(x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; {VV : (UniqueZipper.Zipper a)&lt;p x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})
-&gt; (y:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
    -&gt; {VV : (UniqueZipper.Zipper a)&lt;q y&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})
-&gt; x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; exists [z:{VV : (UniqueZipper.Zipper a)&lt;q x&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}].{VV : (UniqueZipper.Zipper a)&lt;p z&gt; | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-varop">.</span></a> <a class="annot" href="#"><span class="annottext">{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}</span><span class="hs-varid">reverseZipper</span></a>
</pre>
<h2 id="filter-1">Filter</h2>
<p>Finally, using the filter operation on lists allows LiquidHaskell to prove
that filtering a zipper also preserves uniqueness.</p>
<pre><span class="hs-linenum">361: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">filterZipper</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">UZipper</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Maybe</span> <span class="hs-layout">(</span><span class="hs-conid">UZipper</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">362: </span><a class="annot" href="#"><span class="annottext">forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class="hs-definition">filterZipper</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <span class="hs-layout">(</span><span class="hs-conid">Zipper</span> <span class="hs-varid">f</span> <span class="hs-varid">ls</span> <span class="hs-varid">rs</span><span class="hs-layout">)</span> 
<span class="hs-linenum">363: </span>  <span class="hs-keyglyph">=</span> <span class="hs-keyword">case</span> <a class="annot" href="#"><span class="annottext">(a -&gt; (GHC.Types.Bool))
-&gt; xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts xs)))}</span><span class="hs-varid">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | (VV == f)}</span><span class="hs-varid">f</span></a><a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
y:a
-&gt; ys:[{VV : a&lt;p y&gt; | true}]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | ((dups VV) == (if ((Set_mem y (listElts ys))) then (Set_cup (Set_sng y) (dups ys)) else (dups ys))) &amp;&amp; ((len VV) == (1 + (len ys))) &amp;&amp; ((listElts VV) == (Set_cup (Set_sng y) (listElts ys)))}</span><span class="hs-conop">:</span></a><a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem f (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == rs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">rs</span></a><span class="hs-layout">)</span> <span class="hs-keyword">of</span>
<span class="hs-linenum">364: </span>      <span class="hs-varid">f'</span><span class="hs-conop">:</span><span class="hs-varid">rs'</span> <span class="hs-keyglyph">-&gt;</span> <a class="annot" href="#"><span class="annottext">x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}) | (((isJust VV)) &lt;=&gt; true) &amp;&amp; ((fromJust VV) == x)}</span><span class="hs-conid">Just</span></a> <a class="annot" href="#"><span class="annottext">({VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}))
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class="hs-varop">$</span></a> <a class="annot" href="#"><span class="annottext">focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class="hs-conid">Zipper</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == f')}</span><span class="hs-varid">f'</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">(a -&gt; (GHC.Types.Bool))
-&gt; xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts xs)))}</span><span class="hs-varid">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem f (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">ls</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == rs') &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">rs'</span></a>
<span class="hs-linenum">365: </span>      <span class="hs-conid">[]</span>     <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">case</span> <a class="annot" href="#"><span class="annottext">(a -&gt; (GHC.Types.Bool))
-&gt; xs:{VV : [a] | ((Set_emp (dups VV)))}
-&gt; {VV : [a] | ((Set_emp (dups VV))) &amp;&amp; ((Set_sub (listElts VV) (listElts xs)))}</span><span class="hs-varid">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">p</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (not (((Set_mem f (listElts VV))))) &amp;&amp; ((Set_emp (dups VV))) &amp;&amp; (VV == ls) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">ls</span></a> <span class="hs-keyword">of</span>                  
<span class="hs-linenum">366: </span>                  <span class="hs-varid">f'</span><span class="hs-conop">:</span><span class="hs-varid">ls'</span> <span class="hs-keyglyph">-&gt;</span> <a class="annot" href="#"><span class="annottext">x:{VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; {VV : (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}) | (((isJust VV)) &lt;=&gt; true) &amp;&amp; ((fromJust VV) == x)}</span><span class="hs-conid">Just</span></a> <a class="annot" href="#"><span class="annottext">({VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
 -&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}))
-&gt; {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))}
-&gt; (Data.Maybe.Maybe {VV : (UniqueZipper.Zipper a) | ((Set_emp (Set_cap (listElts (getUp VV)) (listElts (getDown VV)))))})</span><span class="hs-varop">$</span></a> <a class="annot" href="#"><span class="annottext">focus:a
-&gt; up:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; down:{VV : [a] | (not (((Set_mem focus (listElts VV))))) &amp;&amp; ((Set_emp (dups VV)))}
-&gt; {VV : (UniqueZipper.Zipper a) | ((getDown VV) == down) &amp;&amp; ((getUp VV) == up)}</span><span class="hs-conid">Zipper</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV == f')}</span><span class="hs-varid">f'</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV == ls') &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">ls'</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-conid">[]</span></a>
<span class="hs-linenum">367: </span>                  <span class="hs-conid">[]</span>     <span class="hs-keyglyph">-&gt;</span> <a class="annot" href="#"><span class="annottext">forall a. {VV : (Data.Maybe.Maybe a) | (((isJust VV)) &lt;=&gt; false)}</span><span class="hs-conid">Nothing</span></a>
</pre>
<h1 id="conclusion">Conclusion</h1>
<p>That’s all for now! This post illustrated</p>
<ol type="1">
<li><p>How we can use set theory to express properties the values of the list,
such as list uniqueness.</p></li>
<li><p>How we can use LuquidHaskell to prove that these properties are
preserved through list operations.</p></li>
<li><p>How we can embed this properties in complicated data structures that use
lists, such as a zipper.</p></li>
</ol>
<pre><span class="hs-linenum">390: </span><span class="hs-comment">-- TODO: Dummy function to provide qualifier hint.</span>
<span class="hs-linenum">391: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">q</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span>  <span class="hs-keyword">{v:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyword">|(not (Set_mem x (listElts v)))}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">392: </span><span class="hs-definition">q</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span>
<span class="hs-linenum">393: </span><a class="annot" href="#"><span class="annottext">forall a. x:a -&gt; {VV : [a] | (not (((Set_mem x (listElts VV)))))}</span><span class="hs-definition">q</span></a> <span class="hs-keyword">_</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a-&gt; a-&gt; Bool&gt;.
{VV : [{VV : a | false}]&lt;p&gt; | ((Set_emp (dups VV))) &amp;&amp; ((Set_emp (listElts VV))) &amp;&amp; ((len VV) == 0)}</span><span class="hs-conid">[]</span></a>
</pre>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2013/05/24/unique-zipper.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2013/05/24/unique-zipper.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>

        </div>
        <div id="footer">
        </div>
      <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="https://ucsd-progsys.github.io/liquidhaskell-blog/feed.xml" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/ranjitjhala" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://plus.google.com/u/0/106612421534244742464" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/ucsd-progsys" target="_blank">
                            <span class="fa-stack fa-lg">

                              <i class="fa fa-arrow-circle-o-down"></i>
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
		    
                </ul>
                <p class="copyright text-muted">
                
                  Copyright &copy; Niki Vazou 2016-17.
                
                  Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>,
                  template by <a href="http://lucumr.pocoo.org">Armin Ronacher</a>,
                  suggest improvements <a href="https://github.com/ucsd-progsys/liquidhaskell-blog/">here</a>.
                </p>
            </div>
        </div>
    </div>
</footer>


<!-- jQuery -->
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/jquery.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/spaceg.stylesheets.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/bootstrap.min.js"></script>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/anim.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/scripts.js"></script>

    </body>
</html>
