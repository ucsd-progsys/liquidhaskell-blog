<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    
    <head>
   <!-- Global Site Tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-106786912-1">
    </script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments)};
      gtag('js', new Date());
      gtag('config', 'UA-106786912-1');
    </script>


     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
 <!--
      loads the http over https ssl -
      welcome to my website!

	this theme is based off the Ice & Fire theme created by Lucas Gatsas
      https://www.twitter.com/LucasGatsas
      www.lucasgatsas.ch - switzerland.
  -->


<!-- Microsoft Internet Explorer documentMode compatMode setting IE Modus -->
<script type="text/javascript">
var IE = null;
if (window.navigator.appName == "Microsoft Internet Explorer") {
  if (document.documentMode) {

    IE = document.documentMode;
    } else {

        IE = 5;
          if (document.compatMode) {
      if (document.compatMode == "CSS1Compat")
      IE = 11;
      }
    }
  }
</script>

    <meta charset="utf-8">
    <!-- X-UA -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <link rel="author" title="Ranjit Jhala" href="http://ranjitjhala.github.io" />

    <meta name="google" content="notranslate" />
    <!-- Viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- index ROBOTS follow -->
    <meta name="robots" content="index, follow" />
    <!-- Site Desciption -->
    <meta name="description" content="LiquidHaskell Blog">
    <!-- Site Desciption -->
    <meta name="keywords" content="haskell, refinement types, liquid types, formal methods, type systems">
    <!-- Favicon -->
    <link rel="shortcut icon" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" type="image/x-icon" />
    <!-- Blog Title -->
    <title>LiquidHaskell</title>

    <!--     <title>{% if page.title %}{{ page.title }} - {{ site.title }}{% else %}{{ site.title }}{% endif %}</title>
-->
    <!-- Property Metas -->
    <meta property="og:image" content="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ix.png" />
    <meta property="og:title" content="LiquidHaskell Blog" />
    <meta property="og:site_name" content="LiquidHaskell Blog" />
    <!-- Canonical -->
    <link rel="canonical" href="{{ page.url | replace:'index.html','' | prepend: site.baseUrl | prepend: site.url }}">
    <!-- StyleSheet -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/bootstrap.min.css">
    <!-- <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/spaceg.stylesheets.css"> -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/ronacher.css" type="text/css">

    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/syntax.css">
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/liquid-light.css">

    <!-- Fonts
    <link href='https://fonts.googleapis.com/css?family=Merriweather:400,300,300italic,400italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900,400italic,700italic,900italic' rel='stylesheet' type='text/css'>
    -->

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>
	#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:url("/static/img/preloader.gif"); /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	ul, ol {margin-top: 0;margin-bottom: 10px;}
	.navbar-inverse {background-color: #FFF;border-color: #FFFFFF;}
</style>
<!--link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/prettify.css"-->
<style>
  /* HEADER IMAGE */
  header.intro-header {background: #6f5499;background: no-repeat center center;background-attachment: scroll;-webkit-background-size: cover;-moz-background-size: cover;background-size: cover;-o-background-size: cover;}

	/* Preloader */#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:; /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	li {list-style: none;}
            body.modal-open
            {overflow: hidden;padding-right: 0px;
        }
	article li {list-style: inherit;}
	article .figure {text-align: center}
    </style>
    <!-- end Loading front stylesheet here -->

    <link href="atom.xml" type="application/atom+xml" rel="alternate" title="LiquidHaskell-Blog ATOM Feed" />
    </head>

    <body>
	    
	<!-- 	
        <div id="preloader">
	    <div id="status">
	    </div>
	</div>  
	-->
	<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ucsd-progsys.github.io/liquidhaskell-blog" id="blog-title-left-top">LiquidHaskell</a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- <li class="dropdown">
                    <a href="#portfolioModal2" data-toggle="modal"><i class="fa fa-random" id="icon-top"></i></a>
                <ul class="dropdown-menu"></ul>
                </li>-->
                
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/blog.html">Blog</a></li>
                <li><a href="http://goto.ucsd.edu:8090/index.html#?demo=absref101.hs" target="_blank">Demo</a></li>
                <li><a href="http://ucsd-progsys.github.io/lh-workshop" target="_blank">Tutorial</a></li>
                <li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial" target="_blank">Book</a></li>
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html" target="_blank">About</a></li>
                <li><a href="http://www.github.com/ucsd-progsys/liquidhaskell" target="_blank"><i class="fa fa-twitter"></i>Download</a></li>
                <!--
                <li><a href="https://www.twitter.com/ranjitjhala" id="roundbutton" target="_blank"><i class="fa fa-twitter"></i>RanjitJhala</a></li>
                -->
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<!-- Portfolio Modals -->
    <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" class="img-responsive img-centered" alt title>
                            <p class="font-style-inline-small">
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow me</a>. <br>
                                <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                                <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>
                            </p>
                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<!-- Menu Modals Add New Sa.21.Feb.2015 03:22:25 -->
    <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <p class="font-style-inline-small">
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow</a>. <br>
                        <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                        <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>  <br>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/index.html">Home</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html">About</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/blog.html">Blog</a></li>
                    <li><a href="http://goto.ucsd.edu:8090/index.html#?demo=absref101.hs" target="_blank">Demo</a></li>
                    <li><a href="http://ucsd-progsys.github.io/lh-workshop" target="_blank">Tutorial</a></li>
                    <li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial" target="_blank">Book</a></li>
                    <li><a href="http://www.github.com/ucsd-progsys/liquidhaskell" target="_blank"><i class="fa fa-twitter"></i>Download</a></li>
                            </p>

                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


        <div id="content">
            <!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt title>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Abstracting Over Refinements</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala and Niki Vazou
		    
			Jun  3, 2013
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged 'abstract-refinements'." href="../../../../tags/abstract-refinements.html">abstract-refinements</a>
              
            </div>

            <br>
			            <p>We’ve seen all sorts of interesting invariants that can be expressed with
refinement predicates. For example, whether a divisor is <a href="../../../../blog/2013/01/01/refinement-types-101.lhs/">non-zero</a>,
the <a href="../../../../blog/2013/01/31/safely-catching-a-list-by-its-tail.lhs/">dimension</a> of lists, ensuring the safety of
<a href="../../../../blog/2013/03/04/bounding-vectors.lhs/">vector indices</a> and reasoning about the <a href="../../../../blog/2013/03/26/talking/about/sets.lhs/">set</a> of values
in containers and verifying their <a href="../../../../blog/2013/05/16/unique-zipper.lhs/">uniqueness</a>.
In each of these cases, we were working with <em>specific</em> refinement predicates
that described whatever property was of interest.</p>
<p>Today, (drumroll please), I want to unveil a brand new feature of
LiquidHaskell, which allows us to <em>abstract</em> over specific properties or
invariants, which significantly increases the expressiveness of the
system, whilst still allowing our friend the SMT solver to carry
out verification and inference automatically.</p>
<!-- more -->
<pre><span class="hs-linenum">30: </span>
<span class="hs-linenum">31: </span><span class="hs-keyword">module</span> <span class="hs-conid">MickeyMouse</span> <span class="hs-keyword">where</span>
<span class="hs-linenum">32: </span>
<span class="hs-linenum">33: </span><span class="hs-keyword">import</span> <span class="hs-conid">Language</span><span class="hs-varop">.</span><span class="hs-conid">Haskell</span><span class="hs-varop">.</span><span class="hs-conid">Liquid</span><span class="hs-varop">.</span><span class="hs-conid">Prelude</span> <span class="hs-layout">(</span><span class="hs-varid">isEven</span><span class="hs-layout">)</span>
</pre>
<h2 id="pin-the-specification-on-the-function">Pin The Specification On the Function</h2>
<p>Lets look at some tiny <em>mickey-mouse</em> examples to see why we may want
to abstract over refinements in the first place.</p>
<p>Consider the following monomorphic <code>max</code> function on <code>Int</code> values:</p>
<pre><span class="hs-linenum">45: </span><span class="hs-definition">maxInt</span>     <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span> 
<span class="hs-linenum">46: </span><a class="annot" href="#"><span class="annottext">forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.
{VV : (GHC.Types.Int)&lt;p&gt; | true}
-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}
-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}</span><span class="hs-definition">maxInt</span></a> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | ((papp1 p VV))}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | ((papp1 p VV))}</span><span class="hs-varid">y</span></a> <span class="hs-keyglyph">=</span> <span class="hs-keyword">if</span> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | ((papp1 p VV)) &amp;&amp; (VV == x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">x:{VV : (GHC.Types.Int) | ((papp1 p VV))}
-&gt; y:{VV : (GHC.Types.Int) | ((papp1 p VV))}
-&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; (x &lt;= y))}</span><span class="hs-varop">&lt;=</span></a> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | ((papp1 p VV)) &amp;&amp; (VV == y)}</span><span class="hs-varid">y</span></a> <span class="hs-keyword">then</span> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | ((papp1 p VV)) &amp;&amp; (VV == y)}</span><span class="hs-varid">y</span></a> <span class="hs-keyword">else</span> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | ((papp1 p VV)) &amp;&amp; (VV == x)}</span><span class="hs-varid">x</span></a> 
</pre>
We could give <code>maxInt</code> many, quite different and incomparable refinement types like
<pre><span class="hs-linenum">50: </span><span class="hs-definition">maxInt</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Int</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-varop">&gt;=</span> <span class="hs-num">0</span><span class="hs-layout">}</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Int</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-varop">&gt;=</span> <span class="hs-num">0</span><span class="hs-layout">}</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Int</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-varop">&gt;=</span> <span class="hs-num">0</span><span class="hs-layout">}</span>
</pre>
or
<pre><span class="hs-linenum">54: </span><span class="hs-definition">maxInt</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Int</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-varop">&lt;</span> <span class="hs-num">10</span><span class="hs-layout">}</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Int</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-varop">&lt;</span> <span class="hs-num">10</span><span class="hs-layout">}</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Int</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-varop">&lt;</span> <span class="hs-num">10</span><span class="hs-layout">}</span>
</pre>
or even
<pre><span class="hs-linenum">58: </span><span class="hs-definition">maxInt</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Int</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-conid">Even</span> <span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">}</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Int</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-conid">Even</span> <span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">}</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Int</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-conid">Even</span> <span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
</pre>
<p>All of the above are valid.</p>
<p>But which one is the <em>right</em> type?</p>
<p>At this point, you might be exasperated for one of two reasons.</p>
<p>First, the type enthusiasts among you may cry out – “What? Does this funny
refinement type system not have <strong>principal types</strong>?”</p>
<p>No. Or, to be precise, of course not!</p>
<p>Principal typing is a lovely feature that is one of the many
reasons why Hindley-Milner is such a delightful sweet spot.
Unfortunately, the moment one wants fancier specifications
one must tearfully kiss principal typing good bye.</p>
<p>Oh well.</p>
<p>Second, you may very well say, “Yes yes, does it even matter? Just pick
one and get on with it already!”</p>
<p>Unfortunately, it matters quite a bit.</p>
<p>Suppose we had a refined type describing valid RGB values:</p>
<pre><span class="hs-linenum">87: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">RGB</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-num">0</span> <span class="hs-varop">&lt;=</span> <span class="hs-varid">v</span><span class="hs-layout">)</span> <span class="hs-varop">&amp;&amp;</span> <span class="hs-layout">(</span><span class="hs-varid">v</span> <span class="hs-varop">&lt;</span> <span class="hs-num">256</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-layout">}</span> <span class="hs-keyword">@-}</span>
</pre>
<p>Now, if I wrote a function that selected the larger, that is to say, the
more intense, of two RGB values, I would certainly like to check that it
produced an RGB value!</p>
<pre><span class="hs-linenum">95: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">intenser</span>   <span class="hs-keyglyph">::</span> <span class="hs-conid">RGB</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">RGB</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">RGB</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">96: </span><a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}
-&gt; {VV : (GHC.Types.Int) | (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}
-&gt; {VV : (GHC.Types.Int) | (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}</span><span class="hs-definition">intenser</span></a> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}</span><span class="hs-varid">c1</span></a> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}</span><span class="hs-varid">c2</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.
{VV : (GHC.Types.Int)&lt;p&gt; | true}
-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}
-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}</span><span class="hs-varid">maxInt</span></a> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV == c1) &amp;&amp; (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}</span><span class="hs-varid">c1</span></a> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV == c2) &amp;&amp; (VV &lt; 256) &amp;&amp; (0 &lt;= VV)}</span><span class="hs-varid">c2</span></a>
</pre>
<p>Well, guess what. The first type (with <code>v &gt;= 0</code>) one would tell us that
the output was non-negative, losing the upper bound. The second type (with
<code>v &lt; 10</code>) would cause LiquidHaskell to bellyache about <code>maxInt</code> being
called with improper arguments – muttering darkly that an RGB value
is not necesarily less than <code>10</code>. As for the third type … well, you get the idea.</p>
<p>So alas, the choice of type <em>does</em> matter.</p>
If we were clairvoyant, we would give <code>maxInt</code> a type like
<pre><span class="hs-linenum">108: </span><span class="hs-definition">maxInt</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">RGB</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">RGB</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">RGB</span> 
</pre>
<p>but of course, that has its own issues. (“What? I have to write a
<em>separate</em> function for picking the larger of two <em>4</em> digit numbers?!”)</p>
<h2 id="defining-parametric-invariants">Defining Parametric Invariants</h2>
<p>Lets take a step back from the types, and turn to a spot of handwaving.</p>
<p>What’s <em>really</em> going on with <code>maxInt</code>?</p>
<p>Well, the function returns <em>one of</em> its two arguments <code>x</code> and <code>y</code>.</p>
<p>This means that if <em>both</em> arguments satisfy some property then the output
<em>must</em> satisfy that property, <em>regardless of what that property was!</em></p>
<p>To teach LiquidHaskell to understand this notion of “regardless of
property” we introduce the idea of <strong>abstracting over refinements</strong>
or, if you prefer, parameterizing a type over its refinements.</p>
<p>In particular, we type <code>maxInt</code> as</p>
<pre><span class="hs-linenum">133: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">maxInt</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">forall</span> <span class="hs-varop">&lt;</span><span class="hs-varid">p</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Prop</span><span class="hs-varop">&gt;.</span> <span class="hs-conid">Int</span><span class="hs-varop">&lt;</span><span class="hs-varid">p</span><span class="hs-varop">&gt;</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span><span class="hs-varop">&lt;</span><span class="hs-varid">p</span><span class="hs-varop">&gt;</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span><span class="hs-varop">&lt;</span><span class="hs-varid">p</span><span class="hs-varop">&gt;</span><span class="hs-keyword">@-}</span>
</pre>
<p>Here, the definition says explicitly: <em>for any property</em> <code>p</code> that is a
property of <code>Int</code>, the function takes two inputs each of which satisfy <code>p</code>
and returns an output that satisfies <code>p</code>. That is to say, <code>Int&lt;p&gt;</code> is
just an abbreviation for <code>{v:Int | (p v)}</code></p>
<p><strong>Digression: Whither Decidability?</strong>
At first glance, it may appear that these abstract <code>p</code> have taken us into
the realm of higher-order logics, where we must leave decidable checking
and our faithful SMT companion at that door, and instead roll up our
sleeves for interactive proofs (not that there’s anything wrong with that!)
Fortunately, that’s not the case. We simply encode abstract refinements <code>p</code>
as <em>uninterpreted function symbols</em> in the refinement logic.</p>
Uninterpreted functions are special symbols <code>p</code> which satisfy only the <em>congruence axiom</em>.
<pre><span class="hs-linenum">150: </span><span class="hs-keyword">forall</span> <span class="hs-conid">X</span><span class="hs-layout">,</span> <span class="hs-conid">Y</span><span class="hs-varop">.</span> <span class="hs-keyword">if</span> <span class="hs-layout">(</span><span class="hs-conid">X</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">Y</span><span class="hs-layout">)</span> <span class="hs-keyword">then</span>  <span class="hs-varid">p</span><span class="hs-layout">(</span><span class="hs-conid">X</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">p</span><span class="hs-layout">(</span><span class="hs-conid">Y</span><span class="hs-layout">)</span>
</pre>
<p>Happily, reasoning with such uninterpreted functions is quite decidable
(thanks to Ackermann, yes, <em>that</em> Ackermann) and actually rather efficient.
Thus, via SMT, LiquidHaskell happily verifies that <code>maxInt</code> indeed behaves
as advertised: the input types ensure that both <code>(p x)</code> and <code>(p y)</code> hold
and hence that the returned value in either branch of <code>maxInt</code> satisfies
the refinement <code>{v:Int | p(v)}</code>, thereby ensuring the output type.</p>
<p>By the same reasoning, we can define the <code>maximumInt</code> operator on lists:</p>
<pre><span class="hs-linenum">163: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">maximumInt</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">forall</span> <span class="hs-varop">&lt;</span><span class="hs-varid">p</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Prop</span><span class="hs-varop">&gt;.</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-conid">Int</span> <span class="hs-varop">&lt;</span><span class="hs-varid">p</span><span class="hs-varop">&gt;</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span> <span class="hs-varop">&lt;</span><span class="hs-varid">p</span><span class="hs-varop">&gt;</span><span class="hs-keyword">@-}</span>
<span class="hs-linenum">164: </span><a class="annot" href="#"><span class="annottext">forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.
[{VV : (GHC.Types.Int)&lt;p&gt; | true}]
-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}</span><span class="hs-definition">maximumInt</span></a> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">({VV : (GHC.Types.Int) | ((papp1 p VV))}
 -&gt; {VV : (GHC.Types.Int) | ((papp1 p VV))}
 -&gt; {VV : (GHC.Types.Int) | ((papp1 p VV))})
-&gt; {VV : (GHC.Types.Int) | ((papp1 p VV))}
-&gt; [{VV : (GHC.Types.Int) | ((papp1 p VV))}]
-&gt; {VV : (GHC.Types.Int) | ((papp1 p VV))}</span><span class="hs-varid">foldr</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.
{VV : (GHC.Types.Int)&lt;p&gt; | true}
-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}
-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}</span><span class="hs-varid">maxInt</span></a> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | ((papp1 p VV)) &amp;&amp; (VV == x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : (GHC.Types.Int) | ((papp1 p VV))}] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a>
</pre>
<h2 id="using-parametric-invariants">Using Parametric Invariants</h2>
<p>Its only useful to parametrize over invariants if there is some easy way
to <em>instantiate</em> the parameters.</p>
<p>Concretely, consider the function:</p>
<pre><span class="hs-linenum">176: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">maxEvens1</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-conid">Int</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span><span class="hs-conid">Int</span> <span class="hs-keyword">| (Even v)}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">177: </span><a class="annot" href="#"><span class="annottext">[(GHC.Types.Int)] -&gt; {VV : (GHC.Types.Int) | ((VV mod 2) == 0)}</span><span class="hs-definition">maxEvens1</span></a> <a class="annot" href="#"><span class="annottext">[(GHC.Types.Int)]</span><span class="hs-varid">xs</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall &lt;p :: (GHC.Types.Int)-&gt; Bool&gt;.
[{VV : (GHC.Types.Int)&lt;p&gt; | true}]
-&gt; {VV : (GHC.Types.Int)&lt;p&gt; | true}</span><span class="hs-varid">maximumInt</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\_ VV -&gt; ((VV mod 2) == 0)&gt; | (VV == xs'') &amp;&amp; ((len VV) == (1 + (len xs'))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs''</span></a>
<span class="hs-linenum">178: </span>  <span class="hs-keyword">where</span> 
<span class="hs-linenum">179: </span>    <a class="annot" href="#"><span class="annottext">{VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\_ VV -&gt; ((VV mod 2) == 0)&gt; | ((len VV) &gt;= 0)}</span><span class="hs-varid">xs'</span></a>      <span class="hs-keyglyph">=</span> <span class="hs-keyglyph">[</span> <a class="annot" href="#"><span class="annottext">(GHC.Types.Int)</span><span class="hs-varid">x</span></a> <span class="hs-keyglyph">|</span> <span class="hs-varid">x</span> <span class="hs-keyglyph">&lt;-</span> <a class="annot" href="#"><span class="annottext">{VV : [(GHC.Types.Int)] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a><span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">x:(GHC.Types.Int)
-&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; ((x mod 2) == 0))}</span><span class="hs-varid">isEven</span></a> <a class="annot" href="#"><span class="annottext">(GHC.Types.Int)</span><span class="hs-varid">x</span></a><span class="hs-keyglyph">]</span>
<span class="hs-linenum">180: </span>    <a class="annot" href="#"><span class="annottext">{VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\_ VV -&gt; ((VV mod 2) == 0)&gt; | ((len VV) == (1 + (len xs')))}</span><span class="hs-varid">xs''</span></a>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV == (0  :  int))}</span><span class="hs-num">0</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;p :: (GHC.Types.Int)-&gt; (GHC.Types.Int)-&gt; Bool&gt;.
y:{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}
-&gt; ys:[{VV : (GHC.Types.Int)&lt;p y&gt; | ((VV mod 2) == 0)}]&lt;p&gt;
-&gt; {VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;p&gt; | ((len VV) == (1 + (len ys)))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\_ VV -&gt; ((VV mod 2) == 0)&gt; | (VV == xs') &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs'</span></a>
</pre>
where the function <code>isEven</code> is from the Language.Haskell.Liquid.Prelude library:
<pre><span class="hs-linenum">184: </span><span class="hs-comment">{- isEven :: x:Int -&gt; {v:Bool | (Prop(v) &lt;=&gt; (Even x))} -}</span>
<span class="hs-linenum">185: </span><span class="hs-definition">isEven</span>   <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span>
<span class="hs-linenum">186: </span><span class="hs-definition">isEven</span> <span class="hs-varid">x</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">x</span> <span class="hs-varop">`mod`</span> <span class="hs-num">2</span> <span class="hs-varop">==</span> <span class="hs-num">0</span>
</pre>
<p>where the predicate <code>Even</code> is defined as</p>
<pre><span class="hs-linenum">192: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">Even</span> <span class="hs-conid">X</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-conid">X</span> <span class="hs-varid">mod</span> <span class="hs-num">2</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-num">0</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
</pre>
<p>To verify that <code>maxEvens1</code> returns an even number, LiquidHaskell</p>
<ol type="1">
<li><p>infers that the list <code>(0:xs')</code> has type <code>[{v:Int | (Even v)}]</code>,
that is, is a list of even numbers.</p></li>
<li><p>automatically instantiates the <em>refinement</em> parameter of
<code>maximumInt</code> with the concrete refinement <code>{\v -&gt; (Even v)}</code> and so</p></li>
<li><p>concludes that the value returned by <code>maxEvens1</code> is indeed <code>Even</code>.</p></li>
</ol>
<h2 id="parametric-invariants-and-type-classes">Parametric Invariants and Type Classes</h2>
<p>Ok, lets be honest, the above is clearly quite contrived. After all,
wouldn’t you write a <em>polymorphic</em> <code>max</code> function? And having done so,
we’d just get all the above goodness from old fashioned parametricity.</p>
That is to say, if we just wrote:
<pre><span class="hs-linenum">213: </span><span class="hs-definition">max</span>     <span class="hs-keyglyph">::</span> <span class="hs-keyword">forall</span> <span class="hs-varid">a</span><span class="hs-varop">.</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> 
<span class="hs-linenum">214: </span><span class="hs-definition">max</span> <span class="hs-varid">x</span> <span class="hs-varid">y</span> <span class="hs-keyglyph">=</span> <span class="hs-keyword">if</span> <span class="hs-varid">x</span> <span class="hs-varop">&gt;</span> <span class="hs-varid">y</span> <span class="hs-keyword">then</span> <span class="hs-varid">x</span> <span class="hs-keyword">else</span> <span class="hs-varid">y</span>
<span class="hs-linenum">215: </span>
<span class="hs-linenum">216: </span><span class="hs-definition">maximum</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">forall</span> <span class="hs-varid">a</span><span class="hs-varop">.</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>
<span class="hs-linenum">217: </span><span class="hs-definition">maximum</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">foldr</span> <span class="hs-varid">max</span> <span class="hs-varid">x</span> <span class="hs-varid">xs</span>
</pre>
<p>then we could happily <em>instantiate</em> the <code>a</code> with <code>{v:Int | v &gt; 0}</code> or
<code>{v:Int | (Even v)}</code> or whatever was needed at the call-site of <code>max</code>.
Sigh. Perhaps we are still pining for Hindley-Milner.</p>
Well, if this was an ML perhaps we could but in Haskell, the types would be
<pre><span class="hs-linenum">225: </span><span class="hs-layout">(</span><span class="hs-varop">&gt;</span><span class="hs-layout">)</span>     <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Ord</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span>
<span class="hs-linenum">226: </span><span class="hs-definition">max</span>     <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Ord</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>
<span class="hs-linenum">227: </span><span class="hs-definition">maximum</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Ord</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>
</pre>
<p>Our first temptation may be to furtively look over our shoulders, and
convinced no one was watching, just pretend that funny <code>(Ord a)</code> business
was not there, and quietly just treat <code>maximum</code> as <code>[a] -&gt; a</code> and summon
parametricity.</p>
<p>That would be most unwise. We may get away with it with the harmless <code>Ord</code> but what of, say, <code>Num</code>.</p>
Clearly a function
<pre><span class="hs-linenum">238: </span><span class="hs-definition">numCrunch</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Num</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>
</pre>
<p>is not going to necessarily return one of its inputs as an output.
Thus, it is laughable to believe that <code>numCrunch</code> would, if given
a list of of even (or positive, negative, prime, RGB, …) integers,
return a even (or positive, negative, prime, RGB, …) integer, since
the function might add or subtract or multiply or do other unspeakable
things to the numbers in order to produce the output value.</p>
<p>And yet, typeclasses are everywhere.</p>
<p>How could we possibly verify that</p>
<pre><span class="hs-linenum">253: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">maxEvens2</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-conid">Int</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span><span class="hs-conid">Int</span> <span class="hs-keyword">| (Even v) }</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">254: </span><a class="annot" href="#"><span class="annottext">[(GHC.Types.Int)] -&gt; {VV : (GHC.Types.Int) | ((VV mod 2) == 0)}</span><span class="hs-definition">maxEvens2</span></a> <a class="annot" href="#"><span class="annottext">[(GHC.Types.Int)]</span><span class="hs-varid">xs</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">[{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]
-&gt; {VV : (GHC.Types.Int) | ((VV mod 2) == 0)}</span><span class="hs-varid">maximumPoly</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\_ VV -&gt; ((VV mod 2) == 0)&gt; | (VV == xs'') &amp;&amp; ((len VV) == (1 + (len xs'))) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs''</span></a>
<span class="hs-linenum">255: </span>  <span class="hs-keyword">where</span> 
<span class="hs-linenum">256: </span>     <a class="annot" href="#"><span class="annottext">{VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\_ VV -&gt; ((VV mod 2) == 0)&gt; | ((len VV) &gt;= 0)}</span><span class="hs-varid">xs'</span></a>     <span class="hs-keyglyph">=</span> <span class="hs-keyglyph">[</span> <a class="annot" href="#"><span class="annottext">(GHC.Types.Int)</span><span class="hs-varid">x</span></a> <span class="hs-keyglyph">|</span> <span class="hs-varid">x</span> <span class="hs-keyglyph">&lt;-</span> <a class="annot" href="#"><span class="annottext">{VV : [(GHC.Types.Int)] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a><span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">x:(GHC.Types.Int)
-&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; ((x mod 2) == 0))}</span><span class="hs-varid">isEven</span></a> <a class="annot" href="#"><span class="annottext">(GHC.Types.Int)</span><span class="hs-varid">x</span></a><span class="hs-keyglyph">]</span>
<span class="hs-linenum">257: </span>     <a class="annot" href="#"><span class="annottext">{VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\_ VV -&gt; ((VV mod 2) == 0)&gt; | ((len VV) == (1 + (len xs')))}</span><span class="hs-varid">xs''</span></a>    <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Int) | (VV == (0  :  int))}</span><span class="hs-num">0</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;p :: (GHC.Types.Int)-&gt; (GHC.Types.Int)-&gt; Bool&gt;.
y:{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}
-&gt; ys:[{VV : (GHC.Types.Int)&lt;p y&gt; | ((VV mod 2) == 0)}]&lt;p&gt;
-&gt; {VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;p&gt; | ((len VV) == (1 + (len ys)))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : (GHC.Types.Int) | ((VV mod 2) == 0)}]&lt;\_ VV -&gt; ((VV mod 2) == 0)&gt; | (VV == xs') &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs'</span></a>
</pre>
<p>where the helpers were in the usual <code>Ord</code> style?</p>
<pre><span class="hs-linenum">263: </span><span class="hs-definition">maximumPoly</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Ord</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span>
<span class="hs-linenum">264: </span><a class="annot" href="#"><span class="annottext">forall a &lt;p :: a-&gt; Bool&gt;.
(GHC.Classes.Ord a) =&gt;
[{VV : a&lt;p&gt; | true}] -&gt; {VV : a&lt;p&gt; | true}</span><span class="hs-definition">maximumPoly</span></a> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">({VV : a | ((papp1 p VV))}
 -&gt; {VV : a | ((papp1 p VV))} -&gt; {VV : a | ((papp1 p VV))})
-&gt; {VV : a | ((papp1 p VV))}
-&gt; [{VV : a | ((papp1 p VV))}]
-&gt; {VV : a | ((papp1 p VV))}</span><span class="hs-varid">foldr</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | ((papp1 p VV))}
-&gt; {VV : a | ((papp1 p VV))} -&gt; {VV : a | ((papp1 p VV))}</span><span class="hs-varid">maxPoly</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | ((papp1 p VV)) &amp;&amp; (VV == x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : a | ((papp1 p VV))}] | (VV == xs) &amp;&amp; ((len VV) &gt;= 0)}</span><span class="hs-varid">xs</span></a>
<span class="hs-linenum">265: </span>
<span class="hs-linenum">266: </span><span class="hs-definition">maxPoly</span>     <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Ord</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> 
<span class="hs-linenum">267: </span><a class="annot" href="#"><span class="annottext">forall a &lt;p :: a-&gt; Bool&gt;.
(GHC.Classes.Ord a) =&gt;
{VV : a&lt;p&gt; | true} -&gt; {VV : a&lt;p&gt; | true} -&gt; {VV : a&lt;p&gt; | true}</span><span class="hs-definition">maxPoly</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | ((papp1 p VV))}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | ((papp1 p VV))}</span><span class="hs-varid">y</span></a> <span class="hs-keyglyph">=</span> <span class="hs-keyword">if</span> <a class="annot" href="#"><span class="annottext">{VV : a | ((papp1 p VV)) &amp;&amp; (VV == x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">x:{VV : a | ((papp1 p VV))}
-&gt; y:{VV : a | ((papp1 p VV))}
-&gt; {VV : (GHC.Types.Bool) | (((Prop VV)) &lt;=&gt; (x &lt;= y))}</span><span class="hs-varop">&lt;=</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | ((papp1 p VV)) &amp;&amp; (VV == y)}</span><span class="hs-varid">y</span></a> <span class="hs-keyword">then</span> <a class="annot" href="#"><span class="annottext">{VV : a | ((papp1 p VV)) &amp;&amp; (VV == y)}</span><span class="hs-varid">y</span></a> <span class="hs-keyword">else</span> <a class="annot" href="#"><span class="annottext">{VV : a | ((papp1 p VV)) &amp;&amp; (VV == x)}</span><span class="hs-varid">x</span></a>
</pre>
<p>The answer: abstract refinements.</p>
<p>First, via the same analysis as the monomorphic <code>Int</code> case, LiquidHaskell
establishes that</p>
<pre><span class="hs-linenum">276: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">maxPoly</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">forall</span> <span class="hs-varop">&lt;</span><span class="hs-varid">p</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Prop</span><span class="hs-varop">&gt;.</span> 
<span class="hs-linenum">277: </span>                 <span class="hs-layout">(</span><span class="hs-conid">Ord</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">a</span><span class="hs-varop">&lt;</span><span class="hs-varid">p</span><span class="hs-varop">&gt;</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">y</span><span class="hs-conop">:</span><span class="hs-varid">a</span><span class="hs-varop">&lt;</span><span class="hs-varid">p</span><span class="hs-varop">&gt;</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span><span class="hs-varop">&lt;</span><span class="hs-varid">p</span><span class="hs-varop">&gt;</span> <span class="hs-keyword">@-}</span>
</pre>
<p>and hence, that</p>
<pre><span class="hs-linenum">283: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">maximumPoly</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">forall</span> <span class="hs-varop">&lt;</span><span class="hs-varid">p</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Prop</span><span class="hs-varop">&gt;.</span> 
<span class="hs-linenum">284: </span>                     <span class="hs-layout">(</span><span class="hs-conid">Ord</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-varop">&lt;</span><span class="hs-varid">p</span><span class="hs-varop">&gt;</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span><span class="hs-varop">&lt;</span><span class="hs-varid">p</span><span class="hs-varop">&gt;</span>     <span class="hs-keyword">@-}</span>
</pre>
<p>Second, at the call-site for <code>maximumPoly</code> in <code>maxEvens2</code> LiquidHaskell
instantiates the type variable <code>a</code> with <code>Int</code>, and the abstract refinement
parameter <code>p</code> with <code>{\v -&gt; (Even v)}</code> after which, the verification proceeds
as described earlier (for the <code>Int</code> case).</p>
<h2 id="and-so">And So</h2>
<p>If you’ve courageously slogged through to this point then you’ve learnt
that</p>
<ol type="1">
<li><p>Sometimes, choosing the right type can be quite difficult!</p></li>
<li><p>But fortunately, with <em>abstract refinements</em> we needn’t choose, but
can write types that are parameterized over the actual concrete
invariants or refinements, which</p></li>
<li><p>Can be instantiated at the call-sites i.e. users of the functions.</p></li>
</ol>
<p>We started with some really frivolous examples, but buckle your seatbelt
and hold on tight, because we’re going to see some rather nifty things that
this new technique makes possible, including induction, reasoning about
memoizing functions, and <em>ordering</em> and <em>sorting</em> data. Stay tuned.</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2013/06/03/abstracting-over-refinements.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2013/06/03/abstracting-over-refinements.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>

        </div>
        <div id="footer">
        </div>
      <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="https://ucsd-progsys.github.io/liquidhaskell-blog/feed.xml" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/ranjitjhala" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://plus.google.com/u/0/106612421534244742464" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/ucsd-progsys" target="_blank">
                            <span class="fa-stack fa-lg">

                              <i class="fa fa-arrow-circle-o-down"></i>
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
		    
                </ul>
                <p class="copyright text-muted">
                
                  Copyright &copy; Ranjit Jhala and Niki Vazou 2016-17.
                
                  Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>,
                  template by <a href="http://lucumr.pocoo.org">Armin Ronacher</a>,
                  suggest improvements <a href="https://github.com/ucsd-progsys/liquidhaskell-blog/">here</a>.
                </p>
            </div>
        </div>
    </div>
</footer>


<!-- jQuery -->
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/jquery.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/spaceg.stylesheets.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/bootstrap.min.js"></script>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/anim.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/scripts.js"></script>

    </body>
</html>
