<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    
    <head>
   <!-- Global Site Tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-106786912-1">
    </script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments)};
      gtag('js', new Date());
      gtag('config', 'UA-106786912-1');
    </script>


     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
 <!--
      loads the http over https ssl -
      welcome to my website!

	this theme is based off the Ice & Fire theme created by Lucas Gatsas
      https://www.twitter.com/LucasGatsas
      www.lucasgatsas.ch - switzerland.
  -->


<!-- Microsoft Internet Explorer documentMode compatMode setting IE Modus -->
<script type="text/javascript">
var IE = null;
if (window.navigator.appName == "Microsoft Internet Explorer") {
  if (document.documentMode) {

    IE = document.documentMode;
    } else {

        IE = 5;
          if (document.compatMode) {
      if (document.compatMode == "CSS1Compat")
      IE = 11;
      }
    }
  }
</script>

    <meta charset="utf-8">
    <!-- X-UA -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <link rel="author" title="Ranjit Jhala" href="http://ranjitjhala.github.io" />

    <meta name="google" content="notranslate" />
    <!-- Viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- index ROBOTS follow -->
    <meta name="robots" content="index, follow" />
    <!-- Site Desciption -->
    <meta name="description" content="LiquidHaskell Blog">
    <!-- Site Desciption -->
    <meta name="keywords" content="haskell, refinement types, liquid types, formal methods, type systems">
    <!-- Favicon -->
    <link rel="shortcut icon" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" type="image/x-icon" />
    <!-- Blog Title -->
    <title>LiquidHaskell</title>

    <!--     <title>{% if page.title %}{{ page.title }} - {{ site.title }}{% else %}{{ site.title }}{% endif %}</title>
-->
    <!-- Property Metas -->
    <meta property="og:image" content="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ix.png" />
    <meta property="og:title" content="LiquidHaskell Blog" />
    <meta property="og:site_name" content="LiquidHaskell Blog" />
    <!-- Canonical -->
    <link rel="canonical" href="{{ page.url | replace:'index.html','' | prepend: site.baseUrl | prepend: site.url }}">
    <!-- StyleSheet -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/bootstrap.min.css">
    <!-- <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/spaceg.stylesheets.css"> -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/ronacher.css" type="text/css">

    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/syntax.css">
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/liquid-light.css">

    <!-- Fonts
    <link href='https://fonts.googleapis.com/css?family=Merriweather:400,300,300italic,400italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900,400italic,700italic,900italic' rel='stylesheet' type='text/css'>
    -->

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>
	#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:url("/static/img/preloader.gif"); /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	ul, ol {margin-top: 0;margin-bottom: 10px;}
	.navbar-inverse {background-color: #FFF;border-color: #FFFFFF;}
</style>
<!--link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/prettify.css"-->
<style>
  /* HEADER IMAGE */
  header.intro-header {background: #6f5499;background: no-repeat center center;background-attachment: scroll;-webkit-background-size: cover;-moz-background-size: cover;background-size: cover;-o-background-size: cover;}

	/* Preloader */#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:; /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	li {list-style: none;}
            body.modal-open
            {overflow: hidden;padding-right: 0px;
        }
	article li {list-style: inherit;}
	article .figure {text-align: center}
    </style>
    <!-- end Loading front stylesheet here -->

    <link href="atom.xml" type="application/atom+xml" rel="alternate" title="LiquidHaskell-Blog ATOM Feed" />
    </head>

    <body>
	    
	<!-- 	
        <div id="preloader">
	    <div id="status">
	    </div>
	</div>  
	-->
	<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ucsd-progsys.github.io/liquidhaskell-blog" id="blog-title-left-top">LiquidHaskell</a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- <li class="dropdown">
                    <a href="#portfolioModal2" data-toggle="modal"><i class="fa fa-random" id="icon-top"></i></a>
                <ul class="dropdown-menu"></ul>
                </li>-->
                
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/blog.html">Blog</a></li>
                <li><a href="http://goto.ucsd.edu:8090/index.html#?demo=TalkingAboutSets.hs" target="_blank">Demo</a></li>
                <li><a href="http://ucsd-progsys.github.io/lh-workshop" target="_blank">Tutorial</a></li>
                <li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial" target="_blank">Book</a></li>
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html" target="_blank">About</a></li>
                <li><a href="http://www.github.com/ucsd-progsys/liquidhaskell" target="_blank"><i class="fa fa-twitter"></i>Download</a></li>
                <!--
                <li><a href="https://www.twitter.com/ranjitjhala" id="roundbutton" target="_blank"><i class="fa fa-twitter"></i>RanjitJhala</a></li>
                -->
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<!-- Portfolio Modals -->
    <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" class="img-responsive img-centered" alt title>
                            <p class="font-style-inline-small">
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow me</a>. <br>
                                <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                                <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>
                            </p>
                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<!-- Menu Modals Add New Sa.21.Feb.2015 03:22:25 -->
    <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <p class="font-style-inline-small">
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow</a>. <br>
                        <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                        <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>  <br>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/index.html">Home</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html">About</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/blog.html">Blog</a></li>
                    <li><a href="http://goto.ucsd.edu:8090/index.html#?demo=TalkingAboutSets.hs" target="_blank">Demo</a></li>
                    <li><a href="http://ucsd-progsys.github.io/lh-workshop" target="_blank">Tutorial</a></li>
                    <li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial" target="_blank">Book</a></li>
                    <li><a href="http://www.github.com/ucsd-progsys/liquidhaskell" target="_blank"><i class="fa fa-twitter"></i>Download</a></li>
                            </p>

                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


        <div id="content">
            <!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt title>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Talking About Sets</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			Mar 26, 2013
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged 'basic'." href="../../../../tags/basic.html">basic</a>, <a title="All pages tagged 'measures'." href="../../../../tags/measures.html">measures</a>, <a title="All pages tagged 'sets'." href="../../../../tags/sets.html">sets</a>
              
            </div>

            <br>
			            <p>In the posts so far, we’ve seen how LiquidHaskell allows you to use SMT
solvers to specify and verify <em>numeric</em> invariants – denominators
that are non-zero, integer indices that are within the range of an
array, vectors that have the right number of dimensions and so on.</p>
<p>However, SMT solvers are not limited to numbers, and in fact, support
rather expressive logics. In the next couple of posts, let’s see how
LiquidHaskell uses SMT to talk about <strong>sets of values</strong>, for example,
the contents of a list, and to specify and verify properties about
those sets.</p>
<!-- more -->
<pre><span class="hs-linenum">27: </span><span class="hs-keyword">module</span> <span class="hs-conid">TalkingAboutSets</span> <span class="hs-keyword">where</span>
<span class="hs-linenum">28: </span>
<span class="hs-linenum">29: </span><span class="hs-keyword">import</span> <span class="hs-conid">Data</span><span class="hs-varop">.</span><span class="hs-conid">Set</span> <span class="hs-varid">hiding</span> <span class="hs-layout">(</span><span class="hs-varid">filter</span><span class="hs-layout">,</span> <span class="hs-varid">split</span><span class="hs-layout">)</span>
<span class="hs-linenum">30: </span><span class="hs-keyword">import</span> <span class="hs-conid">Prelude</span>  <span class="hs-varid">hiding</span> <span class="hs-layout">(</span><span class="hs-varid">reverse</span><span class="hs-layout">,</span> <span class="hs-varid">filter</span><span class="hs-layout">)</span>
<span class="hs-linenum">31: </span>
</pre>
<h1 id="talking-about-sets-in-logic">Talking about Sets (In Logic)</h1>
<p>First, we need a way to talk about sets in the refinement logic. We could
roll our own special Haskell type, but why not just use the <code>Set a</code> type
from <code>Data.Set</code>.</p>
<p>The <code>import Data.Set</code> , also instructs LiquidHaskell to import in the various
specifications defined for the <code>Data.Set</code> module that we have <em>predefined</em>
in <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/Data/Set.spec">Data/Set.spec</a></p>
Let’s look at the specifications.
<pre><span class="hs-linenum">46: </span><span class="hs-keyword">module</span> <span class="hs-varid">spec</span> <span class="hs-conid">Data</span><span class="hs-varop">.</span><span class="hs-conid">Set</span> <span class="hs-keyword">where</span>
<span class="hs-linenum">47: </span>
<span class="hs-linenum">48: </span><span class="hs-definition">embed</span> <span class="hs-conid">Set</span> <span class="hs-keyword">as</span> <span class="hs-conid">Set_Set</span>
</pre>
<p>The <code>embed</code> directive tells LiquidHaskell to model the <strong>Haskell</strong>
type constructor <code>Set</code> with the <strong>SMT</strong> type constructor <code>Set_Set</code>.</p>
First, we define the logical operators (i.e. <code>measure</code>s)
<pre><span class="hs-linenum">55: </span><span class="hs-definition">measure</span> <span class="hs-conid">Set_sng</span>  <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span>                    <span class="hs-comment">-- ^ singleton</span>
<span class="hs-linenum">56: </span><span class="hs-definition">measure</span> <span class="hs-conid">Set_cup</span>  <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span>   <span class="hs-comment">-- ^ union</span>
<span class="hs-linenum">57: </span><span class="hs-definition">measure</span> <span class="hs-conid">Set_cap</span>  <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span>   <span class="hs-comment">-- ^ intersection</span>
<span class="hs-linenum">58: </span><span class="hs-definition">measure</span> <span class="hs-conid">Set_dif</span>  <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span>   <span class="hs-comment">-- ^ difference </span>
</pre>
Next, we define predicates on <code>Set</code>s
<pre><span class="hs-linenum">62: </span><span class="hs-definition">measure</span> <span class="hs-conid">Set_emp</span>  <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Prop</span>                 <span class="hs-comment">-- ^ emptiness</span>
<span class="hs-linenum">63: </span><span class="hs-definition">measure</span> <span class="hs-conid">Set_mem</span>  <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Prop</span>            <span class="hs-comment">-- ^ membership</span>
<span class="hs-linenum">64: </span><span class="hs-definition">measure</span> <span class="hs-conid">Set_sub</span>  <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Prop</span>      <span class="hs-comment">-- ^ inclusion </span>
</pre>
<h2 id="interpreted-operations">Interpreted Operations</h2>
<p>The above operators are <em>interpreted</em> by the SMT solver.</p>
That is, just like the SMT solver “knows that”
<pre><span class="hs-linenum">74: </span><span class="hs-num">2</span> <span class="hs-varop">+</span> <span class="hs-num">2</span> <span class="hs-varop">==</span> <span class="hs-num">4</span>
</pre>
the SMT solver also “knows that”
<pre><span class="hs-linenum">78: </span><span class="hs-layout">(</span><span class="hs-conid">Set_sng</span> <span class="hs-num">1</span><span class="hs-layout">)</span> <span class="hs-varop">==</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cap</span> <span class="hs-layout">(</span><span class="hs-conid">Set_sng</span> <span class="hs-num">1</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cup</span> <span class="hs-layout">(</span><span class="hs-conid">Set_sng</span> <span class="hs-num">2</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-conid">Set_sng</span> <span class="hs-num">1</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">)</span>
</pre>
<p>This is because, the above formulas belong to a decidable Theory of Sets
which can be reduced to McCarthy’s more general <a href="http://www-formal.stanford.edu/jmc/towards.ps">Theory of Arrays</a>.
See <a href="http://research.microsoft.com/en-us/um/people/leonardo/fmcad09.pdf">this recent paper</a> if you want to learn more about how modern SMT
solvers “know” the above equality holds…</p>
<h1 id="talking-about-sets-in-code">Talking about Sets (In Code)</h1>
<p>Of course, the above operators exist purely in the realm of the
refinement logic, beyond the grasp of the programmer.</p>
<p>To bring them down (or up, or left or right) within reach of Haskell code,
we can simply <em>assume</em> that the various public functions in <code>Data.Set</code> do
the <em>Right Thing</em> i.e. produce values that reflect the logical set operations:</p>
First, the functions that create <code>Set</code> values
<pre><span class="hs-linenum">97: </span><span class="hs-definition">empty</span>     <span class="hs-keyglyph">::</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-conid">Set_emp</span> <span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
<span class="hs-linenum">98: </span><span class="hs-definition">singleton</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">Set_sng</span> <span class="hs-varid">x</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
</pre>
Next, the functions that operate on elements and <code>Set</code> values
<pre><span class="hs-linenum">102: </span><span class="hs-definition">insert</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Ord</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">a</span> 
<span class="hs-linenum">103: </span>                <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> 
<span class="hs-linenum">104: </span>                <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cup</span> <span class="hs-varid">xs</span> <span class="hs-layout">(</span><span class="hs-conid">Set_sng</span> <span class="hs-varid">x</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
<span class="hs-linenum">105: </span>
<span class="hs-linenum">106: </span><span class="hs-definition">delete</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Ord</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">a</span> 
<span class="hs-linenum">107: </span>                <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> 
<span class="hs-linenum">108: </span>                <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">Set_dif</span> <span class="hs-varid">xs</span> <span class="hs-layout">(</span><span class="hs-conid">Set_sng</span> <span class="hs-varid">x</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
</pre>
Then, the binary <code>Set</code> operators
<pre><span class="hs-linenum">112: </span><span class="hs-definition">union</span>        <span class="hs-keyglyph">::</span> <span class="hs-conid">Ord</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> 
<span class="hs-linenum">113: </span>                      <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">ys</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> 
<span class="hs-linenum">114: </span>                      <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cup</span> <span class="hs-varid">xs</span> <span class="hs-varid">ys</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
<span class="hs-linenum">115: </span>
<span class="hs-linenum">116: </span><span class="hs-definition">intersection</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Ord</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> 
<span class="hs-linenum">117: </span>                      <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">ys</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> 
<span class="hs-linenum">118: </span>                      <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cap</span> <span class="hs-varid">xs</span> <span class="hs-varid">ys</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
<span class="hs-linenum">119: </span>
<span class="hs-linenum">120: </span><span class="hs-definition">difference</span>   <span class="hs-keyglyph">::</span> <span class="hs-conid">Ord</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> 
<span class="hs-linenum">121: </span>                      <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">ys</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> 
<span class="hs-linenum">122: </span>                      <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">Set_dif</span> <span class="hs-varid">xs</span> <span class="hs-varid">ys</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
</pre>
And finally, the predicates on <code>Set</code> values:
<pre><span class="hs-linenum">126: </span><span class="hs-definition">isSubsetOf</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">Ord</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> 
<span class="hs-linenum">127: </span>                    <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">ys</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> 
<span class="hs-linenum">128: </span>                    <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Bool</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-conid">Prop</span> <span class="hs-varid">v</span><span class="hs-layout">)</span> <span class="hs-varop">&lt;=&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set_sub</span> <span class="hs-varid">xs</span> <span class="hs-varid">ys</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
<span class="hs-linenum">129: </span>
<span class="hs-linenum">130: </span><span class="hs-definition">member</span>     <span class="hs-keyglyph">::</span> <span class="hs-conid">Ord</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">a</span> 
<span class="hs-linenum">131: </span>                    <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> 
<span class="hs-linenum">132: </span>                    <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Bool</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-conid">Prop</span> <span class="hs-varid">v</span><span class="hs-layout">)</span> <span class="hs-varop">&lt;=&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set_mem</span> <span class="hs-varid">x</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
</pre>
<p><strong>Note:</strong> Of course we shouldn’t and needn’t really <em>assume</em>, but should and
will <em>guarantee</em> that the functions from <code>Data.Set</code> implement the above types.
But thats a story for another day…</p>
<h1 id="proving-theorems-with-liquidhaskell">Proving Theorems With LiquidHaskell</h1>
<p>OK, let’s take our refined operators from <code>Data.Set</code> out for a spin!
One pleasant consequence of being able to precisely type the operators
from <code>Data.Set</code> is that we have a pleasant interface for using the SMT
solver to <em>prove theorems</em> about sets, while remaining firmly rooted in
Haskell.</p>
<p>First, let’s write a simple function that asserts that its input is <code>True</code></p>
<pre><span class="hs-linenum">151: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">boolAssert</span> <span class="hs-keyglyph">::</span> <span class="hs-keyword">{v:</span> <span class="hs-conid">Bool</span> <span class="hs-keyword">| (Prop v)}</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span><span class="hs-conid">Bool</span> <span class="hs-keyword">| (Prop v)}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">152: </span><a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Bool) | (? Prop([VV]))}
-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV]))}</span><span class="hs-definition">boolAssert</span></a> <span class="hs-conid">True</span>   <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Bool) | (? Prop([VV])),(VV = True)}</span><span class="hs-conid">True</span></a>
<span class="hs-linenum">153: </span><span class="hs-definition">boolAssert</span> <span class="hs-conid">False</span>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">[(GHC.Types.Char)] -&gt; {VV : (GHC.Types.Bool) | false}</span><span class="hs-varid">error</span></a> <a class="annot" href="#"><span class="annottext">{VV : [(GHC.Types.Char)] | (len([VV]) &gt;= 0)}</span><span class="hs-str">"boolAssert: False? Never!"</span></a>
</pre>
<p>Now, we can use <code>boolAssert</code> to write some simple properties. (Yes, these do
indeed look like QuickCheck properties – but here, instead of generating
tests and executing the code, the type system is proving to us that the
properties will <em>always</em> evaluate to <code>True</code>)</p>
<p>Let’s check that <code>intersection</code> is commutative …</p>
<pre><span class="hs-linenum">164: </span><a class="annot" href="#"><span class="annottext">forall a.
(GHC.Classes.Ord a) =&gt;
(Data.Set.Base.Set a) -&gt; (Data.Set.Base.Set a) -&gt; (GHC.Types.Bool)</span><span class="hs-definition">prop_cap_comm</span></a> <a class="annot" href="#"><span class="annottext">(Data.Set.Base.Set a)</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">(Data.Set.Base.Set a)</span><span class="hs-varid">y</span></a> 
<span class="hs-linenum">165: </span>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Bool) | (? Prop([VV]))}
-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV]))}</span><span class="hs-varid">boolAssert</span></a> 
<span class="hs-linenum">166: </span>  <a class="annot" href="#"><span class="annottext">({VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}
 -&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)})
-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}
-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}</span><span class="hs-varop">$</span></a> <a class="annot" href="#"><span class="annottext">(GHC.Types.Bool)</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">xs:(Data.Set.Base.Set a)
-&gt; ys:(Data.Set.Base.Set a)
-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cap([xs; ys]))}</span><span class="hs-varop">`intersection`</span></a> <a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = y)}</span><span class="hs-varid">y</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">GHC.Classes.Eq (Data.Set.Base.Set a)</span><span class="hs-varop">==</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = y)}</span><span class="hs-varid">y</span></a> <a class="annot" href="#"><span class="annottext">xs:(Data.Set.Base.Set a)
-&gt; ys:(Data.Set.Base.Set a)
-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cap([xs; ys]))}</span><span class="hs-varop">`intersection`</span></a> <a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = x)}</span><span class="hs-varid">x</span></a><span class="hs-layout">)</span>
</pre>
<p>that <code>union</code> is associative …</p>
<pre><span class="hs-linenum">172: </span><a class="annot" href="#"><span class="annottext">forall a.
(GHC.Classes.Ord a) =&gt;
(Data.Set.Base.Set a)
-&gt; (Data.Set.Base.Set a)
-&gt; (Data.Set.Base.Set a)
-&gt; (GHC.Types.Bool)</span><span class="hs-definition">prop_cup_assoc</span></a> <a class="annot" href="#"><span class="annottext">(Data.Set.Base.Set a)</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">(Data.Set.Base.Set a)</span><span class="hs-varid">y</span></a> <a class="annot" href="#"><span class="annottext">(Data.Set.Base.Set a)</span><span class="hs-varid">z</span></a> 
<span class="hs-linenum">173: </span>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Bool) | (? Prop([VV]))}
-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV]))}</span><span class="hs-varid">boolAssert</span></a> 
<span class="hs-linenum">174: </span>  <a class="annot" href="#"><span class="annottext">({VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}
 -&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)})
-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}
-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}</span><span class="hs-varop">$</span></a> <a class="annot" href="#"><span class="annottext">(GHC.Types.Bool)</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">xs:(Data.Set.Base.Set a)
-&gt; ys:(Data.Set.Base.Set a)
-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cup([xs; ys]))}</span><span class="hs-varop">`union`</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = y)}</span><span class="hs-varid">y</span></a> <a class="annot" href="#"><span class="annottext">xs:(Data.Set.Base.Set a)
-&gt; ys:(Data.Set.Base.Set a)
-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cup([xs; ys]))}</span><span class="hs-varop">`union`</span></a> <a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = z)}</span><span class="hs-varid">z</span></a><span class="hs-layout">)</span><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">GHC.Classes.Eq (Data.Set.Base.Set a)</span><span class="hs-varop">==</span></a> <a class="annot" href="#"><span class="annottext">(Data.Set.Base.Set a)</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">xs:(Data.Set.Base.Set a)
-&gt; ys:(Data.Set.Base.Set a)
-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cup([xs; ys]))}</span><span class="hs-varop">`union`</span></a> <a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = y)}</span><span class="hs-varid">y</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">xs:(Data.Set.Base.Set a)
-&gt; ys:(Data.Set.Base.Set a)
-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cup([xs; ys]))}</span><span class="hs-varop">`union`</span></a> <a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = z)}</span><span class="hs-varid">z</span></a>
</pre>
<p>and that <code>union</code> distributes over <code>intersection</code>.</p>
<pre><span class="hs-linenum">180: </span><a class="annot" href="#"><span class="annottext">forall a.
(GHC.Classes.Ord a) =&gt;
(Data.Set.Base.Set a)
-&gt; (Data.Set.Base.Set a)
-&gt; (Data.Set.Base.Set a)
-&gt; (GHC.Types.Bool)</span><span class="hs-definition">prop_cap_dist</span></a> <a class="annot" href="#"><span class="annottext">(Data.Set.Base.Set a)</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">(Data.Set.Base.Set a)</span><span class="hs-varid">y</span></a> <a class="annot" href="#"><span class="annottext">(Data.Set.Base.Set a)</span><span class="hs-varid">z</span></a> 
<span class="hs-linenum">181: </span>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Bool) | (? Prop([VV]))}
-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV]))}</span><span class="hs-varid">boolAssert</span></a> 
<span class="hs-linenum">182: </span>  <a class="annot" href="#"><span class="annottext">({VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}
 -&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)})
-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}
-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}</span><span class="hs-varop">$</span></a>  <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">xs:(Data.Set.Base.Set a)
-&gt; ys:(Data.Set.Base.Set a)
-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cap([xs; ys]))}</span><span class="hs-varop">`intersection`</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = y)}</span><span class="hs-varid">y</span></a> <a class="annot" href="#"><span class="annottext">xs:(Data.Set.Base.Set a)
-&gt; ys:(Data.Set.Base.Set a)
-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cup([xs; ys]))}</span><span class="hs-varop">`union`</span></a> <a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = z)}</span><span class="hs-varid">z</span></a><span class="hs-layout">)</span><span class="hs-layout">)</span> 
<span class="hs-linenum">183: </span>  <a class="annot" href="#"><span class="annottext">GHC.Classes.Eq (Data.Set.Base.Set a)</span><span class="hs-varop">==</span></a> <a class="annot" href="#"><span class="annottext">(Data.Set.Base.Set a)</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">xs:(Data.Set.Base.Set a)
-&gt; ys:(Data.Set.Base.Set a)
-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cap([xs; ys]))}</span><span class="hs-varop">`intersection`</span></a> <a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = y)}</span><span class="hs-varid">y</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">xs:(Data.Set.Base.Set a)
-&gt; ys:(Data.Set.Base.Set a)
-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cup([xs; ys]))}</span><span class="hs-varop">`union`</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">xs:(Data.Set.Base.Set a)
-&gt; ys:(Data.Set.Base.Set a)
-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cap([xs; ys]))}</span><span class="hs-varop">`intersection`</span></a> <a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = z)}</span><span class="hs-varid">z</span></a><span class="hs-layout">)</span> 
</pre>
<p>Of course, while we’re at it, let’s make sure LiquidHaskell
doesn’t prove anything that <em>isn’t</em> true …</p>
<pre><span class="hs-linenum">190: </span><a class="annot" href="#"><span class="annottext">forall a.
(GHC.Classes.Ord a) =&gt;
(Data.Set.Base.Set a) -&gt; (Data.Set.Base.Set a) -&gt; (GHC.Types.Bool)</span><span class="hs-definition">prop_cup_dif_bad</span></a> <a class="annot" href="#"><span class="annottext">(Data.Set.Base.Set a)</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">(Data.Set.Base.Set a)</span><span class="hs-varid">y</span></a>
<span class="hs-linenum">191: </span>   <span class="hs-keyglyph">=</span> <span class="hs-error"><a class="annot" href="#"><span class="annottext">{VV : (GHC.Types.Bool) | (? Prop([VV]))}
-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV]))}</span><span class="hs-varid">boolAssert</span></a></span> 
<span class="hs-linenum">192: </span>   <a class="annot" href="#"><span class="annottext">((GHC.Types.Bool)
 -&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)})
-&gt; (GHC.Types.Bool)
-&gt; {VV : (GHC.Types.Bool) | (? Prop([VV])),(VV != False)}</span><span class="hs-varop">$</span></a> <a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">GHC.Classes.Eq (Data.Set.Base.Set a)</span><span class="hs-varop">==</span></a> <a class="annot" href="#"><span class="annottext">(Data.Set.Base.Set a)</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">xs:(Data.Set.Base.Set a)
-&gt; ys:(Data.Set.Base.Set a)
-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_cup([xs; ys]))}</span><span class="hs-varop">`union`</span></a> <a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = y)}</span><span class="hs-varid">y</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">xs:(Data.Set.Base.Set a)
-&gt; ys:(Data.Set.Base.Set a)
-&gt; {VV : (Data.Set.Base.Set a) | (VV = Set_dif([xs; ys]))}</span><span class="hs-varop">`difference`</span></a> <a class="annot" href="#"><span class="annottext">{VV : (Data.Set.Base.Set a) | (VV = y)}</span><span class="hs-varid">y</span></a>
</pre>
<p>Hmm. You do know why the above doesn’t hold, right? It would be nice to
get a <em>counterexample</em> wouldn’t it? Well, for the moment, there is
QuickCheck!</p>
<p>Thus, the refined types offer a nice interface for interacting with the SMT
solver in order to prove theorems in LiquidHaskell. (BTW, The <a href="https://github.com/LeventErkok/sbv">SBV project</a>
describes another approach for using SMT solvers from Haskell, without the
indirection of refinement types.)</p>
<p>While the above is a nice warm up exercise to understanding how
LiquidHaskell reasons about sets, our overall goal is not to prove
theorems about set operators, but instead to specify and verify
properties of programs.</p>
<h1 id="the-set-of-values-in-a-list">The Set of Values in a List</h1>
<p>Let’s see how we might reason about sets of values in regular Haskell programs.</p>
<p>We’ll begin with Lists, the jack-of-all-data-types. Now, instead of just
talking about the <strong>number of</strong> elements in a list, we can write a measure
that describes the <strong>set of</strong> elements in a list:</p>
A measure for the elements of a list, from <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/master/include/Data/Set.spec">Data/Set.spec</a>
<pre><span class="hs-linenum">221: </span>
<span class="hs-linenum">222: </span><span class="hs-definition">measure</span> <span class="hs-varid">listElts</span> <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-conid">Set</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> 
<span class="hs-linenum">223: </span><span class="hs-definition">listElts</span> <span class="hs-layout">(</span><span class="hs-conid">[]</span><span class="hs-layout">)</span>    <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span> <span class="hs-keyglyph">|</span> <span class="hs-layout">(</span><span class="hs-varop">?</span> <span class="hs-conid">Set_emp</span><span class="hs-layout">(</span><span class="hs-varid">v</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">}</span>
<span class="hs-linenum">224: </span><span class="hs-definition">listElts</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span>  <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cup</span> <span class="hs-layout">(</span><span class="hs-conid">Set_sng</span> <span class="hs-varid">x</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-layout">}</span>
</pre>
<p>That is, <code>(listElts xs)</code> describes the set of elements contained in a list <code>xs</code>.</p>
<p>Next, to make the specifications concise, let’s define a few predicate aliases:</p>
<pre><span class="hs-linenum">232: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">EqElts</span>  <span class="hs-conid">X</span> <span class="hs-conid">Y</span> <span class="hs-keyglyph">=</span> 
<span class="hs-linenum">233: </span>      <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">X</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">Y</span><span class="hs-layout">)</span><span class="hs-layout">)</span>                        <span class="hs-keyword">@-}</span>
<span class="hs-linenum">234: </span>
<span class="hs-linenum">235: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">SubElts</span>   <span class="hs-conid">X</span> <span class="hs-conid">Y</span> <span class="hs-keyglyph">=</span> 
<span class="hs-linenum">236: </span>      <span class="hs-layout">(</span><span class="hs-conid">Set_sub</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">X</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">Y</span><span class="hs-layout">)</span><span class="hs-layout">)</span>                  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">237: </span>
<span class="hs-linenum">238: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">predicate</span> <span class="hs-conid">UnionElts</span> <span class="hs-conid">X</span> <span class="hs-conid">Y</span> <span class="hs-conid">Z</span> <span class="hs-keyglyph">=</span> 
<span class="hs-linenum">239: </span>      <span class="hs-layout">(</span><span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">X</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">(</span><span class="hs-conid">Set_cup</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">Y</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">listElts</span> <span class="hs-conid">Z</span><span class="hs-layout">)</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
</pre>
<h2 id="a-trivial-identity">A Trivial Identity</h2>
<p>OK, now let’s write some code to check that the <code>listElts</code> measure is sensible!</p>
<pre><span class="hs-linenum">248: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">listId</span>    <span class="hs-keyglyph">::</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyword">| (EqElts v xs)}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">249: </span><a class="annot" href="#"><span class="annottext">forall a.
x1:[a]
-&gt; {VV : [a] | (len([VV]) = len([x1])),
               (listElts([VV]) = Set_cup([listElts([x1]); listElts([x1])])),
               (listElts([VV]) = listElts([x1])),
               (listElts([x1]) = Set_cup([listElts([x1]); listElts([VV])])),
               (len([VV]) &gt;= 0)}</span><span class="hs-definition">listId</span></a> <span class="hs-conid">[]</span>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a -&gt; a -&gt; Bool&gt;.
{VV : [{VV : a | false}]&lt;p&gt; | (? Set_emp([listElts([VV])])),
                              (len([VV]) = 0)}</span><span class="hs-conid">[]</span></a>
<span class="hs-linenum">250: </span><span class="hs-definition">listId</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : a | (VV = x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a -&gt; a -&gt; Bool&gt;.
y:a
-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),
                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">forall a.
x1:[a]
-&gt; {VV : [a] | (len([VV]) = len([x1])),
               (listElts([VV]) = Set_cup([listElts([x1]); listElts([x1])])),
               (listElts([VV]) = listElts([x1])),
               (listElts([x1]) = Set_cup([listElts([x1]); listElts([VV])])),
               (len([VV]) &gt;= 0)}</span><span class="hs-varid">listId</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}</span><span class="hs-varid">xs</span></a>
</pre>
<p>That is, LiquidHaskell checks that the set of elements of the output list
is the same as those in the input.</p>
<h2 id="a-less-trivial-identity">A Less Trivial Identity</h2>
<p>Next, let’s write a function to <code>reverse</code> a list. Of course, we’d like to
verify that <code>reverse</code> doesn’t leave any elements behind; that is that the
output has the same set of values as the input list. This is somewhat more
interesting because of the <em>tail recursive</em> helper <code>go</code>. Do you understand
the type that is inferred for it? (Put your mouse over <code>go</code> to see the
inferred type.)</p>
<pre><span class="hs-linenum">267: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">reverse</span>       <span class="hs-keyglyph">::</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyword">| (EqElts v xs)}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">268: </span><a class="annot" href="#"><span class="annottext">forall a. xs:[a] -&gt; {VV : [a] | (listElts([VV]) = listElts([xs]))}</span><span class="hs-definition">reverse</span></a>           <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | (len([VV]) = 0)}
-&gt; x2:[a]
-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);
                                          listElts([x2])])),
               (listElts([VV]) = Set_cup([listElts([x2]); listElts([x1])])),
               (len([VV]) &gt;= 0)}</span><span class="hs-varid">go</span></a> <a class="annot" href="#"><span class="annottext">{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | (? Set_emp([listElts([VV])])),
                                           (len([VV]) = 0),
                                           (len([VV]) &gt;= 0)}</span><span class="hs-conid">[]</span></a> 
<span class="hs-linenum">269: </span>  <span class="hs-keyword">where</span> 
<span class="hs-linenum">270: </span>    <a class="annot" href="#"><span class="annottext">acc:{VV : [a] | (len([VV]) &gt;= 0)}
-&gt; x1:[a]
-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([acc]);
                                          listElts([x1])])),
               (listElts([VV]) = Set_cup([listElts([x1]); listElts([acc])])),
               (len([VV]) &gt;= 0)}</span><span class="hs-varid">go</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (len([VV]) &gt;= 0)}</span><span class="hs-varid">acc</span></a> <span class="hs-conid">[]</span>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = acc),(len([VV]) &gt;= 0)}</span><span class="hs-varid">acc</span></a>
<span class="hs-linenum">271: </span>    <span class="hs-varid">go</span> <span class="hs-varid">acc</span> <span class="hs-layout">(</span><span class="hs-varid">y</span><span class="hs-conop">:</span><span class="hs-varid">ys</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">acc:{VV : [a] | (len([VV]) &gt;= 0)}
-&gt; x1:[a]
-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([acc]);
                                          listElts([x1])])),
               (listElts([VV]) = Set_cup([listElts([x1]); listElts([acc])])),
               (len([VV]) &gt;= 0)}</span><span class="hs-varid">go</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | (VV = y)}</span><span class="hs-varid">y</span></a><a class="annot" href="#"><span class="annottext">forall &lt;p :: a -&gt; a -&gt; Bool&gt;.
y:a
-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),
                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}</span><span class="hs-conop">:</span></a><a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = acc),(len([VV]) &gt;= 0)}</span><span class="hs-varid">acc</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = ys),(len([VV]) &gt;= 0)}</span><span class="hs-varid">ys</span></a>
</pre>
<h2 id="appending-lists">Appending Lists</h2>
<p>Next, here’s good old <code>append</code>, but now with a specification that states
that the output indeed includes the elements from both the input lists.</p>
<pre><span class="hs-linenum">281: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">append</span>       <span class="hs-keyglyph">::</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">ys</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span><span class="hs-keyword">| (UnionElts v xs ys)}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">282: </span><a class="annot" href="#"><span class="annottext">forall a.
x1:[a]
-&gt; ys:[a]
-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);
                                          listElts([ys])])),
               (listElts([VV]) = Set_cup([listElts([ys]); listElts([x1])])),
               (len([VV]) &gt;= 0)}</span><span class="hs-definition">append</span></a> <span class="hs-conid">[]</span>     <a class="annot" href="#"><span class="annottext">[a]</span><span class="hs-varid">ys</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = ys),(len([VV]) &gt;= 0)}</span><span class="hs-varid">ys</span></a>
<span class="hs-linenum">283: </span><span class="hs-definition">append</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-varid">ys</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : a | (VV = x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a -&gt; a -&gt; Bool&gt;.
y:a
-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),
                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">forall a.
x1:[a]
-&gt; ys:[a]
-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);
                                          listElts([ys])])),
               (listElts([VV]) = Set_cup([listElts([ys]); listElts([x1])])),
               (len([VV]) &gt;= 0)}</span><span class="hs-varid">append</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}</span><span class="hs-varid">xs</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = ys),(len([VV]) &gt;= 0)}</span><span class="hs-varid">ys</span></a>
</pre>
<h2 id="filtering-lists">Filtering Lists</h2>
<p>Let’s round off the list trilogy, with <code>filter</code>. Here, we can verify
that it returns a <strong>subset of</strong> the values of the input list.</p>
<pre><span class="hs-linenum">293: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">filter</span>      <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Bool</span><span class="hs-layout">)</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span><span class="hs-keyword">| (SubElts v xs)}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">294: </span>
<span class="hs-linenum">295: </span><a class="annot" href="#"><span class="annottext">forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; x2:[a]
-&gt; {VV : [a] | (? Set_sub([listElts([VV]); listElts([x2])])),
               (listElts([x2]) = Set_cup([listElts([x2]); listElts([VV])])),
               (len([VV]) &gt;= 0)}</span><span class="hs-definition">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">f</span></a> <span class="hs-conid">[]</span>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a -&gt; a -&gt; Bool&gt;.
{VV : [{VV : a | false}]&lt;p&gt; | (? Set_emp([listElts([VV])])),
                              (len([VV]) = 0)}</span><span class="hs-conid">[]</span></a>
<span class="hs-linenum">296: </span><span class="hs-definition">filter</span> <span class="hs-varid">f</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> 
<span class="hs-linenum">297: </span>  <span class="hs-keyglyph">|</span> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">f</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV = x)}</span><span class="hs-varid">x</span></a>         <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : a | (VV = x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a -&gt; a -&gt; Bool&gt;.
y:a
-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),
                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; x2:[a]
-&gt; {VV : [a] | (? Set_sub([listElts([VV]); listElts([x2])])),
               (listElts([x2]) = Set_cup([listElts([x2]); listElts([VV])])),
               (len([VV]) &gt;= 0)}</span><span class="hs-varid">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">f</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}</span><span class="hs-varid">xs</span></a> 
<span class="hs-linenum">298: </span>  <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span>   <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall a.
(a -&gt; (GHC.Types.Bool))
-&gt; x2:[a]
-&gt; {VV : [a] | (? Set_sub([listElts([VV]); listElts([x2])])),
               (listElts([x2]) = Set_cup([listElts([x2]); listElts([VV])])),
               (len([VV]) &gt;= 0)}</span><span class="hs-varid">filter</span></a> <a class="annot" href="#"><span class="annottext">a -&gt; (GHC.Types.Bool)</span><span class="hs-varid">f</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}</span><span class="hs-varid">xs</span></a>
</pre>
<h1 id="merge-sort">Merge Sort</h1>
<p>Let’s conclude this entry with one larger example: <code>mergeSort</code>.
We’d like to verify that, well, the list that is returned
contains the same set of elements as the input list.</p>
<p>And so we will!</p>
<p>But first, let’s remind ourselves of how <code>mergeSort</code> works:</p>
<ol type="1">
<li><code>split</code> the input list into two halves,</li>
<li><code>sort</code> each half, recursively,</li>
<li><code>merge</code> the sorted halves to obtain the sorted list.</li>
</ol>
<h2 id="split">Split</h2>
<p>We can <code>split</code> a list into two, roughly equal parts like so:</p>
<pre><span class="hs-linenum">323: </span><a class="annot" href="#"><span class="annottext">forall a.
x1:[a]
-&gt; ({VV : [a] | (? Set_sub([listElts([VV]); listElts([x1])])),
                (listElts([x1]) = Set_cup([listElts([x1]); listElts([VV])])),
                (len([VV]) &gt;= 0)} , {VV : [a] | (? Set_sub([listElts([VV]);
                                                            listElts([x1])])),
                                                (listElts([x1]) = Set_cup([listElts([x1]);
                                                                           listElts([VV])])),
                                                (len([VV]) &gt;= 0)})&lt;\x1 VV -&gt; (? Set_sub([listElts([VV]);
                                                                                         listElts([x1])])),
                                                                             (listElts([x1]) = Set_cup([listElts([x1]);
                                                                                                        listElts([VV])])),
                                                                             (listElts([x1]) = Set_cup([listElts([x1]);
                                                                                                        listElts([VV])])),
                                                                             (len([VV]) &gt;= 0)&gt;</span><span class="hs-definition">split</span></a> <span class="hs-conid">[]</span>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall a b &lt;p2 :: a -&gt; b -&gt; Bool&gt;. x1:a -&gt; b&lt;p2 x1&gt; -&gt; (a , b)&lt;p2&gt;</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | (? Set_emp([listElts([VV])])),
                                           (len([VV]) = 0),
                                           (len([VV]) &gt;= 0)}</span><span class="hs-conid">[]</span></a><span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | (? Set_emp([listElts([VV])])),
                                           (len([VV]) = 0),
                                           (len([VV]) &gt;= 0)}</span><span class="hs-conid">[]</span></a><span class="hs-layout">)</span>
<span class="hs-linenum">324: </span><span class="hs-definition">split</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall a b &lt;p2 :: a -&gt; b -&gt; Bool&gt;. x1:a -&gt; b&lt;p2 x1&gt; -&gt; (a , b)&lt;p2&gt;</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">{VV : a | (VV = x)}</span><span class="hs-varid">x</span></a><a class="annot" href="#"><span class="annottext">forall &lt;p :: a -&gt; a -&gt; Bool&gt;.
y:a
-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),
                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}</span><span class="hs-conop">:</span></a><a class="annot" href="#"><span class="annottext">{VV : [a] | (? Set_sub([listElts([VV]); listElts([xs])])),
            (VV = zs),
            (VV = zs),
            (len([VV]) = len([zs])),
            (listElts([VV]) = Set_cup([listElts([zs]); listElts([zs])])),
            (listElts([VV]) = listElts([zs])),
            (listElts([xs]) = Set_cup([listElts([xs]); listElts([VV])])),
            (listElts([xs]) = Set_cup([listElts([ys]); listElts([VV])])),
            (listElts([xs]) = Set_cup([listElts([ys]); listElts([VV])])),
            (listElts([zs]) = Set_cup([listElts([zs]); listElts([VV])])),
            (len([VV]) &gt;= 0)}</span><span class="hs-varid">zs</span></a><span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (? Set_sub([listElts([VV]); listElts([xs])])),
            (VV = ys),
            (VV = ys),
            (len([VV]) = len([ys])),
            (listElts([VV]) = Set_cup([listElts([ys]); listElts([ys])])),
            (listElts([VV]) = listElts([ys])),
            (listElts([xs]) = Set_cup([listElts([xs]); listElts([VV])])),
            (listElts([xs]) = Set_cup([listElts([zs]); listElts([VV])])),
            (listElts([ys]) = Set_cup([listElts([ys]); listElts([VV])])),
            (len([VV]) &gt;= 0)}</span><span class="hs-varid">ys</span></a><span class="hs-layout">)</span>
<span class="hs-linenum">325: </span>  <span class="hs-keyword">where</span> 
<span class="hs-linenum">326: </span>    <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : [a] | (? Set_sub([listElts([VV]); listElts([xs])])),
            (VV = ys),
            (len([VV]) = len([ys])),
            (listElts([VV]) = Set_cup([listElts([ys]); listElts([ys])])),
            (listElts([VV]) = listElts([ys])),
            (listElts([xs]) = Set_cup([listElts([xs]); listElts([VV])])),
            (listElts([xs]) = Set_cup([listElts([zs]); listElts([VV])])),
            (listElts([ys]) = Set_cup([listElts([ys]); listElts([VV])])),
            (len([VV]) &gt;= 0)}</span><span class="hs-varid">ys</span></a><span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (? Set_sub([listElts([VV]); listElts([xs])])),
            (VV = zs),
            (len([VV]) = len([zs])),
            (listElts([VV]) = Set_cup([listElts([zs]); listElts([zs])])),
            (listElts([VV]) = listElts([zs])),
            (listElts([xs]) = Set_cup([listElts([xs]); listElts([VV])])),
            (listElts([xs]) = Set_cup([listElts([ys]); listElts([VV])])),
            (listElts([xs]) = Set_cup([listElts([ys]); listElts([VV])])),
            (listElts([zs]) = Set_cup([listElts([zs]); listElts([VV])])),
            (len([VV]) &gt;= 0)}</span><span class="hs-varid">zs</span></a><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall a.
x1:[a]
-&gt; ({VV : [a] | (? Set_sub([listElts([VV]); listElts([x1])])),
                (listElts([x1]) = Set_cup([listElts([x1]); listElts([VV])])),
                (len([VV]) &gt;= 0)} , {VV : [a] | (? Set_sub([listElts([VV]);
                                                            listElts([x1])])),
                                                (listElts([x1]) = Set_cup([listElts([x1]);
                                                                           listElts([VV])])),
                                                (len([VV]) &gt;= 0)})&lt;\x1 VV -&gt; (? Set_sub([listElts([VV]);
                                                                                         listElts([x1])])),
                                                                             (listElts([x1]) = Set_cup([listElts([x1]);
                                                                                                        listElts([VV])])),
                                                                             (listElts([x1]) = Set_cup([listElts([x1]);
                                                                                                        listElts([VV])])),
                                                                             (len([VV]) &gt;= 0)&gt;</span><span class="hs-varid">split</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}</span><span class="hs-varid">xs</span></a>
</pre>
<p>LiquidHaskell verifies that the relevant property of split is</p>
<pre><span class="hs-linenum">332: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">split</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span><span class="hs-layout">,</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span><span class="hs-layout">)</span><span class="hs-keyword">&lt;{\ys zs -&gt; (UnionElts xs ys zs)}&gt;</span> <span class="hs-keyword">@-}</span>
</pre>
<p>The funny syntax with angle brackets simply says that the output of <code>split</code>
is a <em>pair</em> <code>(ys, zs)</code> whose union is the list of elements of the input <code>xs</code>.
(Yes, this is indeed a dependent pair; we will revisit these later to
understand whats going on with the odd syntax.)</p>
<h2 id="merge">Merge</h2>
<p>Next, we can <code>merge</code> two (sorted) lists like so:</p>
<pre><span class="hs-linenum">346: </span><a class="annot" href="#"><span class="annottext">forall a.
(GHC.Classes.Ord a) =&gt;
xs:[a]
-&gt; x1:[a]
-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);
                                          listElts([xs])])),
               (listElts([VV]) = Set_cup([listElts([xs]); listElts([x1])])),
               (len([VV]) &gt;= 0)}</span><span class="hs-definition">merge</span></a> <a class="annot" href="#"><span class="annottext">[a]</span><span class="hs-varid">xs</span></a> <span class="hs-conid">[]</span>         <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}</span><span class="hs-varid">xs</span></a>
<span class="hs-linenum">347: </span><span class="hs-definition">merge</span> <span class="hs-conid">[]</span> <span class="hs-varid">ys</span>         <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (len([VV]) &gt;= 0)}</span><span class="hs-varid">ys</span></a>
<span class="hs-linenum">348: </span><span class="hs-definition">merge</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-layout">(</span><span class="hs-varid">y</span><span class="hs-conop">:</span><span class="hs-varid">ys</span><span class="hs-layout">)</span> 
<span class="hs-linenum">349: </span>  <span class="hs-keyglyph">|</span> <a class="annot" href="#"><span class="annottext">{VV : a | (VV = x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">x:a
-&gt; y:a -&gt; {VV : (GHC.Types.Bool) | ((? Prop([VV])) &lt;=&gt; (x &lt;= y))}</span><span class="hs-varop">&lt;=</span></a> <a class="annot" href="#"><span class="annottext">{VV : a | (VV = y)}</span><span class="hs-varid">y</span></a>          <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : a | (VV = x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a -&gt; a -&gt; Bool&gt;.
y:a
-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),
                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">forall a.
(GHC.Classes.Ord a) =&gt;
xs:[a]
-&gt; x1:[a]
-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);
                                          listElts([xs])])),
               (listElts([VV]) = Set_cup([listElts([xs]); listElts([x1])])),
               (len([VV]) &gt;= 0)}</span><span class="hs-varid">merge</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}</span><span class="hs-varid">xs</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | (VV = y)}</span><span class="hs-varid">y</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a -&gt; a -&gt; Bool&gt;.
y:a
-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),
                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = ys),(len([VV]) &gt;= 0)}</span><span class="hs-varid">ys</span></a><span class="hs-layout">)</span>
<span class="hs-linenum">350: </span>  <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span>       <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : a | (VV = y)}</span><span class="hs-varid">y</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a -&gt; a -&gt; Bool&gt;.
y:a
-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),
                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">forall a.
(GHC.Classes.Ord a) =&gt;
xs:[a]
-&gt; x1:[a]
-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);
                                          listElts([xs])])),
               (listElts([VV]) = Set_cup([listElts([xs]); listElts([x1])])),
               (len([VV]) &gt;= 0)}</span><span class="hs-varid">merge</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | (VV = x)}</span><span class="hs-varid">x</span></a> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a -&gt; a -&gt; Bool&gt;.
y:a
-&gt; ys:[a&lt;p y&gt;]&lt;p&gt;
-&gt; {VV : [a]&lt;p&gt; | (len([VV]) = (1 + len([ys]))),
                  (listElts([VV]) = Set_cup([Set_sng([y]); listElts([ys])]))}</span><span class="hs-conop">:</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = xs),(len([VV]) &gt;= 0)}</span><span class="hs-varid">xs</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = ys),(len([VV]) &gt;= 0)}</span><span class="hs-varid">ys</span></a>
</pre>
<p>As you might expect, the elements of the returned list are the union of the
elements of the input, or as LiquidHaskell might say,</p>
<pre><span class="hs-linenum">357: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">merge</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Ord</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">y</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span><span class="hs-keyword">| (UnionElts v x y)}</span> <span class="hs-keyword">@-}</span>
</pre>
<h2 id="sort">Sort</h2>
<p>Finally, we put all the pieces together by</p>
<pre><span class="hs-linenum">366: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">mergeSort</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">(</span><span class="hs-conid">Ord</span> <span class="hs-varid">a</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyword">| (EqElts v xs)}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">367: </span><a class="annot" href="#"><span class="annottext">forall a.
(GHC.Classes.Ord a) =&gt;
x1:[a]
-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);
                                          listElts([x1])])),
               (listElts([VV]) = listElts([x1])),
               (listElts([x1]) = Set_cup([listElts([x1]); listElts([VV])]))}</span><span class="hs-definition">mergeSort</span></a> <span class="hs-conid">[]</span>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall &lt;p :: a -&gt; a -&gt; Bool&gt;.
{VV : [{VV : a | false}]&lt;p&gt; | (? Set_emp([listElts([VV])])),
                              (len([VV]) = 0)}</span><span class="hs-conid">[]</span></a>
<span class="hs-linenum">368: </span><span class="hs-definition">mergeSort</span> <span class="hs-keyglyph">[</span><span class="hs-varid">x</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : [{VV : a | false}]&lt;\_ VV -&gt; false&gt; | (? Set_emp([listElts([VV])])),
                                           (len([VV]) = 0),
                                           (len([VV]) &gt;= 0)}</span><span class="hs-keyglyph">[</span></a><a class="annot" href="#"><span class="annottext">{VV : a | (VV = x)}</span><span class="hs-varid">x</span></a><span class="hs-keyglyph">]</span>
<span class="hs-linenum">369: </span><span class="hs-definition">mergeSort</span> <span class="hs-varid">xs</span>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x:[a]
-&gt; y:[a]
-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x]);
                                          listElts([y])]))}</span><span class="hs-varid">merge</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">forall a.
(GHC.Classes.Ord a) =&gt;
x1:[a]
-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);
                                          listElts([x1])])),
               (listElts([VV]) = listElts([x1])),
               (listElts([x1]) = Set_cup([listElts([x1]); listElts([VV])]))}</span><span class="hs-varid">mergeSort</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = ys),
            (VV = ys),
            (len([VV]) = len([ys])),
            (listElts([VV]) = Set_cup([listElts([ys]); listElts([ys])])),
            (listElts([VV]) = listElts([ys])),
            (listElts([ys]) = Set_cup([listElts([ys]); listElts([VV])])),
            (len([VV]) &gt;= 0)}</span><span class="hs-varid">ys</span></a><span class="hs-layout">)</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">forall a.
(GHC.Classes.Ord a) =&gt;
x1:[a]
-&gt; {VV : [a] | (listElts([VV]) = Set_cup([listElts([x1]);
                                          listElts([x1])])),
               (listElts([VV]) = listElts([x1])),
               (listElts([x1]) = Set_cup([listElts([x1]); listElts([VV])]))}</span><span class="hs-varid">mergeSort</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = zs),
            (VV = zs),
            (len([VV]) = len([zs])),
            (listElts([VV]) = Set_cup([listElts([zs]); listElts([zs])])),
            (listElts([VV]) = listElts([zs])),
            (listElts([zs]) = Set_cup([listElts([zs]); listElts([VV])])),
            (len([VV]) &gt;= 0)}</span><span class="hs-varid">zs</span></a><span class="hs-layout">)</span> 
<span class="hs-linenum">370: </span>  <span class="hs-keyword">where</span> 
<span class="hs-linenum">371: </span>    <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = ys),
            (len([VV]) = len([ys])),
            (listElts([VV]) = Set_cup([listElts([ys]); listElts([ys])])),
            (listElts([VV]) = listElts([ys])),
            (listElts([ys]) = Set_cup([listElts([ys]); listElts([VV])])),
            (len([VV]) &gt;= 0)}</span><span class="hs-varid">ys</span></a><span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">{VV : [a] | (VV = zs),
            (len([VV]) = len([zs])),
            (listElts([VV]) = Set_cup([listElts([zs]); listElts([zs])])),
            (listElts([VV]) = listElts([zs])),
            (listElts([zs]) = Set_cup([listElts([zs]); listElts([VV])])),
            (len([VV]) &gt;= 0)}</span><span class="hs-varid">zs</span></a><span class="hs-layout">)</span>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">xs:[a]
-&gt; ([a] , [a])&lt;\ys VV -&gt; (listElts([xs]) = Set_cup([listElts([ys]);
                                                    listElts([VV])]))&gt;</span><span class="hs-varid">split</span></a> <a class="annot" href="#"><span class="annottext">{VV : [a] | (len([VV]) &gt;= 0)}</span><span class="hs-varid">xs</span></a>
</pre>
<p>The type given to <code>mergeSort</code>guarantees that the set of elements in the
output list is indeed the same as in the input list. Of course, it says
nothing about whether the list is <em>actually sorted</em>.</p>
<p>Well, Rome wasn’t built in a day…</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2013/03/26/talking-about-sets.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2013/03/26/talking-about-sets.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>

        </div>
        <div id="footer">
        </div>
      <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="https://ucsd-progsys.github.io/liquidhaskell-blog/feed.xml" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/ranjitjhala" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://plus.google.com/u/0/106612421534244742464" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/ucsd-progsys" target="_blank">
                            <span class="fa-stack fa-lg">

                              <i class="fa fa-arrow-circle-o-down"></i>
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
		    
                </ul>
                <p class="copyright text-muted">
                
                  Copyright &copy; Ranjit Jhala 2016-17.
                
                  Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>,
                  template by <a href="http://lucumr.pocoo.org">Armin Ronacher</a>,
                  suggest improvements <a href="https://github.com/ucsd-progsys/liquidhaskell-blog/">here</a>.
                </p>
            </div>
        </div>
    </div>
</footer>


<!-- jQuery -->
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/jquery.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/spaceg.stylesheets.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/bootstrap.min.js"></script>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/anim.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/scripts.js"></script>

    </body>
</html>
