<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    
    <head>
   <!-- Global Site Tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-106786912-1">
    </script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments)};
      gtag('js', new Date());
      gtag('config', 'UA-106786912-1');
    </script>


     <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
 <!--
      loads the http over https ssl -
      welcome to my website!

	this theme is based off the Ice & Fire theme created by Lucas Gatsas
      https://www.twitter.com/LucasGatsas
      www.lucasgatsas.ch - switzerland.
  -->


<!-- Microsoft Internet Explorer documentMode compatMode setting IE Modus -->
<script type="text/javascript">
var IE = null;
if (window.navigator.appName == "Microsoft Internet Explorer") {
  if (document.documentMode) {

    IE = document.documentMode;
    } else {

        IE = 5;
          if (document.compatMode) {
      if (document.compatMode == "CSS1Compat")
      IE = 11;
      }
    }
  }
</script>

    <meta charset="utf-8">
    <!-- X-UA -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <link rel="author" title="Ranjit Jhala" href="http://ranjitjhala.github.io" />

    <meta name="google" content="notranslate" />
    <!-- Viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- index ROBOTS follow -->
    <meta name="robots" content="index, follow" />
    <!-- Site Desciption -->
    <meta name="description" content="LiquidHaskell Blog">
    <!-- Site Desciption -->
    <meta name="keywords" content="haskell, refinement types, liquid types, formal methods, type systems">
    <!-- Favicon -->
    <link rel="shortcut icon" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" type="image/x-icon" />
    <!-- Blog Title -->
    <title>LiquidHaskell</title>

    <!--     <title>{% if page.title %}{{ page.title }} - {{ site.title }}{% else %}{{ site.title }}{% endif %}</title>
-->
    <!-- Property Metas -->
    <meta property="og:image" content="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ix.png" />
    <meta property="og:title" content="LiquidHaskell Blog" />
    <meta property="og:site_name" content="LiquidHaskell Blog" />
    <!-- Canonical -->
    <link rel="canonical" href="{{ page.url | replace:'index.html','' | prepend: site.baseUrl | prepend: site.url }}">
    <!-- StyleSheet -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/bootstrap.min.css">
    <!-- <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/spaceg.stylesheets.css"> -->
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/ronacher.css" type="text/css">

    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/syntax.css">
    <link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/liquid-light.css">

    <!-- Fonts
    <link href='https://fonts.googleapis.com/css?family=Merriweather:400,300,300italic,400italic,700,700italic,900,900italic' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900,400italic,700italic,900italic' rel='stylesheet' type='text/css'>
    -->

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>
	#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:url("/static/img/preloader.gif"); /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	ul, ol {margin-top: 0;margin-bottom: 10px;}
	.navbar-inverse {background-color: #FFF;border-color: #FFFFFF;}
</style>
<!--link rel="stylesheet" href="https://ucsd-progsys.github.io/liquidhaskell-blog/static/css/prettify.css"-->
<style>
  /* HEADER IMAGE */
  header.intro-header {background: #6f5499;background: no-repeat center center;background-attachment: scroll;-webkit-background-size: cover;-moz-background-size: cover;background-size: cover;-o-background-size: cover;}

	/* Preloader */#preloader {position:fixed;top:0;left:0;right:0;bottom:0;background-color:#fff; /* change if the mask should have another color then white */z-index:99; /* makes sure it stays on top */}
	#status {width:200px;height:200px;position:absolute;left:50%; /* centers the loading animation horizontally one the screen */top:50%; /* centers the loading animation vertically one the screen */background-image:; /* path to your loading animation */background-repeat:no-repeat;background-position:center;margin:-100px 0 0 -100px; /* is width and height divided by two */}
	li {list-style: none;}
            body.modal-open
            {overflow: hidden;padding-right: 0px;
        }
	article li {list-style: inherit;}
	article .figure {text-align: center}
    </style>
    <!-- end Loading front stylesheet here -->

    <link href="atom.xml" type="application/atom+xml" rel="alternate" title="LiquidHaskell-Blog ATOM Feed" />
    </head>

    <body>
	    
	<!-- 	
        <div id="preloader">
	    <div id="status">
	    </div>
	</div>  
	-->
	<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://ucsd-progsys.github.io/liquidhaskell-blog" id="blog-title-left-top">LiquidHaskell</a>
        </div>
        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- <li class="dropdown">
                    <a href="#portfolioModal2" data-toggle="modal"><i class="fa fa-random" id="icon-top"></i></a>
                <ul class="dropdown-menu"></ul>
                </li>-->
                
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/blog.html">Blog</a></li>
                <li><a href="http://goto.ucsd.edu:8090/index.html#?demo=LazyQueue.hs" target="_blank">Demo</a></li>
                <li><a href="http://ucsd-progsys.github.io/lh-workshop" target="_blank">Tutorial</a></li>
                <li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial" target="_blank">Book</a></li>
                <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html" target="_blank">About</a></li>
                <li><a href="http://www.github.com/ucsd-progsys/liquidhaskell" target="_blank"><i class="fa fa-twitter"></i>Download</a></li>
                <!--
                <li><a href="https://www.twitter.com/ranjitjhala" id="roundbutton" target="_blank"><i class="fa fa-twitter"></i>RanjitJhala</a></li>
                -->
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<!-- Portfolio Modals -->
    <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <img src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/ico.png" class="img-responsive img-centered" alt title>
                            <p class="font-style-inline-small">
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow me</a>. <br>
                                <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                                <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                                <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>
                            </p>
                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<!-- Menu Modals Add New Sa.21.Feb.2015 03:22:25 -->
    <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-hidden="true" style="padding-right:0px; overflow: hidden;">
        <div class="modal-content">
            <div class="close-modal" data-dismiss="modal">
                <div class="lr">
                    <div class="rl">
                    </div>
                </div>
            </div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2">
                        <div class="modal-body">
                            <h1 class="font-style-inline-small-h1">Ranjit Jhala</h1>
                            <hr class="star-primary">
                            <p class="font-style-inline-small">
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank">follow</a>. <br>
                        <a href="https://www.github.com/ucsd-progsys" target="_blank">    <i class="fa fa-github" id="spaceg-social-modal"></i> </a>
                        <a href="https://www.twitter.com/ranjitjhala" target="_blank"><i class="fa fa-twitter" id="spaceg-social-modal"></i> </a>
                        <a href="https://plus.google.com/u/0/106612421534244742464" target="_blank"> <i class="fa fa-google-plus" id="spaceg-social-modal"></i></a>  <br>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/index.html">Home</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/about.html">About</a></li>
                    <li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/blog.html">Blog</a></li>
                    <li><a href="http://goto.ucsd.edu:8090/index.html#?demo=LazyQueue.hs" target="_blank">Demo</a></li>
                    <li><a href="http://ucsd-progsys.github.io/lh-workshop" target="_blank">Tutorial</a></li>
                    <li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial" target="_blank">Book</a></li>
                    <li><a href="http://www.github.com/ucsd-progsys/liquidhaskell" target="_blank"><i class="fa fa-twitter"></i>Download</a></li>
                            </p>

                            <button type="button" class="btn btn-default" data-dismiss="modal"><i class="fa fa-times"></i> Close</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


        <div id="content">
            <!-- Post Header -->
<header class="intro-header" style="background-image: url('https://ucsd-progsys.github.io/liquidhaskell-blog/static/img/sea.jpg')" alt title>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Okasaki's Lazy Queues</h1>
                    
                    <span class="meta">
		    
			Posted by Ranjit Jhala
		    
			Jan 28, 2015
		    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

            <br>

            <div class="info">
              
                Tags: <a title="All pages tagged 'measures'." href="../../../../tags/measures.html">measures</a>
              
            </div>

            <br>
			            <p>The “Hello World!” example for fancy type systems is probably the sized vector
or list <code>append</code> function (“The output has size equal to the <em>sum</em> of the
inputs!”). One the one hand, it is perfect: simple enough to explain without
pages of code, yet complex enough to show off whats cool about dependency. On
the other hand, like the sweater I’m sporting right now, it’s a bit well-worn and
worse, was never wholly convincing (“Why do I <em>care</em> what the <em>size</em> of the
output list is anyway?”)</p>
<p>Recently, I came across a nice example that is almost as simple, but is also
well motivated: Okasaki’s beautiful <a href="http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp95queue.pdf">Lazy Amortized Queues</a>. This
structure leans heavily on an invariant to provide fast <em>insertion</em> and
<em>deletion</em>. Let’s see how to enforce that invariant with LiquidHaskell.</p>
<!-- more -->
<div class="hidden">
<pre><span class="hs-linenum">30: </span><span class="hs-keyword">{-@</span> <span class="hs-conid">LIQUID</span> <span class="hs-str">"--no-termination"</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">31: </span><span class="hs-keyword">{-@</span> <span class="hs-conid">LIQUID</span> <span class="hs-str">"--total"</span>          <span class="hs-keyword">@-}</span>
<span class="hs-linenum">32: </span><span class="hs-keyword">{-@</span> <span class="hs-conid">LIQUID</span> <span class="hs-str">"--maxparams=3"</span>    <span class="hs-keyword">@-}</span>
<span class="hs-linenum">33: </span>
<span class="hs-linenum">34: </span><span class="hs-keyword">module</span> <span class="hs-conid">LazyQueue</span> <span class="hs-layout">(</span><span class="hs-conid">Queue</span><span class="hs-layout">,</span> <span class="hs-varid">insert</span><span class="hs-layout">,</span> <span class="hs-varid">remove</span><span class="hs-layout">,</span> <span class="hs-varid">emp</span><span class="hs-layout">)</span> <span class="hs-keyword">where</span>
<span class="hs-linenum">35: </span>
<span class="hs-linenum">36: </span><span class="hs-keyword">import</span> <span class="hs-conid">Prelude</span> <span class="hs-varid">hiding</span> <span class="hs-layout">(</span><span class="hs-varid">length</span><span class="hs-layout">)</span>
<span class="hs-linenum">37: </span>
<span class="hs-linenum">38: </span><span class="hs-comment">-- | Size function actually returns the size: (Duh!)</span>
<span class="hs-linenum">39: </span>
<span class="hs-linenum">40: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">size</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">q</span><span class="hs-conop">:</span><span class="hs-conid">SList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-keyword">{v:</span><span class="hs-conid">Nat</span> <span class="hs-keyword">| v = size q}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">41: </span><span class="hs-keyword">data</span> <span class="hs-conid">Queue</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">Q</span>  <span class="hs-layout">{</span> <a class="annot" href="#"><span class="annottext">forall a. (LazyQueue.Queue a) -&gt; (LazyQueue.SList a)</span><span class="hs-varid">front</span></a> <span class="hs-keyglyph">::</span> <span class="hs-conid">SList</span> <span class="hs-varid">a</span>
<span class="hs-linenum">42: </span>                  <span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">forall a. (LazyQueue.Queue a) -&gt; (LazyQueue.SList a)</span><span class="hs-varid">back</span></a>  <span class="hs-keyglyph">::</span> <span class="hs-conid">SList</span> <span class="hs-varid">a</span>
<span class="hs-linenum">43: </span>                  <span class="hs-layout">}</span>
<span class="hs-linenum">44: </span>
<span class="hs-linenum">45: </span><span class="hs-comment">-- Source: Okasaki, JFP 1995</span>
<span class="hs-linenum">46: </span><span class="hs-comment">-- <a href="http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp95queue.pdf">http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp95queue.pdf</a></span>
<span class="hs-linenum">47: </span>
</pre>
</div>
<h2 id="queues">Queues</h2>
<p>A <a href="http://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29">queue</a> is a structure into which we can <code>insert</code> and <code>remove</code> data
such that the order in which the data is removed is the same as the order in which
it was inserted.</p>
<figure>
<img src="../../../../static/img/queue.png" alt="A Queue" /><figcaption aria-hidden="true">A Queue</figcaption>
</figure>
<p>To implement a queue <em>efficiently</em> one needs to have rapid access to both
the “head” as well as the “tail” because we <code>remove</code> elements from former
and <code>insert</code> elements into the latter. This is quite straightforward with
explicit pointers and mutation – one uses an old school linked list and
maintains pointers to the head and the tail. But can we implement the
structure efficiently without having stoop so low?</p>
<h2 id="queues-pair-of-lists">Queues = Pair of Lists</h2>
<p>Almost two decades ago, Chris Okasaki came up with a very cunning way
to implement queues using a <em>pair</em> of lists – let’s call them <code>front</code>
and <code>back</code> which represent the corresponding parts of the Queue.</p>
<ul>
<li>To <code>insert</code> elements, we just <em>cons</em> them onto the <code>back</code> list,</li>
<li>To <code>remove</code> elements, we just <em>un-cons</em> them from the <code>front</code> list.</li>
</ul>
<figure>
<img src="../../../../static/img/queue-lists.png" alt="A Queue is Two Lists" /><figcaption aria-hidden="true">A Queue is Two Lists</figcaption>
</figure>
<p>The catch is that we need to shunt elements from the back to the
front every so often, e.g. when</p>
<ol type="1">
<li>a <code>remove</code> call is triggered, and</li>
<li>the <code>front</code> list is empty,</li>
</ol>
<p>We can transfer the elements from the <code>back</code> to the <code>front</code>.</p>
<figure>
<img src="../../../../static/img/queue-rotate.png" alt="Transferring Elements from Back to Front" /><figcaption aria-hidden="true">Transferring Elements from Back to Front</figcaption>
</figure>
<p>Okasaki observed that every element is only moved <em>once</em> from the
front to the back; hence, the time for <code>insert</code> and <code>lookup</code> could be
<code>O(1)</code> when <em>amortized</em> over all the operations. Awesome, right?!</p>
<p>Almost. Some set of unlucky <code>remove</code> calls (which occur when
the <code>front</code> is empty) are stuck paying the bill. They have a
rather high latency up to <code>O(n)</code> where <code>n</code> is the total number
of operations. Oops.</p>
<h2 id="queue-balanced-lazy-lists">Queue = Balanced Lazy Lists</h2>
<p>This is where Okasaki’s beautiful insights kick in. Okasaki
observed that all we need to do is to enforce a simple invariant:</p>
<p><strong>Invariant:</strong> Size of <code>front</code> &gt;= Size of <code>back</code></p>
<p>Now, if the lists are <em>lazy</em> i.e. only constructed as the head
value is demanded, then a single <code>remove</code> needs only a tiny <code>O(log n)</code>
in the worst case, and so no single <code>remove</code> is stuck paying the bill.</p>
<p>Let’s see how to represent these Queues and ensure the crucial invariant(s)
with LiquidHaskell. What we need are the following ingredients:</p>
<ol type="1">
<li><p>A type for <code>List</code>s, and a way to track their <code>size</code>,</p></li>
<li><p>A type for <code>Queue</code>s which encodes the <em>balance</em> invariant – ``front longer than back”,</p></li>
<li><p>A way to implement the <code>insert</code>, <code>remove</code> and <code>transfer</code> operations.</p></li>
</ol>
<h2 id="sized-lists">Sized Lists</h2>
<p>The first part is super easy. Let’s define a type:</p>
<pre><span class="hs-linenum">127: </span><span class="hs-keyword">data</span> <span class="hs-conid">SList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">SL</span> <span class="hs-layout">{</span> <a class="annot" href="#"><span class="annottext">forall a.
x1:(LazyQueue.SList a)
-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}</span><span class="hs-varid">size</span></a> <span class="hs-keyglyph">::</span> <span class="hs-conid">Int</span><span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">forall a. (LazyQueue.SList a) -&gt; [a]</span><span class="hs-varid">elems</span></a> <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span><span class="hs-layout">}</span>
</pre>
<p>We have a special field that saves the <code>size</code> because otherwise, we
have a linear time computation that wrecks Okasaki’s careful
analysis. (Actually, he presents a variant which does <em>not</em> require
saving the size as well, but that’s for another day.)</p>
<p>But how can we be sure that <code>size</code> is indeed the <em>real size</em> of <code>elems</code>?</p>
<p>Let’s write a function to <em>measure</em> the real size:</p>
<pre><span class="hs-linenum">140: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">measure</span> <span class="hs-varid">realSize</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">141: </span><span class="hs-definition">realSize</span>      <span class="hs-keyglyph">::</span> <span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span>
<span class="hs-linenum">142: </span><a class="annot" href="#"><span class="annottext">forall a. x1:[a] -&gt; {VV : GHC.Types.Int | VV == realSize x1}</span><span class="hs-definition">realSize</span></a> <span class="hs-conid">[]</span>     <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:GHC.Prim.Int# -&gt; {v : GHC.Types.Int | v == (x1  :  int)}</span><span class="hs-num">0</span></a>
<span class="hs-linenum">143: </span><span class="hs-definition">realSize</span> <span class="hs-layout">(</span><span class="hs-keyword">_</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v == (1  :  int)}</span><span class="hs-num">1</span></a> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int
-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a> <a class="annot" href="#"><span class="annottext">forall a. x1:[a] -&gt; {VV : GHC.Types.Int | VV == realSize x1}</span><span class="hs-varid">realSize</span></a> <a class="annot" href="#"><span class="annottext">{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class="hs-varid">xs</span></a>
</pre>
<p>and now, we can simply specify a <em>refined</em> type for <code>SList</code> that ensures
that the <em>real</em> size is saved in the <code>size</code> field:</p>
<pre><span class="hs-linenum">150: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">data</span> <span class="hs-conid">SList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">SL</span> <span class="hs-layout">{</span>
<span class="hs-linenum">151: </span>       <span class="hs-varid">size</span>  <span class="hs-keyglyph">::</span> <span class="hs-conid">Nat</span> 
<span class="hs-linenum">152: </span>     <span class="hs-layout">,</span> <span class="hs-varid">elems</span> <span class="hs-keyglyph">::</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-keyglyph">[</span><span class="hs-varid">a</span><span class="hs-keyglyph">]</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">realSize</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">size</span><span class="hs-layout">}</span>
<span class="hs-linenum">153: </span>     <span class="hs-layout">}</span>
<span class="hs-linenum">154: </span>  <span class="hs-keyword">@-}</span>
</pre>
<p>As a sanity check, consider this:</p>
<pre><span class="hs-linenum">160: </span><a class="annot" href="#"><span class="annottext">{VV : (LazyQueue.SList {VV : [GHC.Types.Char] | len VV &gt;= 0}) | size VV &gt; 0}</span><span class="hs-definition">okList</span></a>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:{v : GHC.Types.Int | v &gt;= 0}
-&gt; x2:{v : [{v : [GHC.Types.Char] | len v &gt;= 0}] | realSize v == x1}
-&gt; {v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | elems v == x2 &amp;&amp; size v == x1}</span><span class="hs-conid">SL</span></a> <a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v == (1  :  int)}</span><span class="hs-num">1</span></a> <a class="annot" href="#"><span class="annottext">{v : [{v : [GHC.Types.Char] | len v &gt;= 0}]&lt;\_ VV -&gt; false&gt; | null v &lt;=&gt; false &amp;&amp; len v &gt;= 0}</span><span class="hs-keyglyph">[</span></a><a class="annot" href="#"><span class="annottext">{v : [GHC.Types.Char] | len v &gt;= 0}</span><span class="hs-str">"cat"</span></a><span class="hs-keyglyph">]</span>    <span class="hs-comment">-- accepted</span>
<span class="hs-linenum">161: </span>
<span class="hs-linenum">162: </span><a class="annot" href="#"><span class="annottext">forall a. (LazyQueue.SList a)</span><span class="hs-definition">badList</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:{v : GHC.Types.Int | v &gt;= 0}
-&gt; x2:{v : [a] | realSize v == x1}
-&gt; {v : (LazyQueue.SList a) | elems v == x2 &amp;&amp; size v == x1}</span><span class="hs-conid">SL</span></a> <a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v == (1  :  int)}</span><span class="hs-num">1</span></a> <span class="hs-error"><a class="annot" href="#"><span class="annottext">{v : [a] | null v &lt;=&gt; true &amp;&amp; realSize v == 0 &amp;&amp; len v == 0 &amp;&amp; len v &gt;= 0}</span><span class="hs-conid">[]</span></a></span>         <span class="hs-comment">-- rejected</span>
</pre>
<p>It is helpful to define a few aliases for <code>SList</code>s of a size <code>N</code> and
non-empty <code>SList</code>s:</p>
<pre><span class="hs-linenum">169: </span><span class="hs-comment">-- | SList of size N</span>
<span class="hs-linenum">170: </span>
<span class="hs-linenum">171: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">SListN</span> <span class="hs-varid">a</span> <span class="hs-conid">N</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">SList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">size</span> <span class="hs-varid">v</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">N</span><span class="hs-layout">}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">172: </span>
<span class="hs-linenum">173: </span><span class="hs-comment">-- | Non-Empty SLists:</span>
<span class="hs-linenum">174: </span>
<span class="hs-linenum">175: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">NEList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">SList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">size</span> <span class="hs-varid">v</span> <span class="hs-varop">&gt;</span> <span class="hs-num">0</span><span class="hs-layout">}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">176: </span>
</pre>
<p>Finally, we can define a basic API for <code>SList</code>.</p>
<p><strong>To Construct</strong> lists, we use <code>nil</code> and <code>cons</code>:</p>
<pre><span class="hs-linenum">184: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">nil</span>          <span class="hs-keyglyph">::</span> <span class="hs-conid">SListN</span> <span class="hs-varid">a</span> <span class="hs-num">0</span>  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">185: </span><a class="annot" href="#"><span class="annottext">forall a. {v : (LazyQueue.SList a) | size v == 0}</span><span class="hs-definition">nil</span></a>              <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:{v : GHC.Types.Int | v &gt;= 0}
-&gt; x2:{v : [a] | realSize v == x1}
-&gt; {v : (LazyQueue.SList a) | elems v == x2 &amp;&amp; size v == x1}</span><span class="hs-conid">SL</span></a> <a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v == (0  :  int)}</span><span class="hs-num">0</span></a> <a class="annot" href="#"><span class="annottext">{v : [a] | null v &lt;=&gt; true &amp;&amp; realSize v == 0 &amp;&amp; len v == 0 &amp;&amp; len v &gt;= 0}</span><span class="hs-conid">[]</span></a>
<span class="hs-linenum">186: </span>
<span class="hs-linenum">187: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">cons</span>         <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-conid">SList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">SListN</span> <span class="hs-varid">a</span> <span class="hs-keyword">{size xs + 1}</span>   <span class="hs-keyword">@-}</span>
<span class="hs-linenum">188: </span><a class="annot" href="#"><span class="annottext">forall a.
a
-&gt; x2:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size x2 + 1}</span><span class="hs-definition">cons</span></a> <a class="annot" href="#"><span class="annottext">a</span><span class="hs-varid">x</span></a> <span class="hs-layout">(</span><span class="hs-conid">SL</span> <span class="hs-varid">n</span> <span class="hs-varid">xs</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:{v : GHC.Types.Int | v &gt;= 0}
-&gt; x2:{v : [a] | realSize v == x1}
-&gt; {v : (LazyQueue.SList a) | elems v == x2 &amp;&amp; size v == x1}</span><span class="hs-conid">SL</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v == n &amp;&amp; v &gt;= 0}</span><span class="hs-varid">n</span></a><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int
-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a><a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v == (1  :  int)}</span><span class="hs-num">1</span></a><span class="hs-layout">)</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | VV == x}</span><span class="hs-varid">x</span></a><a class="annot" href="#"><span class="annottext">x1:a
-&gt; x2:[a]
-&gt; {v : [a] | null v &lt;=&gt; false &amp;&amp; xListSelector v == x1 &amp;&amp; realSize v == 1 + realSize x2 &amp;&amp; xsListSelector v == x2 &amp;&amp; len v == 1 + len x2}</span><span class="hs-conop">:</span></a><a class="annot" href="#"><span class="annottext">{v : [a] | v == xs &amp;&amp; realSize v == n &amp;&amp; len v &gt;= 0}</span><span class="hs-varid">xs</span></a><span class="hs-layout">)</span>
</pre>
<p><strong>To Destruct</strong> lists, we have <code>hd</code> and <code>tl</code>.</p>
<pre><span class="hs-linenum">194: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">tl</span>           <span class="hs-keyglyph">::</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-conid">NEList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">SListN</span> <span class="hs-varid">a</span> <span class="hs-keyword">{size xs - 1}</span>  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">195: </span><a class="annot" href="#"><span class="annottext">forall a.
x1:{v : (LazyQueue.SList a) | size v &gt; 0}
-&gt; {v : (LazyQueue.SList a) | size v == size x1 - 1}</span><span class="hs-definition">tl</span></a> <span class="hs-layout">(</span><span class="hs-conid">SL</span> <span class="hs-varid">n</span> <span class="hs-layout">(</span><span class="hs-keyword">_</span><span class="hs-conop">:</span><span class="hs-varid">xs</span><span class="hs-layout">)</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:{v : GHC.Types.Int | v &gt;= 0}
-&gt; x2:{v : [a] | realSize v == x1}
-&gt; {v : (LazyQueue.SList a) | elems v == x2 &amp;&amp; size v == x1}</span><span class="hs-conid">SL</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v == n &amp;&amp; v &gt;= 0}</span><span class="hs-varid">n</span></a><a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int
-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 - x2}</span><span class="hs-comment">-</span></a><a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v == (1  :  int)}</span><span class="hs-num">1</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">{v : [a] | v == xs &amp;&amp; len v &gt;= 0}</span><span class="hs-varid">xs</span></a>
<span class="hs-linenum">196: </span>
<span class="hs-linenum">197: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">hd</span>           <span class="hs-keyglyph">::</span> <span class="hs-varid">xs</span><span class="hs-conop">:</span><span class="hs-conid">NEList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">198: </span><a class="annot" href="#"><span class="annottext">forall a. {v : (LazyQueue.SList a) | size v &gt; 0} -&gt; a</span><span class="hs-definition">hd</span></a> <span class="hs-layout">(</span><span class="hs-conid">SL</span> <span class="hs-keyword">_</span> <span class="hs-layout">(</span><span class="hs-varid">x</span><span class="hs-conop">:</span><span class="hs-keyword">_</span><span class="hs-layout">)</span><span class="hs-layout">)</span>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{VV : a | VV == x}</span><span class="hs-varid">x</span></a> 
</pre>
<p>Don’t worry, they are perfectly <em>safe</em> as LiquidHaskell will make
sure we <em>only</em> call these operators on non-empty <code>SList</code>s. For example,</p>
<pre><span class="hs-linenum">205: </span><a class="annot" href="#"><span class="annottext">{v : [GHC.Types.Char] | len v &gt;= 0}</span><span class="hs-definition">okHd</span></a>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | size v &gt; 0}
-&gt; {v : [GHC.Types.Char] | len v &gt;= 0}</span><span class="hs-varid">hd</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | v == LazyQueue.okList &amp;&amp; size v &gt; 0}</span><span class="hs-varid">okList</span></a>       <span class="hs-comment">-- accepted</span>
<span class="hs-linenum">206: </span>
<span class="hs-linenum">207: </span><a class="annot" href="#"><span class="annottext">{VV : [GHC.Types.Char] | len VV &gt;= 0}</span><span class="hs-definition">badHd</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | size v &gt; 0}
-&gt; {v : [GHC.Types.Char] | len v &gt;= 0}</span><span class="hs-varid">hd</span></a> <span class="hs-layout">(</span><span class="hs-error"><a class="annot" href="#"><span class="annottext">x1:{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | size v &gt; 0}
-&gt; {v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | size v == size x1 - 1}</span><span class="hs-varid">tl</span></a></span><span class="hs-error"> </span><span class="hs-error"><a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | v == LazyQueue.okList &amp;&amp; size v &gt; 0}</span><span class="hs-varid">okList</span></a></span><span class="hs-layout">)</span>  <span class="hs-comment">-- rejected</span>
</pre>
<h2 id="queue-type">Queue Type</h2>
<p>Now, it is quite straightforward to define the <code>Queue</code> type, as a pair of lists,
<code>front</code> and <code>back</code>, such that the latter is always smaller than the former:</p>
<pre><span class="hs-linenum">218: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">data</span> <span class="hs-conid">Queue</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">=</span> <span class="hs-conid">Q</span> <span class="hs-layout">{</span>
<span class="hs-linenum">219: </span>       <span class="hs-varid">front</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">SList</span> <span class="hs-varid">a</span> 
<span class="hs-linenum">220: </span>     <span class="hs-layout">,</span> <span class="hs-varid">back</span>  <span class="hs-keyglyph">::</span> <span class="hs-conid">SListLE</span> <span class="hs-varid">a</span> <span class="hs-layout">(</span><span class="hs-varid">size</span> <span class="hs-varid">front</span><span class="hs-layout">)</span>
<span class="hs-linenum">221: </span>     <span class="hs-layout">}</span>
<span class="hs-linenum">222: </span>  <span class="hs-keyword">@-}</span>
</pre>
<p>Where the alias <code>SListLE a L</code> corresponds to lists with less than <code>N</code> elements:</p>
<pre><span class="hs-linenum">228: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">SListLE</span> <span class="hs-varid">a</span> <span class="hs-conid">N</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">SList</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">|</span> <span class="hs-varid">size</span> <span class="hs-varid">v</span> <span class="hs-varop">&lt;=</span> <span class="hs-conid">N</span><span class="hs-layout">}</span> <span class="hs-keyword">@-}</span>
</pre>
<p>As a quick check, notice that we <em>cannot represent illegal Queues</em>:</p>
<pre><span class="hs-linenum">234: </span><a class="annot" href="#"><span class="annottext">{VV : (LazyQueue.Queue [GHC.Types.Char]) | 0 &lt; qsize VV}</span><span class="hs-definition">okQ</span></a>  <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:(LazyQueue.SList [GHC.Types.Char])
-&gt; x2:{v : (LazyQueue.SList [GHC.Types.Char]) | size v &lt;= size x1}
-&gt; {v : (LazyQueue.Queue [GHC.Types.Char]) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}</span><span class="hs-conid">Q</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | v == LazyQueue.okList &amp;&amp; size v &gt; 0}</span><span class="hs-varid">okList</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList [GHC.Types.Char]) | size v == 0}</span><span class="hs-varid">nil</span></a>  <span class="hs-comment">-- accepted, |front| &gt; |back| </span>
<span class="hs-linenum">235: </span>
<span class="hs-linenum">236: </span><a class="annot" href="#"><span class="annottext">{VV : (LazyQueue.Queue [GHC.Types.Char]) | 0 &lt; qsize VV}</span><span class="hs-definition">badQ</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:(LazyQueue.SList [GHC.Types.Char])
-&gt; x2:{v : (LazyQueue.SList [GHC.Types.Char]) | size v &lt;= size x1}
-&gt; {v : (LazyQueue.Queue [GHC.Types.Char]) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}</span><span class="hs-conid">Q</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList [GHC.Types.Char]) | size v == 0}</span><span class="hs-varid">nil</span></a> <span class="hs-error"><a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList {v : [GHC.Types.Char] | len v &gt;= 0}) | v == LazyQueue.okList &amp;&amp; size v &gt; 0}</span><span class="hs-varid">okList</span></a></span>  <span class="hs-comment">-- rejected, |front| &lt; |back|</span>
</pre>
<p><strong>To Measure Queue Size</strong> let us define a function</p>
<pre><span class="hs-linenum">242: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">measure</span> <span class="hs-varid">qsize</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">243: </span><span class="hs-definition">qsize</span>         <span class="hs-keyglyph">::</span> <span class="hs-conid">Queue</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">Int</span>
<span class="hs-linenum">244: </span><a class="annot" href="#"><span class="annottext">forall a.
x1:(LazyQueue.Queue a) -&gt; {VV : GHC.Types.Int | VV == qsize x1}</span><span class="hs-definition">qsize</span></a> <span class="hs-layout">(</span><span class="hs-conid">Q</span> <span class="hs-varid">l</span> <span class="hs-varid">r</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:(LazyQueue.SList a)
-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}</span><span class="hs-varid">size</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == l}</span><span class="hs-varid">l</span></a> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int
-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Int | v == x1 + x2}</span><span class="hs-varop">+</span></a> <a class="annot" href="#"><span class="annottext">x1:(LazyQueue.SList a)
-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}</span><span class="hs-varid">size</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == r &amp;&amp; size v &lt;= size l}</span><span class="hs-varid">r</span></a>
</pre>
<p>This will prove helpful to define <code>Queue</code>s of a given size <code>N</code> and
non-empty <code>Queue</code>s (from which values can be safely removed.)</p>
<pre><span class="hs-linenum">251: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">QueueN</span> <span class="hs-varid">a</span> <span class="hs-conid">N</span> <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Queue</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">|</span> <span class="hs-conid">N</span> <span class="hs-keyglyph">=</span> <span class="hs-varid">qsize</span> <span class="hs-varid">v</span><span class="hs-layout">}</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">252: </span><span class="hs-keyword">{-@</span> <span class="hs-keyword">type</span> <span class="hs-conid">NEQueue</span> <span class="hs-varid">a</span>  <span class="hs-keyglyph">=</span> <span class="hs-layout">{</span><span class="hs-varid">v</span><span class="hs-conop">:</span><span class="hs-conid">Queue</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">|</span> <span class="hs-num">0</span> <span class="hs-varop">&lt;</span> <span class="hs-varid">qsize</span> <span class="hs-varid">v</span><span class="hs-layout">}</span> <span class="hs-keyword">@-}</span>
</pre>
<h2 id="queue-operations">Queue Operations</h2>
<p>Almost there! Now all that remains is to define the <code>Queue</code> API. The
code below is more or less identical to Okasaki’s (I prefer <code>front</code>
and <code>back</code> to his <code>left</code> and <code>right</code>.)</p>
<p><strong>The Empty Queue</strong> is simply one where both <code>front</code> and <code>back</code> are <code>nil</code>.</p>
<pre><span class="hs-linenum">267: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">emp</span> <span class="hs-keyglyph">::</span> <span class="hs-conid">QueueN</span> <span class="hs-varid">a</span> <span class="hs-num">0</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">268: </span><a class="annot" href="#"><span class="annottext">forall a. {v : (LazyQueue.Queue a) | 0 == qsize v}</span><span class="hs-definition">emp</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1}
-&gt; {v : (LazyQueue.Queue a) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}</span><span class="hs-conid">Q</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | size v == 0}</span><span class="hs-varid">nil</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | size v == 0}</span><span class="hs-varid">nil</span></a>
</pre>
<p><strong>To Insert</strong> an element we just <code>cons</code> it to the <code>back</code> list, and call
the <em>smart constructor</em> <code>makeq</code> to ensure that the balance invariant holds:</p>
<pre><span class="hs-linenum">275: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">insert</span>       <span class="hs-keyglyph">::</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">q</span><span class="hs-conop">:</span><span class="hs-conid">Queue</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">QueueN</span> <span class="hs-varid">a</span> <span class="hs-keyword">{qsize q + 1}</span>   <span class="hs-keyword">@-}</span>
<span class="hs-linenum">276: </span><a class="annot" href="#"><span class="annottext">forall a.
a
-&gt; x2:(LazyQueue.Queue a)
-&gt; {v : (LazyQueue.Queue a) | qsize x2 + 1 == qsize v}</span><span class="hs-definition">insert</span></a> <a class="annot" href="#"><span class="annottext">a</span><span class="hs-varid">e</span></a> <span class="hs-layout">(</span><span class="hs-conid">Q</span> <span class="hs-varid">f</span> <span class="hs-varid">b</span><span class="hs-layout">)</span> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1 + 1}
-&gt; {v : (LazyQueue.Queue a) | size x1 + size v == qsize v}</span><span class="hs-varid">makeq</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == f}</span><span class="hs-varid">f</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{VV : a | VV == e}</span><span class="hs-varid">e</span></a> <a class="annot" href="#"><span class="annottext">a
-&gt; x2:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size v + 1}</span><span class="hs-varop">`cons`</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f}</span><span class="hs-varid">b</span></a><span class="hs-layout">)</span>
</pre>
<p><strong>To Remove</strong> an element we pop it off the <code>front</code> by using <code>hd</code> and <code>tl</code>.
Notice that the <code>remove</code> is only called on non-empty <code>Queue</code>s, which together
with the key balance invariant, ensures that the calls to <code>hd</code> and <code>tl</code> are safe.</p>
<pre><span class="hs-linenum">284: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">remove</span>       <span class="hs-keyglyph">::</span> <span class="hs-varid">q</span><span class="hs-conop">:</span><span class="hs-conid">NEQueue</span> <span class="hs-varid">a</span> <span class="hs-keyglyph">-&gt;</span> <span class="hs-layout">(</span><span class="hs-varid">a</span><span class="hs-layout">,</span> <span class="hs-conid">QueueN</span> <span class="hs-varid">a</span> <span class="hs-keyword">{qsize q - 1}</span><span class="hs-layout">)</span> <span class="hs-keyword">@-}</span>
<span class="hs-linenum">285: </span><a class="annot" href="#"><span class="annottext">forall a.
x1:{v : (LazyQueue.Queue a) | 0 &lt; qsize v}
-&gt; (a, {v : (LazyQueue.Queue a) | qsize x1 - 1 == qsize v})</span><span class="hs-definition">remove</span></a> <span class="hs-layout">(</span><span class="hs-conid">Q</span> <span class="hs-varid">f</span> <span class="hs-varid">b</span><span class="hs-layout">)</span>   <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">forall a b &lt;p2 :: a b -&gt; Prop&gt;.
x1:a
-&gt; x2:{VV : b&lt;p2 x1&gt; | true}
-&gt; {v : (a, b)&lt;\x6 VV -&gt; p2 x6&gt; | fst v == x1 &amp;&amp; x_Tuple22 v == x2 &amp;&amp; snd v == x2 &amp;&amp; x_Tuple21 v == x1}</span><span class="hs-layout">(</span></a><a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | size v &gt; 0} -&gt; a</span><span class="hs-varid">hd</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == f}</span><span class="hs-varid">f</span></a><span class="hs-layout">,</span> <a class="annot" href="#"><span class="annottext">x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1 + 1}
-&gt; {v : (LazyQueue.Queue a) | size x1 + size v == qsize v}</span><span class="hs-varid">makeq</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">x1:{v : (LazyQueue.SList a) | size v &gt; 0}
-&gt; {v : (LazyQueue.SList a) | size v == size x1 - 1}</span><span class="hs-varid">tl</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == f}</span><span class="hs-varid">f</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f}</span><span class="hs-varid">b</span></a><span class="hs-layout">)</span>
</pre>
<p><em>Aside:</em> Why didn’t we (or Okasaki) use a pattern match here?</p>
<p><strong>To Ensure the Invariant</strong> we use the smart constructor <code>makeq</code>,
which is where the heavy lifting, such as it is, happens. The
constructor takes two lists, the front <code>f</code> and back <code>b</code> and if they
are balanced, directly returns the <code>Queue</code>, and otherwise transfers
the elements from <code>b</code> over using <code>rot</code>ate.</p>
<pre><span class="hs-linenum">297: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">makeq</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">f</span><span class="hs-conop">:</span><span class="hs-conid">SList</span> <span class="hs-varid">a</span>
<span class="hs-linenum">298: </span>          <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span><span class="hs-conop">:</span><span class="hs-conid">SListLE</span> <span class="hs-varid">a</span> <span class="hs-keyword">{size f + 1 }</span>
<span class="hs-linenum">299: </span>          <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">QueueN</span> <span class="hs-varid">a</span> <span class="hs-keyword">{size f + size b}</span>
<span class="hs-linenum">300: </span>  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">301: </span><a class="annot" href="#"><span class="annottext">forall a.
x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1 + 1}
-&gt; {v : (LazyQueue.Queue a) | size x1 + size x2 == qsize v}</span><span class="hs-definition">makeq</span></a> <a class="annot" href="#"><span class="annottext">(LazyQueue.SList a)</span><span class="hs-varid">f</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | size v &lt;= size f + 1}</span><span class="hs-varid">b</span></a> 
<span class="hs-linenum">302: </span>  <span class="hs-keyglyph">|</span> <a class="annot" href="#"><span class="annottext">x1:(LazyQueue.SList a)
-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}</span><span class="hs-varid">size</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f + 1}</span><span class="hs-varid">b</span></a> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int
-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 &lt;= v}</span><span class="hs-varop">&lt;=</span></a> <a class="annot" href="#"><span class="annottext">x1:(LazyQueue.SList a)
-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}</span><span class="hs-varid">size</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == f}</span><span class="hs-varid">f</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1}
-&gt; {v : (LazyQueue.Queue a) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}</span><span class="hs-conid">Q</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == f}</span><span class="hs-varid">f</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f + 1}</span><span class="hs-varid">b</span></a>
<span class="hs-linenum">303: </span>  <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span>        <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v &lt;= size x1}
-&gt; {v : (LazyQueue.Queue a) | qsize v == size x1 + size x2 &amp;&amp; front v == x1 &amp;&amp; back v == x2}</span><span class="hs-conid">Q</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">forall a.
x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v == 1 + size x1}
-&gt; x3:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size x1 + size x2 + size x3}</span><span class="hs-varid">rot</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == f}</span><span class="hs-varid">f</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == b &amp;&amp; size v &lt;= size f + 1}</span><span class="hs-varid">b</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | size v == 0}</span><span class="hs-varid">nil</span></a><span class="hs-layout">)</span> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | size v == 0}</span><span class="hs-varid">nil</span></a>
</pre>
<p><strong>The Rotate</strong> function is only called when the <code>back</code> is one larger
than the <code>front</code> (we never let things drift beyond that). It is
arranged so that it the <code>hd</code> is built up fast, before the entire
computation finishes; which, combined with laziness provides the
efficient worst-case guarantee.</p>
<pre><span class="hs-linenum">313: </span><span class="hs-keyword">{-@</span> <span class="hs-varid">rot</span> <span class="hs-keyglyph">::</span> <span class="hs-varid">f</span><span class="hs-conop">:</span><span class="hs-conid">SList</span> <span class="hs-varid">a</span>
<span class="hs-linenum">314: </span>        <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">b</span><span class="hs-conop">:</span><span class="hs-conid">SListN</span> <span class="hs-keyword">_</span> <span class="hs-keyword">{1 + size f}</span>
<span class="hs-linenum">315: </span>        <span class="hs-keyglyph">-&gt;</span> <span class="hs-varid">a</span><span class="hs-conop">:</span><span class="hs-conid">SList</span> <span class="hs-keyword">_</span>
<span class="hs-linenum">316: </span>        <span class="hs-keyglyph">-&gt;</span> <span class="hs-conid">SListN</span> <span class="hs-keyword">_</span> <span class="hs-keyword">{size f + size b + size a}</span>
<span class="hs-linenum">317: </span>  <span class="hs-keyword">@-}</span>
<span class="hs-linenum">318: </span><a class="annot" href="#"><span class="annottext">forall a.
x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v == 1 + size x1}
-&gt; x3:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size x1 + size x2 + size x3}</span><span class="hs-definition">rot</span></a> <a class="annot" href="#"><span class="annottext">(LazyQueue.SList a)</span><span class="hs-varid">f</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | size v == 1 + size f}</span><span class="hs-varid">b</span></a> <a class="annot" href="#"><span class="annottext">(LazyQueue.SList a)</span><span class="hs-varid">a</span></a>
<span class="hs-linenum">319: </span>  <span class="hs-keyglyph">|</span> <a class="annot" href="#"><span class="annottext">x1:(LazyQueue.SList a)
-&gt; {v : GHC.Types.Int | v == size x1 &amp;&amp; v &gt;= 0}</span><span class="hs-varid">size</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == f}</span><span class="hs-varid">f</span></a> <a class="annot" href="#"><span class="annottext">x1:GHC.Types.Int
-&gt; x2:GHC.Types.Int -&gt; {v : GHC.Types.Bool | Prop v &lt;=&gt; x1 == v}</span><span class="hs-varop">==</span></a> <a class="annot" href="#"><span class="annottext">{v : GHC.Types.Int | v == (0  :  int)}</span><span class="hs-num">0</span></a> <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | size v &gt; 0} -&gt; a</span><span class="hs-varid">hd</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == b &amp;&amp; size v == 1 + size f}</span><span class="hs-varid">b</span></a> <a class="annot" href="#"><span class="annottext">a
-&gt; x2:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size v + 1}</span><span class="hs-varop">`cons`</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == a}</span><span class="hs-varid">a</span></a>
<span class="hs-linenum">320: </span>  <span class="hs-keyglyph">|</span> <span class="hs-varid">otherwise</span>   <span class="hs-keyglyph">=</span> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | size v &gt; 0} -&gt; a</span><span class="hs-varid">hd</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == f}</span><span class="hs-varid">f</span></a> <a class="annot" href="#"><span class="annottext">a
-&gt; x2:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size v + 1}</span><span class="hs-varop">`cons`</span></a> <a class="annot" href="#"><span class="annottext">forall a.
x1:(LazyQueue.SList a)
-&gt; x2:{v : (LazyQueue.SList a) | size v == 1 + size x1}
-&gt; x3:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size x1 + size x2 + size x3}</span><span class="hs-varid">rot</span></a> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">x1:{v : (LazyQueue.SList a) | size v &gt; 0}
-&gt; {v : (LazyQueue.SList a) | size v == size x1 - 1}</span><span class="hs-varid">tl</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == f}</span><span class="hs-varid">f</span></a><span class="hs-layout">)</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">x1:{v : (LazyQueue.SList a) | size v &gt; 0}
-&gt; {v : (LazyQueue.SList a) | size v == size x1 - 1}</span><span class="hs-varid">tl</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == b &amp;&amp; size v == 1 + size f}</span><span class="hs-varid">b</span></a><span class="hs-layout">)</span> <span class="hs-layout">(</span><a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | size v &gt; 0} -&gt; a</span><span class="hs-varid">hd</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == b &amp;&amp; size v == 1 + size f}</span><span class="hs-varid">b</span></a> <a class="annot" href="#"><span class="annottext">a
-&gt; x2:(LazyQueue.SList a)
-&gt; {v : (LazyQueue.SList a) | size v == size v + 1}</span><span class="hs-varop">`cons`</span></a> <a class="annot" href="#"><span class="annottext">{v : (LazyQueue.SList a) | v == a}</span><span class="hs-varid">a</span></a><span class="hs-layout">)</span>
</pre>
<h2 id="conclusion">Conclusion</h2>
<p>Well there you have it; Okasaki’s beautiful lazy Queue, with the
invariants easily expressed and checked with LiquidHaskell. I find
this example particularly interesting because the refinements express
invariants that are critical for efficiency, and furthermore the code
introspects on the <code>size</code> in order to guarantee the invariants. Plus,
it’s just marginally more complicated than <code>append</code> and so, (I hope!)
was easy to follow.</p>
                <hr>
                <ul class="pager">
                    
                    
                </ul>

                <div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url        = 'https://ucsd-progsys.github.io/liquidhaskell-blog/2015/01/30/okasakis-lazy-queue.lhs';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = '/2015/01/30/okasakis-lazy-queue.lhs';           // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');
        s.src = '//liquidhaskell.disqus.com/embed.js';  // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </div>
        </div>
    </div>
</article>

        </div>
        <div id="footer">
        </div>
      <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="https://ucsd-progsys.github.io/liquidhaskell-blog/feed.xml" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/ranjitjhala" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://plus.google.com/u/0/106612421534244742464" data-datatype="json" data-type="GET" data-target="#frame" class="reload" id="clickme" target="_blank">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-google-plus fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/ucsd-progsys" target="_blank">
                            <span class="fa-stack fa-lg">

                              <i class="fa fa-arrow-circle-o-down"></i>
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
		    
                </ul>
                <p class="copyright text-muted">
                
                  Copyright &copy; Ranjit Jhala 2016-17.
                
                  Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>,
                  template by <a href="http://lucumr.pocoo.org">Armin Ronacher</a>,
                  suggest improvements <a href="https://github.com/ucsd-progsys/liquidhaskell-blog/">here</a>.
                </p>
            </div>
        </div>
    </div>
</footer>


<!-- jQuery -->
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/jquery.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/spaceg.stylesheets.min.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/bootstrap.min.js"></script>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/anim.js"></script>
<script src="https://ucsd-progsys.github.io/liquidhaskell-blog/static/js/scripts.js"></script>

    </body>
</html>
